<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - interactive - raycasting - points</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="src/style/main.css">
    <script src="src/lib/d3.v5.min.js"></script>
    <script src="src/lib/three.min.js"></script>
    <script src="src/lib/stats.min.js"></script>
</head>

<body>
<div id="container"></div>
<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive - raycasting - points </div>

<script>

    function draw(data) {
        let renderer, scene, camera, stats;
        let pointclouds;
        let raycaster;
        let intersection = null;
        let spheresIndex = 0;
        let clock;
        let toggle = 0;

        const pointer = new THREE.Vector2();
        const spheres = [];

        const threshold = 0.1;
        const pointSize = 0.05;

        const rotateY = new THREE.Matrix4().makeRotationY(0.005);

        init();
        animate();

        function generatePointCloudGeometry(data) {

            const geometry = new THREE.BufferGeometry();
            const numPoints = data.length;

            const positions = new Float32Array(numPoints * 3);
            const colors = new Float32Array(numPoints * 3);

            data.forEach((d,k)=>{

                positions[3 * k] = d.x;
                positions[3 * k + 1] = d.y;
                positions[3 * k + 2] = d.z;

                const color = new THREE.Color(d3.color(d.color??'white') + '');
                colors[3 * k] = color.r;
                colors[3 * k + 1] = color.g;
                colors[3 * k + 2] = color.b;

            });

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeBoundingBox();

            return geometry;

        }

        function generatePointcloud(data) {

            const geometry = generatePointCloudGeometry(data);
            const material = new THREE.PointsMaterial({size: pointSize, vertexColors: true});

            return new THREE.Points(geometry, material);

        }

        function init() {

            const container = document.getElementById('container');

            scene = new THREE.Scene();

            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(10, 10, 10);
            camera.lookAt(scene.position);
            camera.updateMatrix();

            //

            const pcBuffer = generatePointcloud(data);
            pcBuffer.scale.set(10, 10, 10);
            pcBuffer.position.set(-5, -5, -5);
            scene.add(pcBuffer);

            let geo = new THREE.BoxGeometry( 10, 10 , 10 );
            const object = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( 0xff0000 ) );
            const box = new THREE.BoxHelper( object, 0xffff00 );
            scene.add( box );


            pointclouds = [pcBuffer];

            //

            const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});

            for (let i = 0; i < 40; i++) {

                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(sphere);
                spheres.push(sphere);

            }

            //

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            //

            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = threshold;

            //

            stats = new Stats();
            container.appendChild(stats.dom);

            //

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointermove', onPointerMove);

        }

        function onPointerMove(event) {

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            render();
            stats.update();

        }

        function render() {

            camera.applyMatrix4(rotateY);
            camera.updateMatrixWorld();

            raycaster.setFromCamera(pointer, camera);

            const intersections = raycaster.intersectObjects(pointclouds);
            intersection = (intersections.length) > 0 ? intersections[0] : null;

            if (toggle > 0.02 && intersection !== null) {

                spheres[spheresIndex].position.copy(intersection.point);
                spheres[spheresIndex].scale.set(1, 1, 1);
                spheresIndex = (spheresIndex + 1) % spheres.length;

                toggle = 0;

            }

            for (let i = 0; i < spheres.length; i++) {

                const sphere = spheres[i];
                sphere.scale.multiplyScalar(0.98);
                sphere.scale.clampScalar(0.01, 1);

            }

            toggle += clock.getDelta();

            renderer.render(scene, camera);

        }
    }

</script>

<script src="src/lib/underscore-min.js"></script>
<script src="src/js/setting.js"></script>
<script src="src/js/main.js"></script>

</body>

</html>
