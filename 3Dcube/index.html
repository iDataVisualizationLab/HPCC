<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - interactive - raycasting - points</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="src/style/main.css">
    <script src="src/lib/d3.v5.min.js"></script>
    <script src="src/lib/three.min.js"></script>
    <script src="src/lib/stats.min.js"></script>
    <script src="src/lib/dat.gui.min.js"></script>
</head>

<body>
<div id="container"></div>
<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive -
    raycasting - points
</div>
<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size ;

				gl_Position = projectionMatrix * mvPosition;

			}


</script>

<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D pointTexture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );

				gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

			}


</script>
<script>

    function draw(data) {
        let renderer, scene, camera, stats;
        let pointclouds, boundary_o, boundary;
        let raycaster;
        let intersection = null;
        let spheresIndex = 0;
        let clock;
        let toggle = 0;
        let settings = {
            'x': 0,
            'y': 1,
            'z': -1,
            'size': -2,
            'Point size':2,
            'Time scale': 2,
        };
        const listAxis = {'Time': -1};
        serviceLists.forEach(s => listAxis[s.text] = s.id);
        let axisData = [{text: 'mem_power', x: -2.5, y: -5, z: -5 * settings['Time scale']}, {
            text: 'mem_usage',
            x: -5,
            y: -2.5,
            z: -5 * settings['Time scale'],
            rx: Math.PI / 2,
            ry: Math.PI / 2
        }, {
            text: 'time',
            x: -5,
            y: -5,
            z: -2.5 * settings['Time scale'],
            rx: -Math.PI / 2,
            rz: -Math.PI / 2,
            ry: -Math.PI / 2
        }];

        const pointer = new THREE.Vector2();
        const spheres = [];

        const threshold = 0.1;

        const rotateY = new THREE.Matrix4().makeRotationY(0.005);

        init();
        animate();

        function addText(texts) {
            const loader = new THREE.FontLoader();
            loader.load('./src/fonts/helvetiker_regular.typeface.json', function (font) {

                const color = 0xDDCB21;
                texts.forEach(t => {
                    if (t.el)
                        scene.remove(t.el);
                    const matLite = new THREE.MeshBasicMaterial({
                        color: color,
                        side: THREE.DoubleSide
                    });

                    const message = t.text;

                    const shapes = font.generateShapes(message, 0.4);

                    const geometry = new THREE.ShapeGeometry(shapes);

                    geometry.computeBoundingBox();

                    const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                    geometry.translate(xMid, 0, 0);

                    // make shape ( N.B. edge view not visible )

                    const text = new THREE.Mesh(geometry, matLite);
                    text.position.x = t.x;
                    text.position.y = t.y;
                    text.position.z = t.z;
                    text.rotation.x = t.rx ?? 0;
                    text.rotation.y = t.ry ?? 0;
                    text.rotation.z = t.rz ?? 0;
                    text.name = t.text;
                    t.el = text;
                    scene.add(text);
                })
            })
        }

        function generatePointCloudGeometry(data) {

            const geometry = new THREE.BufferGeometry();
            const numPoints = data.length;

            const positions = new Float32Array(numPoints * 3);
            const colors = new Float32Array(numPoints * 3);
            const sizes = new Float32Array(numPoints);

            data.forEach((d, k) => {

                positions[3 * k] = d.x;
                positions[3 * k + 1] = d.y;
                positions[3 * k + 2] = d.z;

                const color = new THREE.Color(d3.color(d.color ?? 'white') + '');
                colors[3 * k] = color.r;
                colors[3 * k + 1] = color.g;
                colors[3 * k + 2] = color.b;
                sizes[k] = d.size??settings['Point size'];
            });

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.computeBoundingBox();

            return geometry;

        }

        function generatePointcloud(data) {

            const geometry = generatePointCloudGeometry(data);
            // const materialPoint = new THREE.PointsMaterial({size: settings['Point size'], vertexColors: true});
            const materialPoint = new THREE.ShaderMaterial( {
                uniforms: {
                    color: {value: new THREE.Color(0xffffff)},
                    pointTexture: { value: new THREE.TextureLoader().load( './src/texture/circle.png' ) }
                },
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                depthTest: false

            } );

            return new THREE.Points(geometry, materialPoint);

        }

        function createPanel() {

            const panel = new dat.GUI({width: 310});

            const folder1 = panel.addFolder('Axis');
            const folder2 = panel.addFolder('Graphic');
            const folder3 = panel.addFolder('Filter');

            folder1.add(settings, 'x', listAxis).onChange(updateModelRender({updateAxis: true}));
            folder1.add(settings, 'y', listAxis).onChange(updateModelRender({updateAxis: true}));
            folder1.add(settings, 'z', listAxis).onChange(updateModelRender({updateAxis: true}));
            folder1.add(settings, 'size', {'none': -2, ...listAxis}).onChange(updateModelRender({updateAxis: true}));

            folder2.add(settings, 'Point size', 0.5, 10, 0.5).onChange(updateModelRender());
            folder2.add(settings, 'Time scale', 0.2, 10, 0.1).onChange(updateModelScale);

            folder1.open();
            folder2.open();

        }

        function handleData() {
            const listremap = {};
            Object.keys(listAxis).forEach(k => listremap[listAxis[k]] = k);
            axisData[0].text = listremap[settings.x];
            axisData[1].text = listremap[settings.y];
            axisData[2].text = listremap[settings.z];
            data.forEach(d => {
                d.x = d.data[settings.x];
                d.y = d.data[settings.y];
                d.z = d.data[settings.z];
            })
        }

        function init() {

            const container = document.getElementById('container');

            scene = new THREE.Scene();

            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(10, 10, 10);
            camera.lookAt(scene.position);
            camera.updateMatrix();

            //
            handleData();

            const dataBuffer = generatePointcloud(data);
            dataBuffer.scale.set(10, 10, 10 * settings['Time scale']);
            dataBuffer.position.set(-5, -5, -5 * settings['Time scale']);
            scene.add(dataBuffer);

            //

            addText(axisData)

            //

            let geo = new THREE.BoxGeometry(10, 10, 10);
            boundary_o = new THREE.Mesh(geo, new THREE.MeshBasicMaterial(0xff0000));
            boundary_o.scale.set(1, 1, settings['Time scale'])
            boundary = new THREE.BoxHelper(boundary_o, 0xffff00);
            boundary.name = 'boundary'
            scene.add(boundary);


            pointclouds = [dataBuffer];

            //

            const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});

            for (let i = 0; i < 40; i++) {

                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(sphere);
                spheres.push(sphere);

            }

            //

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            //

            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = threshold;

            //

            stats = new Stats();
            container.appendChild(stats.dom);

            //

            createPanel();

            //

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointermove', onPointerMove);

        }

        function updateModelRender(opt) {
            if (opt && opt.updateAxis) {
                return () => {
                    update();
                    addText(axisData)
                }
            } else {
                return () => {
                    update();
                }
            }

            function update() {
                handleData();
                const position = pointclouds[0].geometry.attributes.position.array;
                let scaleSize = d3.scaleLinear().domain([0.1,1]);
                if ((+settings.size)===-2)
                    scaleSize=()=>1;
                data.forEach((d, i) => {
                    position[3 * i] = d.x;
                    position[3 * i + 1] = d.y;
                    position[3 * i + 2] = d.z;
                    pointclouds[0].geometry.attributes.size.array[i] = scaleSize(d.data[settings.size])*settings['Point size'];
                });

                pointclouds[0].geometry.attributes.position.needsUpdate = true;
                pointclouds[0].geometry.attributes.size.needsUpdate = true;
                pointclouds[0].geometry.boundingBox = null;
                pointclouds[0].geometry.computeBoundingSphere();
            }
        }

        function updateModelScale() {
            axisData[0].z = -5 * settings['Time scale'];
            axisData[1].z = -5 * settings['Time scale'];
            axisData[2].z = -2.5 * settings['Time scale'];
            axisData.forEach(a => {
                if (a.el)
                    a.el.position.z = a.z
            });
            pointclouds[0].scale.set(10, 10, 10 * settings['Time scale']);
            pointclouds[0].position.set(-5, -5, -5 * settings['Time scale']);
            boundary_o.scale.set(1, 1, settings['Time scale']);
            boundary.update();
        }

        function onPointerMove(event) {

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            render();
            stats.update();

        }

        function render() {

            camera.applyMatrix4(rotateY);
            camera.updateMatrixWorld();

            raycaster.setFromCamera(pointer, camera);

            const intersections = raycaster.intersectObjects(pointclouds);
            intersection = (intersections.length) > 0 ? intersections[0] : null;

            if (toggle > 0.02 && intersection !== null) {
                debugger
                spheres[spheresIndex].position.copy(intersection.point);
                spheres[spheresIndex].scale.set(1, 1, 1);
                spheresIndex = (spheresIndex + 1) % spheres.length;

                toggle = 0;

            }

            for (let i = 0; i < spheres.length; i++) {

                const sphere = spheres[i];
                sphere.scale.multiplyScalar(0.98);
                sphere.scale.clampScalar(0.01, 1);

            }

            toggle += clock.getDelta();

            renderer.render(scene, camera);

        }
    }

</script>

<script src="src/lib/underscore-min.js"></script>
<script src="src/js/setting.js"></script>
<script src="src/js/main.js"></script>

</body>

</html>
