(function () {
    'use strict';

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var underscore = createCommonjsModule(function (module, exports) {
        //     Underscore.js 1.9.1
        //     http://underscorejs.org
        //     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
        //     Underscore may be freely distributed under the MIT license.

        (function() {

            // Baseline setup
            // --------------

            // Establish the root object, `window` (`self`) in the browser, `global`
            // on the server, or `this` in some virtual machines. We use `self`
            // instead of `window` for `WebWorker` support.
            var root = typeof self == 'object' && self.self === self && self ||
                typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal ||
                this ||
                {};

            // Save the previous value of the `_` variable.
            var previousUnderscore = root._;

            // Save bytes in the minified (but not gzipped) version:
            var ArrayProto = Array.prototype, ObjProto = Object.prototype;
            var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

            // Create quick reference variables for speed access to core prototypes.
            var push = ArrayProto.push,
                slice = ArrayProto.slice,
                toString = ObjProto.toString,
                hasOwnProperty = ObjProto.hasOwnProperty;

            // All **ECMAScript 5** native function implementations that we hope to use
            // are declared here.
            var nativeIsArray = Array.isArray,
                nativeKeys = Object.keys,
                nativeCreate = Object.create;

            // Naked function reference for surrogate-prototype-swapping.
            var Ctor = function(){};

            // Create a safe reference to the Underscore object for use below.
            var _ = function(obj) {
                if (obj instanceof _) return obj;
                if (!(this instanceof _)) return new _(obj);
                this._wrapped = obj;
            };

            // Export the Underscore object for **Node.js**, with
            // backwards-compatibility for their old module API. If we're in
            // the browser, add `_` as a global object.
            // (`nodeType` is checked to ensure that `module`
            // and `exports` are not HTML elements.)
            if ( !exports.nodeType) {
                if ( !module.nodeType && module.exports) {
                    exports = module.exports = _;
                }
                exports._ = _;
            } else {
                root._ = _;
            }

            // Current version.
            _.VERSION = '1.9.1';

            // Internal function that returns an efficient (for current engines) version
            // of the passed-in callback, to be repeatedly applied in other Underscore
            // functions.
            var optimizeCb = function(func, context, argCount) {
                if (context === void 0) return func;
                switch (argCount == null ? 3 : argCount) {
                    case 1: return function(value) {
                        return func.call(context, value);
                    };
                    // The 2-argument case is omitted because we’re not using it.
                    case 3: return function(value, index, collection) {
                        return func.call(context, value, index, collection);
                    };
                    case 4: return function(accumulator, value, index, collection) {
                        return func.call(context, accumulator, value, index, collection);
                    };
                }
                return function() {
                    return func.apply(context, arguments);
                };
            };

            var builtinIteratee;

            // An internal function to generate callbacks that can be applied to each
            // element in a collection, returning the desired result — either `identity`,
            // an arbitrary callback, a property matcher, or a property accessor.
            var cb = function(value, context, argCount) {
                if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
                if (value == null) return _.identity;
                if (_.isFunction(value)) return optimizeCb(value, context, argCount);
                if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
                return _.property(value);
            };

            // External wrapper for our callback generator. Users may customize
            // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
            // This abstraction hides the internal-only argCount argument.
            _.iteratee = builtinIteratee = function(value, context) {
                return cb(value, context, Infinity);
            };

            // Some functions take a variable number of arguments, or a few expected
            // arguments at the beginning and then a variable number of values to operate
            // on. This helper accumulates all remaining arguments past the function’s
            // argument length (or an explicit `startIndex`), into an array that becomes
            // the last argument. Similar to ES6’s "rest parameter".
            var restArguments = function(func, startIndex) {
                startIndex = startIndex == null ? func.length - 1 : +startIndex;
                return function() {
                    var length = Math.max(arguments.length - startIndex, 0),
                        rest = Array(length),
                        index = 0;
                    for (; index < length; index++) {
                        rest[index] = arguments[index + startIndex];
                    }
                    switch (startIndex) {
                        case 0: return func.call(this, rest);
                        case 1: return func.call(this, arguments[0], rest);
                        case 2: return func.call(this, arguments[0], arguments[1], rest);
                    }
                    var args = Array(startIndex + 1);
                    for (index = 0; index < startIndex; index++) {
                        args[index] = arguments[index];
                    }
                    args[startIndex] = rest;
                    return func.apply(this, args);
                };
            };

            // An internal function for creating a new object that inherits from another.
            var baseCreate = function(prototype) {
                if (!_.isObject(prototype)) return {};
                if (nativeCreate) return nativeCreate(prototype);
                Ctor.prototype = prototype;
                var result = new Ctor;
                Ctor.prototype = null;
                return result;
            };

            var shallowProperty = function(key) {
                return function(obj) {
                    return obj == null ? void 0 : obj[key];
                };
            };

            var has = function(obj, path) {
                return obj != null && hasOwnProperty.call(obj, path);
            };

            var deepGet = function(obj, path) {
                var length = path.length;
                for (var i = 0; i < length; i++) {
                    if (obj == null) return void 0;
                    obj = obj[path[i]];
                }
                return length ? obj : void 0;
            };

            // Helper for collection methods to determine whether a collection
            // should be iterated as an array or as an object.
            // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
            // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
            var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
            var getLength = shallowProperty('length');
            var isArrayLike = function(collection) {
                var length = getLength(collection);
                return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
            };

            // Collection Functions
            // --------------------

            // The cornerstone, an `each` implementation, aka `forEach`.
            // Handles raw objects in addition to array-likes. Treats all
            // sparse array-likes as if they were dense.
            _.each = _.forEach = function(obj, iteratee, context) {
                iteratee = optimizeCb(iteratee, context);
                var i, length;
                if (isArrayLike(obj)) {
                    for (i = 0, length = obj.length; i < length; i++) {
                        iteratee(obj[i], i, obj);
                    }
                } else {
                    var keys = _.keys(obj);
                    for (i = 0, length = keys.length; i < length; i++) {
                        iteratee(obj[keys[i]], keys[i], obj);
                    }
                }
                return obj;
            };

            // Return the results of applying the iteratee to each element.
            _.map = _.collect = function(obj, iteratee, context) {
                iteratee = cb(iteratee, context);
                var keys = !isArrayLike(obj) && _.keys(obj),
                    length = (keys || obj).length,
                    results = Array(length);
                for (var index = 0; index < length; index++) {
                    var currentKey = keys ? keys[index] : index;
                    results[index] = iteratee(obj[currentKey], currentKey, obj);
                }
                return results;
            };

            // Create a reducing function iterating left or right.
            var createReduce = function(dir) {
                // Wrap code that reassigns argument variables in a separate function than
                // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
                var reducer = function(obj, iteratee, memo, initial) {
                    var keys = !isArrayLike(obj) && _.keys(obj),
                        length = (keys || obj).length,
                        index = dir > 0 ? 0 : length - 1;
                    if (!initial) {
                        memo = obj[keys ? keys[index] : index];
                        index += dir;
                    }
                    for (; index >= 0 && index < length; index += dir) {
                        var currentKey = keys ? keys[index] : index;
                        memo = iteratee(memo, obj[currentKey], currentKey, obj);
                    }
                    return memo;
                };

                return function(obj, iteratee, memo, context) {
                    var initial = arguments.length >= 3;
                    return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
                };
            };

            // **Reduce** builds up a single result from a list of values, aka `inject`,
            // or `foldl`.
            _.reduce = _.foldl = _.inject = createReduce(1);

            // The right-associative version of reduce, also known as `foldr`.
            _.reduceRight = _.foldr = createReduce(-1);

            // Return the first value which passes a truth test. Aliased as `detect`.
            _.find = _.detect = function(obj, predicate, context) {
                var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
                var key = keyFinder(obj, predicate, context);
                if (key !== void 0 && key !== -1) return obj[key];
            };

            // Return all the elements that pass a truth test.
            // Aliased as `select`.
            _.filter = _.select = function(obj, predicate, context) {
                var results = [];
                predicate = cb(predicate, context);
                _.each(obj, function(value, index, list) {
                    if (predicate(value, index, list)) results.push(value);
                });
                return results;
            };

            // Return all the elements for which a truth test fails.
            _.reject = function(obj, predicate, context) {
                return _.filter(obj, _.negate(cb(predicate)), context);
            };

            // Determine whether all of the elements match a truth test.
            // Aliased as `all`.
            _.every = _.all = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var keys = !isArrayLike(obj) && _.keys(obj),
                    length = (keys || obj).length;
                for (var index = 0; index < length; index++) {
                    var currentKey = keys ? keys[index] : index;
                    if (!predicate(obj[currentKey], currentKey, obj)) return false;
                }
                return true;
            };

            // Determine if at least one element in the object matches a truth test.
            // Aliased as `any`.
            _.some = _.any = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var keys = !isArrayLike(obj) && _.keys(obj),
                    length = (keys || obj).length;
                for (var index = 0; index < length; index++) {
                    var currentKey = keys ? keys[index] : index;
                    if (predicate(obj[currentKey], currentKey, obj)) return true;
                }
                return false;
            };

            // Determine if the array or object contains a given item (using `===`).
            // Aliased as `includes` and `include`.
            _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
                if (!isArrayLike(obj)) obj = _.values(obj);
                if (typeof fromIndex != 'number' || guard) fromIndex = 0;
                return _.indexOf(obj, item, fromIndex) >= 0;
            };

            // Invoke a method (with arguments) on every item in a collection.
            _.invoke = restArguments(function(obj, path, args) {
                var contextPath, func;
                if (_.isFunction(path)) {
                    func = path;
                } else if (_.isArray(path)) {
                    contextPath = path.slice(0, -1);
                    path = path[path.length - 1];
                }
                return _.map(obj, function(context) {
                    var method = func;
                    if (!method) {
                        if (contextPath && contextPath.length) {
                            context = deepGet(context, contextPath);
                        }
                        if (context == null) return void 0;
                        method = context[path];
                    }
                    return method == null ? method : method.apply(context, args);
                });
            });

            // Convenience version of a common use case of `map`: fetching a property.
            _.pluck = function(obj, key) {
                return _.map(obj, _.property(key));
            };

            // Convenience version of a common use case of `filter`: selecting only objects
            // containing specific `key:value` pairs.
            _.where = function(obj, attrs) {
                return _.filter(obj, _.matcher(attrs));
            };

            // Convenience version of a common use case of `find`: getting the first object
            // containing specific `key:value` pairs.
            _.findWhere = function(obj, attrs) {
                return _.find(obj, _.matcher(attrs));
            };

            // Return the maximum element (or element-based computation).
            _.max = function(obj, iteratee, context) {
                var result = -Infinity, lastComputed = -Infinity,
                    value, computed;
                if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
                    obj = isArrayLike(obj) ? obj : _.values(obj);
                    for (var i = 0, length = obj.length; i < length; i++) {
                        value = obj[i];
                        if (value != null && value > result) {
                            result = value;
                        }
                    }
                } else {
                    iteratee = cb(iteratee, context);
                    _.each(obj, function(v, index, list) {
                        computed = iteratee(v, index, list);
                        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                            result = v;
                            lastComputed = computed;
                        }
                    });
                }
                return result;
            };

            // Return the minimum element (or element-based computation).
            _.min = function(obj, iteratee, context) {
                var result = Infinity, lastComputed = Infinity,
                    value, computed;
                if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
                    obj = isArrayLike(obj) ? obj : _.values(obj);
                    for (var i = 0, length = obj.length; i < length; i++) {
                        value = obj[i];
                        if (value != null && value < result) {
                            result = value;
                        }
                    }
                } else {
                    iteratee = cb(iteratee, context);
                    _.each(obj, function(v, index, list) {
                        computed = iteratee(v, index, list);
                        if (computed < lastComputed || computed === Infinity && result === Infinity) {
                            result = v;
                            lastComputed = computed;
                        }
                    });
                }
                return result;
            };

            // Shuffle a collection.
            _.shuffle = function(obj) {
                return _.sample(obj, Infinity);
            };

            // Sample **n** random values from a collection using the modern version of the
            // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
            // If **n** is not specified, returns a single random element.
            // The internal `guard` argument allows it to work with `map`.
            _.sample = function(obj, n, guard) {
                if (n == null || guard) {
                    if (!isArrayLike(obj)) obj = _.values(obj);
                    return obj[_.random(obj.length - 1)];
                }
                var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
                var length = getLength(sample);
                n = Math.max(Math.min(n, length), 0);
                var last = length - 1;
                for (var index = 0; index < n; index++) {
                    var rand = _.random(index, last);
                    var temp = sample[index];
                    sample[index] = sample[rand];
                    sample[rand] = temp;
                }
                return sample.slice(0, n);
            };

            // Sort the object's values by a criterion produced by an iteratee.
            _.sortBy = function(obj, iteratee, context) {
                var index = 0;
                iteratee = cb(iteratee, context);
                return _.pluck(_.map(obj, function(value, key, list) {
                    return {
                        value: value,
                        index: index++,
                        criteria: iteratee(value, key, list)
                    };
                }).sort(function(left, right) {
                    var a = left.criteria;
                    var b = right.criteria;
                    if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                    }
                    return left.index - right.index;
                }), 'value');
            };

            // An internal function used for aggregate "group by" operations.
            var group = function(behavior, partition) {
                return function(obj, iteratee, context) {
                    var result = partition ? [[], []] : {};
                    iteratee = cb(iteratee, context);
                    _.each(obj, function(value, index) {
                        var key = iteratee(value, index, obj);
                        behavior(result, value, key);
                    });
                    return result;
                };
            };

            // Groups the object's values by a criterion. Pass either a string attribute
            // to group by, or a function that returns the criterion.
            _.groupBy = group(function(result, value, key) {
                if (has(result, key)) result[key].push(value); else result[key] = [value];
            });

            // Indexes the object's values by a criterion, similar to `groupBy`, but for
            // when you know that your index values will be unique.
            _.indexBy = group(function(result, value, key) {
                result[key] = value;
            });

            // Counts instances of an object that group by a certain criterion. Pass
            // either a string attribute to count by, or a function that returns the
            // criterion.
            _.countBy = group(function(result, value, key) {
                if (has(result, key)) result[key]++; else result[key] = 1;
            });

            var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
            // Safely create a real, live array from anything iterable.
            _.toArray = function(obj) {
                if (!obj) return [];
                if (_.isArray(obj)) return slice.call(obj);
                if (_.isString(obj)) {
                    // Keep surrogate pair characters together
                    return obj.match(reStrSymbol);
                }
                if (isArrayLike(obj)) return _.map(obj, _.identity);
                return _.values(obj);
            };

            // Return the number of elements in an object.
            _.size = function(obj) {
                if (obj == null) return 0;
                return isArrayLike(obj) ? obj.length : _.keys(obj).length;
            };

            // Split a collection into two arrays: one whose elements all satisfy the given
            // predicate, and one whose elements all do not satisfy the predicate.
            _.partition = group(function(result, value, pass) {
                result[pass ? 0 : 1].push(value);
            }, true);

            // Array Functions
            // ---------------

            // Get the first element of an array. Passing **n** will return the first N
            // values in the array. Aliased as `head` and `take`. The **guard** check
            // allows it to work with `_.map`.
            _.first = _.head = _.take = function(array, n, guard) {
                if (array == null || array.length < 1) return n == null ? void 0 : [];
                if (n == null || guard) return array[0];
                return _.initial(array, array.length - n);
            };

            // Returns everything but the last entry of the array. Especially useful on
            // the arguments object. Passing **n** will return all the values in
            // the array, excluding the last N.
            _.initial = function(array, n, guard) {
                return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
            };

            // Get the last element of an array. Passing **n** will return the last N
            // values in the array.
            _.last = function(array, n, guard) {
                if (array == null || array.length < 1) return n == null ? void 0 : [];
                if (n == null || guard) return array[array.length - 1];
                return _.rest(array, Math.max(0, array.length - n));
            };

            // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
            // Especially useful on the arguments object. Passing an **n** will return
            // the rest N values in the array.
            _.rest = _.tail = _.drop = function(array, n, guard) {
                return slice.call(array, n == null || guard ? 1 : n);
            };

            // Trim out all falsy values from an array.
            _.compact = function(array) {
                return _.filter(array, Boolean);
            };

            // Internal implementation of a recursive `flatten` function.
            var flatten = function(input, shallow, strict, output) {
                output = output || [];
                var idx = output.length;
                for (var i = 0, length = getLength(input); i < length; i++) {
                    var value = input[i];
                    if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                        // Flatten current level of array or arguments object.
                        if (shallow) {
                            var j = 0, len = value.length;
                            while (j < len) output[idx++] = value[j++];
                        } else {
                            flatten(value, shallow, strict, output);
                            idx = output.length;
                        }
                    } else if (!strict) {
                        output[idx++] = value;
                    }
                }
                return output;
            };

            // Flatten out an array, either recursively (by default), or just one level.
            _.flatten = function(array, shallow) {
                return flatten(array, shallow, false);
            };

            // Return a version of the array that does not contain the specified value(s).
            _.without = restArguments(function(array, otherArrays) {
                return _.difference(array, otherArrays);
            });

            // Produce a duplicate-free version of the array. If the array has already
            // been sorted, you have the option of using a faster algorithm.
            // The faster algorithm will not work with an iteratee if the iteratee
            // is not a one-to-one function, so providing an iteratee will disable
            // the faster algorithm.
            // Aliased as `unique`.
            _.uniq = _.unique = function(array, isSorted, iteratee, context) {
                if (!_.isBoolean(isSorted)) {
                    context = iteratee;
                    iteratee = isSorted;
                    isSorted = false;
                }
                if (iteratee != null) iteratee = cb(iteratee, context);
                var result = [];
                var seen = [];
                for (var i = 0, length = getLength(array); i < length; i++) {
                    var value = array[i],
                        computed = iteratee ? iteratee(value, i, array) : value;
                    if (isSorted && !iteratee) {
                        if (!i || seen !== computed) result.push(value);
                        seen = computed;
                    } else if (iteratee) {
                        if (!_.contains(seen, computed)) {
                            seen.push(computed);
                            result.push(value);
                        }
                    } else if (!_.contains(result, value)) {
                        result.push(value);
                    }
                }
                return result;
            };

            // Produce an array that contains the union: each distinct element from all of
            // the passed-in arrays.
            _.union = restArguments(function(arrays) {
                return _.uniq(flatten(arrays, true, true));
            });

            // Produce an array that contains every item shared between all the
            // passed-in arrays.
            _.intersection = function(array) {
                var result = [];
                var argsLength = arguments.length;
                for (var i = 0, length = getLength(array); i < length; i++) {
                    var item = array[i];
                    if (_.contains(result, item)) continue;
                    var j;
                    for (j = 1; j < argsLength; j++) {
                        if (!_.contains(arguments[j], item)) break;
                    }
                    if (j === argsLength) result.push(item);
                }
                return result;
            };

            // Take the difference between one array and a number of other arrays.
            // Only the elements present in just the first array will remain.
            _.difference = restArguments(function(array, rest) {
                rest = flatten(rest, true, true);
                return _.filter(array, function(value){
                    return !_.contains(rest, value);
                });
            });

            // Complement of _.zip. Unzip accepts an array of arrays and groups
            // each array's elements on shared indices.
            _.unzip = function(array) {
                var length = array && _.max(array, getLength).length || 0;
                var result = Array(length);

                for (var index = 0; index < length; index++) {
                    result[index] = _.pluck(array, index);
                }
                return result;
            };

            // Zip together multiple lists into a single array -- elements that share
            // an index go together.
            _.zip = restArguments(_.unzip);

            // Converts lists into objects. Pass either a single array of `[key, value]`
            // pairs, or two parallel arrays of the same length -- one of keys, and one of
            // the corresponding values. Passing by pairs is the reverse of _.pairs.
            _.object = function(list, values) {
                var result = {};
                for (var i = 0, length = getLength(list); i < length; i++) {
                    if (values) {
                        result[list[i]] = values[i];
                    } else {
                        result[list[i][0]] = list[i][1];
                    }
                }
                return result;
            };

            // Generator function to create the findIndex and findLastIndex functions.
            var createPredicateIndexFinder = function(dir) {
                return function(array, predicate, context) {
                    predicate = cb(predicate, context);
                    var length = getLength(array);
                    var index = dir > 0 ? 0 : length - 1;
                    for (; index >= 0 && index < length; index += dir) {
                        if (predicate(array[index], index, array)) return index;
                    }
                    return -1;
                };
            };

            // Returns the first index on an array-like that passes a predicate test.
            _.findIndex = createPredicateIndexFinder(1);
            _.findLastIndex = createPredicateIndexFinder(-1);

            // Use a comparator function to figure out the smallest index at which
            // an object should be inserted so as to maintain order. Uses binary search.
            _.sortedIndex = function(array, obj, iteratee, context) {
                iteratee = cb(iteratee, context, 1);
                var value = iteratee(obj);
                var low = 0, high = getLength(array);
                while (low < high) {
                    var mid = Math.floor((low + high) / 2);
                    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
                }
                return low;
            };

            // Generator function to create the indexOf and lastIndexOf functions.
            var createIndexFinder = function(dir, predicateFind, sortedIndex) {
                return function(array, item, idx) {
                    var i = 0, length = getLength(array);
                    if (typeof idx == 'number') {
                        if (dir > 0) {
                            i = idx >= 0 ? idx : Math.max(idx + length, i);
                        } else {
                            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
                        }
                    } else if (sortedIndex && idx && length) {
                        idx = sortedIndex(array, item);
                        return array[idx] === item ? idx : -1;
                    }
                    if (item !== item) {
                        idx = predicateFind(slice.call(array, i, length), _.isNaN);
                        return idx >= 0 ? idx + i : -1;
                    }
                    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
                        if (array[idx] === item) return idx;
                    }
                    return -1;
                };
            };

            // Return the position of the first occurrence of an item in an array,
            // or -1 if the item is not included in the array.
            // If the array is large and already in sort order, pass `true`
            // for **isSorted** to use binary search.
            _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
            _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

            // Generate an integer Array containing an arithmetic progression. A port of
            // the native Python `range()` function. See
            // [the Python documentation](http://docs.python.org/library/functions.html#range).
            _.range = function(start, stop, step) {
                if (stop == null) {
                    stop = start || 0;
                    start = 0;
                }
                if (!step) {
                    step = stop < start ? -1 : 1;
                }

                var length = Math.max(Math.ceil((stop - start) / step), 0);
                var range = Array(length);

                for (var idx = 0; idx < length; idx++, start += step) {
                    range[idx] = start;
                }

                return range;
            };

            // Chunk a single array into multiple arrays, each containing `count` or fewer
            // items.
            _.chunk = function(array, count) {
                if (count == null || count < 1) return [];
                var result = [];
                var i = 0, length = array.length;
                while (i < length) {
                    result.push(slice.call(array, i, i += count));
                }
                return result;
            };

            // Function (ahem) Functions
            // ------------------

            // Determines whether to execute a function as a constructor
            // or a normal function with the provided arguments.
            var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
                if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
                var self = baseCreate(sourceFunc.prototype);
                var result = sourceFunc.apply(self, args);
                if (_.isObject(result)) return result;
                return self;
            };

            // Create a function bound to a given object (assigning `this`, and arguments,
            // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
            // available.
            _.bind = restArguments(function(func, context, args) {
                if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
                var bound = restArguments(function(callArgs) {
                    return executeBound(func, bound, context, this, args.concat(callArgs));
                });
                return bound;
            });

            // Partially apply a function by creating a version that has had some of its
            // arguments pre-filled, without changing its dynamic `this` context. _ acts
            // as a placeholder by default, allowing any combination of arguments to be
            // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
            _.partial = restArguments(function(func, boundArgs) {
                var placeholder = _.partial.placeholder;
                var bound = function() {
                    var position = 0, length = boundArgs.length;
                    var args = Array(length);
                    for (var i = 0; i < length; i++) {
                        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
                    }
                    while (position < arguments.length) args.push(arguments[position++]);
                    return executeBound(func, bound, this, this, args);
                };
                return bound;
            });

            _.partial.placeholder = _;

            // Bind a number of an object's methods to that object. Remaining arguments
            // are the method names to be bound. Useful for ensuring that all callbacks
            // defined on an object belong to it.
            _.bindAll = restArguments(function(obj, keys) {
                keys = flatten(keys, false, false);
                var index = keys.length;
                if (index < 1) throw new Error('bindAll must be passed function names');
                while (index--) {
                    var key = keys[index];
                    obj[key] = _.bind(obj[key], obj);
                }
            });

            // Memoize an expensive function by storing its results.
            _.memoize = function(func, hasher) {
                var memoize = function(key) {
                    var cache = memoize.cache;
                    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
                    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
                    return cache[address];
                };
                memoize.cache = {};
                return memoize;
            };

            // Delays a function for the given number of milliseconds, and then calls
            // it with the arguments supplied.
            _.delay = restArguments(function(func, wait, args) {
                return setTimeout(function() {
                    return func.apply(null, args);
                }, wait);
            });

            // Defers a function, scheduling it to run after the current call stack has
            // cleared.
            _.defer = _.partial(_.delay, _, 1);

            // Returns a function, that, when invoked, will only be triggered at most once
            // during a given window of time. Normally, the throttled function will run
            // as much as it can, without ever going more than once per `wait` duration;
            // but if you'd like to disable the execution on the leading edge, pass
            // `{leading: false}`. To disable execution on the trailing edge, ditto.
            _.throttle = function(func, wait, options) {
                var timeout, context, args, result;
                var previous = 0;
                if (!options) options = {};

                var later = function() {
                    previous = options.leading === false ? 0 : _.now();
                    timeout = null;
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                };

                var throttled = function() {
                    var now = _.now();
                    if (!previous && options.leading === false) previous = now;
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0 || remaining > wait) {
                        if (timeout) {
                            clearTimeout(timeout);
                            timeout = null;
                        }
                        previous = now;
                        result = func.apply(context, args);
                        if (!timeout) context = args = null;
                    } else if (!timeout && options.trailing !== false) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };

                throttled.cancel = function() {
                    clearTimeout(timeout);
                    previous = 0;
                    timeout = context = args = null;
                };

                return throttled;
            };

            // Returns a function, that, as long as it continues to be invoked, will not
            // be triggered. The function will be called after it stops being called for
            // N milliseconds. If `immediate` is passed, trigger the function on the
            // leading edge, instead of the trailing.
            _.debounce = function(func, wait, immediate) {
                var timeout, result;

                var later = function(context, args) {
                    timeout = null;
                    if (args) result = func.apply(context, args);
                };

                var debounced = restArguments(function(args) {
                    if (timeout) clearTimeout(timeout);
                    if (immediate) {
                        var callNow = !timeout;
                        timeout = setTimeout(later, wait);
                        if (callNow) result = func.apply(this, args);
                    } else {
                        timeout = _.delay(later, wait, this, args);
                    }

                    return result;
                });

                debounced.cancel = function() {
                    clearTimeout(timeout);
                    timeout = null;
                };

                return debounced;
            };

            // Returns the first function passed as an argument to the second,
            // allowing you to adjust arguments, run code before and after, and
            // conditionally execute the original function.
            _.wrap = function(func, wrapper) {
                return _.partial(wrapper, func);
            };

            // Returns a negated version of the passed-in predicate.
            _.negate = function(predicate) {
                return function() {
                    return !predicate.apply(this, arguments);
                };
            };

            // Returns a function that is the composition of a list of functions, each
            // consuming the return value of the function that follows.
            _.compose = function() {
                var args = arguments;
                var start = args.length - 1;
                return function() {
                    var i = start;
                    var result = args[start].apply(this, arguments);
                    while (i--) result = args[i].call(this, result);
                    return result;
                };
            };

            // Returns a function that will only be executed on and after the Nth call.
            _.after = function(times, func) {
                return function() {
                    if (--times < 1) {
                        return func.apply(this, arguments);
                    }
                };
            };

            // Returns a function that will only be executed up to (but not including) the Nth call.
            _.before = function(times, func) {
                var memo;
                return function() {
                    if (--times > 0) {
                        memo = func.apply(this, arguments);
                    }
                    if (times <= 1) func = null;
                    return memo;
                };
            };

            // Returns a function that will be executed at most one time, no matter how
            // often you call it. Useful for lazy initialization.
            _.once = _.partial(_.before, 2);

            _.restArguments = restArguments;

            // Object Functions
            // ----------------

            // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
            var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
            var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

            var collectNonEnumProps = function(obj, keys) {
                var nonEnumIdx = nonEnumerableProps.length;
                var constructor = obj.constructor;
                var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

                // Constructor is a special case.
                var prop = 'constructor';
                if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

                while (nonEnumIdx--) {
                    prop = nonEnumerableProps[nonEnumIdx];
                    if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
                        keys.push(prop);
                    }
                }
            };

            // Retrieve the names of an object's own properties.
            // Delegates to **ECMAScript 5**'s native `Object.keys`.
            _.keys = function(obj) {
                if (!_.isObject(obj)) return [];
                if (nativeKeys) return nativeKeys(obj);
                var keys = [];
                for (var key in obj) if (has(obj, key)) keys.push(key);
                // Ahem, IE < 9.
                if (hasEnumBug) collectNonEnumProps(obj, keys);
                return keys;
            };

            // Retrieve all the property names of an object.
            _.allKeys = function(obj) {
                if (!_.isObject(obj)) return [];
                var keys = [];
                for (var key in obj) keys.push(key);
                // Ahem, IE < 9.
                if (hasEnumBug) collectNonEnumProps(obj, keys);
                return keys;
            };

            // Retrieve the values of an object's properties.
            _.values = function(obj) {
                var keys = _.keys(obj);
                var length = keys.length;
                var values = Array(length);
                for (var i = 0; i < length; i++) {
                    values[i] = obj[keys[i]];
                }
                return values;
            };

            // Returns the results of applying the iteratee to each element of the object.
            // In contrast to _.map it returns an object.
            _.mapObject = function(obj, iteratee, context) {
                iteratee = cb(iteratee, context);
                var keys = _.keys(obj),
                    length = keys.length,
                    results = {};
                for (var index = 0; index < length; index++) {
                    var currentKey = keys[index];
                    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
                }
                return results;
            };

            // Convert an object into a list of `[key, value]` pairs.
            // The opposite of _.object.
            _.pairs = function(obj) {
                var keys = _.keys(obj);
                var length = keys.length;
                var pairs = Array(length);
                for (var i = 0; i < length; i++) {
                    pairs[i] = [keys[i], obj[keys[i]]];
                }
                return pairs;
            };

            // Invert the keys and values of an object. The values must be serializable.
            _.invert = function(obj) {
                var result = {};
                var keys = _.keys(obj);
                for (var i = 0, length = keys.length; i < length; i++) {
                    result[obj[keys[i]]] = keys[i];
                }
                return result;
            };

            // Return a sorted list of the function names available on the object.
            // Aliased as `methods`.
            _.functions = _.methods = function(obj) {
                var names = [];
                for (var key in obj) {
                    if (_.isFunction(obj[key])) names.push(key);
                }
                return names.sort();
            };

            // An internal function for creating assigner functions.
            var createAssigner = function(keysFunc, defaults) {
                return function(obj) {
                    var length = arguments.length;
                    if (defaults) obj = Object(obj);
                    if (length < 2 || obj == null) return obj;
                    for (var index = 1; index < length; index++) {
                        var source = arguments[index],
                            keys = keysFunc(source),
                            l = keys.length;
                        for (var i = 0; i < l; i++) {
                            var key = keys[i];
                            if (!defaults || obj[key] === void 0) obj[key] = source[key];
                        }
                    }
                    return obj;
                };
            };

            // Extend a given object with all the properties in passed-in object(s).
            _.extend = createAssigner(_.allKeys);

            // Assigns a given object with all the own properties in the passed-in object(s).
            // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
            _.extendOwn = _.assign = createAssigner(_.keys);

            // Returns the first key on an object that passes a predicate test.
            _.findKey = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var keys = _.keys(obj), key;
                for (var i = 0, length = keys.length; i < length; i++) {
                    key = keys[i];
                    if (predicate(obj[key], key, obj)) return key;
                }
            };

            // Internal pick helper function to determine if `obj` has key `key`.
            var keyInObj = function(value, key, obj) {
                return key in obj;
            };

            // Return a copy of the object only containing the whitelisted properties.
            _.pick = restArguments(function(obj, keys) {
                var result = {}, iteratee = keys[0];
                if (obj == null) return result;
                if (_.isFunction(iteratee)) {
                    if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
                    keys = _.allKeys(obj);
                } else {
                    iteratee = keyInObj;
                    keys = flatten(keys, false, false);
                    obj = Object(obj);
                }
                for (var i = 0, length = keys.length; i < length; i++) {
                    var key = keys[i];
                    var value = obj[key];
                    if (iteratee(value, key, obj)) result[key] = value;
                }
                return result;
            });

            // Return a copy of the object without the blacklisted properties.
            _.omit = restArguments(function(obj, keys) {
                var iteratee = keys[0], context;
                if (_.isFunction(iteratee)) {
                    iteratee = _.negate(iteratee);
                    if (keys.length > 1) context = keys[1];
                } else {
                    keys = _.map(flatten(keys, false, false), String);
                    iteratee = function(value, key) {
                        return !_.contains(keys, key);
                    };
                }
                return _.pick(obj, iteratee, context);
            });

            // Fill in a given object with default properties.
            _.defaults = createAssigner(_.allKeys, true);

            // Creates an object that inherits from the given prototype object.
            // If additional properties are provided then they will be added to the
            // created object.
            _.create = function(prototype, props) {
                var result = baseCreate(prototype);
                if (props) _.extendOwn(result, props);
                return result;
            };

            // Create a (shallow-cloned) duplicate of an object.
            _.clone = function(obj) {
                if (!_.isObject(obj)) return obj;
                return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
            };

            // Invokes interceptor with the obj, and then returns obj.
            // The primary purpose of this method is to "tap into" a method chain, in
            // order to perform operations on intermediate results within the chain.
            _.tap = function(obj, interceptor) {
                interceptor(obj);
                return obj;
            };

            // Returns whether an object has a given set of `key:value` pairs.
            _.isMatch = function(object, attrs) {
                var keys = _.keys(attrs), length = keys.length;
                if (object == null) return !length;
                var obj = Object(object);
                for (var i = 0; i < length; i++) {
                    var key = keys[i];
                    if (attrs[key] !== obj[key] || !(key in obj)) return false;
                }
                return true;
            };


            // Internal recursive comparison function for `isEqual`.
            var eq, deepEq;
            eq = function(a, b, aStack, bStack) {
                // Identical objects are equal. `0 === -0`, but they aren't identical.
                // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
                if (a === b) return a !== 0 || 1 / a === 1 / b;
                // `null` or `undefined` only equal to itself (strict comparison).
                if (a == null || b == null) return false;
                // `NaN`s are equivalent, but non-reflexive.
                if (a !== a) return b !== b;
                // Exhaust primitive checks
                var type = typeof a;
                if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
                return deepEq(a, b, aStack, bStack);
            };

            // Internal recursive comparison function for `isEqual`.
            deepEq = function(a, b, aStack, bStack) {
                // Unwrap any wrapped objects.
                if (a instanceof _) a = a._wrapped;
                if (b instanceof _) b = b._wrapped;
                // Compare `[[Class]]` names.
                var className = toString.call(a);
                if (className !== toString.call(b)) return false;
                switch (className) {
                    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
                    case '[object RegExp]':
                    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
                    case '[object String]':
                        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                        // equivalent to `new String("5")`.
                        return '' + a === '' + b;
                    case '[object Number]':
                        // `NaN`s are equivalent, but non-reflexive.
                        // Object(NaN) is equivalent to NaN.
                        if (+a !== +a) return +b !== +b;
                        // An `egal` comparison is performed for other numeric values.
                        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
                    case '[object Date]':
                    case '[object Boolean]':
                        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                        // millisecond representations. Note that invalid dates with millisecond representations
                        // of `NaN` are not equivalent.
                        return +a === +b;
                    case '[object Symbol]':
                        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
                }

                var areArrays = className === '[object Array]';
                if (!areArrays) {
                    if (typeof a != 'object' || typeof b != 'object') return false;

                    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
                    // from different frames are.
                    var aCtor = a.constructor, bCtor = b.constructor;
                    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                        _.isFunction(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
                        return false;
                    }
                }
                // Assume equality for cyclic structures. The algorithm for detecting cyclic
                // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

                // Initializing stack of traversed objects.
                // It's done here since we only need them for objects and arrays comparison.
                aStack = aStack || [];
                bStack = bStack || [];
                var length = aStack.length;
                while (length--) {
                    // Linear search. Performance is inversely proportional to the number of
                    // unique nested structures.
                    if (aStack[length] === a) return bStack[length] === b;
                }

                // Add the first object to the stack of traversed objects.
                aStack.push(a);
                bStack.push(b);

                // Recursively compare objects and arrays.
                if (areArrays) {
                    // Compare array lengths to determine if a deep comparison is necessary.
                    length = a.length;
                    if (length !== b.length) return false;
                    // Deep compare the contents, ignoring non-numeric properties.
                    while (length--) {
                        if (!eq(a[length], b[length], aStack, bStack)) return false;
                    }
                } else {
                    // Deep compare objects.
                    var keys = _.keys(a), key;
                    length = keys.length;
                    // Ensure that both objects contain the same number of properties before comparing deep equality.
                    if (_.keys(b).length !== length) return false;
                    while (length--) {
                        // Deep compare each member
                        key = keys[length];
                        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
                    }
                }
                // Remove the first object from the stack of traversed objects.
                aStack.pop();
                bStack.pop();
                return true;
            };

            // Perform a deep comparison to check if two objects are equal.
            _.isEqual = function(a, b) {
                return eq(a, b);
            };

            // Is a given array, string, or object empty?
            // An "empty" object has no enumerable own-properties.
            _.isEmpty = function(obj) {
                if (obj == null) return true;
                if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
                return _.keys(obj).length === 0;
            };

            // Is a given value a DOM element?
            _.isElement = function(obj) {
                return !!(obj && obj.nodeType === 1);
            };

            // Is a given value an array?
            // Delegates to ECMA5's native Array.isArray
            _.isArray = nativeIsArray || function(obj) {
                return toString.call(obj) === '[object Array]';
            };

            // Is a given variable an object?
            _.isObject = function(obj) {
                var type = typeof obj;
                return type === 'function' || type === 'object' && !!obj;
            };

            // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
            _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
                _['is' + name] = function(obj) {
                    return toString.call(obj) === '[object ' + name + ']';
                };
            });

            // Define a fallback version of the method in browsers (ahem, IE < 9), where
            // there isn't any inspectable "Arguments" type.
            if (!_.isArguments(arguments)) {
                _.isArguments = function(obj) {
                    return has(obj, 'callee');
                };
            }

            // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
            // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
            var nodelist = root.document && root.document.childNodes;
            if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
                _.isFunction = function(obj) {
                    return typeof obj == 'function' || false;
                };
            }

            // Is a given object a finite number?
            _.isFinite = function(obj) {
                return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
            };

            // Is the given value `NaN`?
            _.isNaN = function(obj) {
                return _.isNumber(obj) && isNaN(obj);
            };

            // Is a given value a boolean?
            _.isBoolean = function(obj) {
                return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
            };

            // Is a given value equal to null?
            _.isNull = function(obj) {
                return obj === null;
            };

            // Is a given variable undefined?
            _.isUndefined = function(obj) {
                return obj === void 0;
            };

            // Shortcut function for checking if an object has a given property directly
            // on itself (in other words, not on a prototype).
            _.has = function(obj, path) {
                if (!_.isArray(path)) {
                    return has(obj, path);
                }
                var length = path.length;
                for (var i = 0; i < length; i++) {
                    var key = path[i];
                    if (obj == null || !hasOwnProperty.call(obj, key)) {
                        return false;
                    }
                    obj = obj[key];
                }
                return !!length;
            };

            // Utility Functions
            // -----------------

            // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
            // previous owner. Returns a reference to the Underscore object.
            _.noConflict = function() {
                root._ = previousUnderscore;
                return this;
            };

            // Keep the identity function around for default iteratees.
            _.identity = function(value) {
                return value;
            };

            // Predicate-generating functions. Often useful outside of Underscore.
            _.constant = function(value) {
                return function() {
                    return value;
                };
            };

            _.noop = function(){};

            // Creates a function that, when passed an object, will traverse that object’s
            // properties down the given `path`, specified as an array of keys or indexes.
            _.property = function(path) {
                if (!_.isArray(path)) {
                    return shallowProperty(path);
                }
                return function(obj) {
                    return deepGet(obj, path);
                };
            };

            // Generates a function for a given object that returns a given property.
            _.propertyOf = function(obj) {
                if (obj == null) {
                    return function(){};
                }
                return function(path) {
                    return !_.isArray(path) ? obj[path] : deepGet(obj, path);
                };
            };

            // Returns a predicate for checking whether an object has a given set of
            // `key:value` pairs.
            _.matcher = _.matches = function(attrs) {
                attrs = _.extendOwn({}, attrs);
                return function(obj) {
                    return _.isMatch(obj, attrs);
                };
            };

            // Run a function **n** times.
            _.times = function(n, iteratee, context) {
                var accum = Array(Math.max(0, n));
                iteratee = optimizeCb(iteratee, context, 1);
                for (var i = 0; i < n; i++) accum[i] = iteratee(i);
                return accum;
            };

            // Return a random integer between min and max (inclusive).
            _.random = function(min, max) {
                if (max == null) {
                    max = min;
                    min = 0;
                }
                return min + Math.floor(Math.random() * (max - min + 1));
            };

            // A (possibly faster) way to get the current timestamp as an integer.
            _.now = Date.now || function() {
                return new Date().getTime();
            };

            // List of HTML entities for escaping.
            var escapeMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '`': '&#x60;'
            };
            var unescapeMap = _.invert(escapeMap);

            // Functions for escaping and unescaping strings to/from HTML interpolation.
            var createEscaper = function(map) {
                var escaper = function(match) {
                    return map[match];
                };
                // Regexes for identifying a key that needs to be escaped.
                var source = '(?:' + _.keys(map).join('|') + ')';
                var testRegexp = RegExp(source);
                var replaceRegexp = RegExp(source, 'g');
                return function(string) {
                    string = string == null ? '' : '' + string;
                    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
                };
            };
            _.escape = createEscaper(escapeMap);
            _.unescape = createEscaper(unescapeMap);

            // Traverses the children of `obj` along `path`. If a child is a function, it
            // is invoked with its parent as context. Returns the value of the final
            // child, or `fallback` if any child is undefined.
            _.result = function(obj, path, fallback) {
                if (!_.isArray(path)) path = [path];
                var length = path.length;
                if (!length) {
                    return _.isFunction(fallback) ? fallback.call(obj) : fallback;
                }
                for (var i = 0; i < length; i++) {
                    var prop = obj == null ? void 0 : obj[path[i]];
                    if (prop === void 0) {
                        prop = fallback;
                        i = length; // Ensure we don't continue iterating.
                    }
                    obj = _.isFunction(prop) ? prop.call(obj) : prop;
                }
                return obj;
            };

            // Generate a unique integer id (unique within the entire client session).
            // Useful for temporary DOM ids.
            var idCounter = 0;
            _.uniqueId = function(prefix) {
                var id = ++idCounter + '';
                return prefix ? prefix + id : id;
            };

            // By default, Underscore uses ERB-style template delimiters, change the
            // following template settings to use alternative delimiters.
            _.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };

            // When customizing `templateSettings`, if you don't want to define an
            // interpolation, evaluation or escaping regex, we need one that is
            // guaranteed not to match.
            var noMatch = /(.)^/;

            // Certain characters need to be escaped so that they can be put into a
            // string literal.
            var escapes = {
                "'": "'",
                '\\': '\\',
                '\r': 'r',
                '\n': 'n',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
            };

            var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

            var escapeChar = function(match) {
                return '\\' + escapes[match];
            };

            // JavaScript micro-templating, similar to John Resig's implementation.
            // Underscore templating handles arbitrary delimiters, preserves whitespace,
            // and correctly escapes quotes within interpolated code.
            // NB: `oldSettings` only exists for backwards compatibility.
            _.template = function(text, settings, oldSettings) {
                if (!settings && oldSettings) settings = oldSettings;
                settings = _.defaults({}, settings, _.templateSettings);

                // Combine delimiters into one regular expression via alternation.
                var matcher = RegExp([
                    (settings.escape || noMatch).source,
                    (settings.interpolate || noMatch).source,
                    (settings.evaluate || noMatch).source
                ].join('|') + '|$', 'g');

                // Compile the template source, escaping string literals appropriately.
                var index = 0;
                var source = "__p+='";
                text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
                    index = offset + match.length;

                    if (escape) {
                        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                    } else if (interpolate) {
                        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                    } else if (evaluate) {
                        source += "';\n" + evaluate + "\n__p+='";
                    }

                    // Adobe VMs need the match returned to produce the correct offset.
                    return match;
                });
                source += "';\n";

                // If a variable is not specified, place data values in local scope.
                if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

                source = "var __t,__p='',__j=Array.prototype.join," +
                    "print=function(){__p+=__j.call(arguments,'');};\n" +
                    source + 'return __p;\n';

                var render;
                try {
                    render = new Function(settings.variable || 'obj', '_', source);
                } catch (e) {
                    e.source = source;
                    throw e;
                }

                var template = function(data) {
                    return render.call(this, data, _);
                };

                // Provide the compiled source as a convenience for precompilation.
                var argument = settings.variable || 'obj';
                template.source = 'function(' + argument + '){\n' + source + '}';

                return template;
            };

            // Add a "chain" function. Start chaining a wrapped Underscore object.
            _.chain = function(obj) {
                var instance = _(obj);
                instance._chain = true;
                return instance;
            };

            // OOP
            // ---------------
            // If Underscore is called as a function, it returns a wrapped object that
            // can be used OO-style. This wrapper holds altered versions of all the
            // underscore functions. Wrapped objects may be chained.

            // Helper function to continue chaining intermediate results.
            var chainResult = function(instance, obj) {
                return instance._chain ? _(obj).chain() : obj;
            };

            // Add your own custom functions to the Underscore object.
            _.mixin = function(obj) {
                _.each(_.functions(obj), function(name) {
                    var func = _[name] = obj[name];
                    _.prototype[name] = function() {
                        var args = [this._wrapped];
                        push.apply(args, arguments);
                        return chainResult(this, func.apply(_, args));
                    };
                });
                return _;
            };

            // Add all of the Underscore functions to the wrapper object.
            _.mixin(_);

            // Add all mutator Array functions to the wrapper.
            _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
                var method = ArrayProto[name];
                _.prototype[name] = function() {
                    var obj = this._wrapped;
                    method.apply(obj, arguments);
                    if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
                    return chainResult(this, obj);
                };
            });

            // Add all accessor Array functions to the wrapper.
            _.each(['concat', 'join', 'slice'], function(name) {
                var method = ArrayProto[name];
                _.prototype[name] = function() {
                    return chainResult(this, method.apply(this._wrapped, arguments));
                };
            });

            // Extracts the result from a wrapped and chained object.
            _.prototype.value = function() {
                return this._wrapped;
            };

            // Provide unwrapping proxy for some methods used in engine operations
            // such as arithmetic and JSON stringification.
            _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

            _.prototype.toString = function() {
                return String(this._wrapped);
            };
        }());
    });
    var underscore_1 = underscore._;

    class Normalizer {
        constructor(points) {
            this.points = points.map(e=>e.slice());
            //pass the data over
            this.points.forEach((p, i)=>{
                p.data = points[i].data;
            });
            let nds = this.nds = underscore.unzip(this.points);
            let maxD = this.maxD = [];
            let minD = this.minD = [];
            let rangeD = this.rangeD = [];
            let normalizedD = this.normalizedD = [];
            nds.forEach((d, i)=>{
                maxD[i] = underscore.max(d);
                minD[i] = underscore.min(d);
                rangeD[i] = (maxD[i] != minD[i]) ? maxD[i] - minD[i] : 1;
                normalizedD[i] = d.map(e=>(e-minD[i])/rangeD[i]);
            });
            let length = this.points.length;
            this.normalizedPoints = [];
            for (let i = 0; i < length; i++) {
                this.normalizedPoints[i] = [];
                for (let j = 0; j < this.nds.length; j++) {
                    this.normalizedPoints[i][j] = normalizedD[j][i];
                }
            }
            //Add one step to pass the data over if there is.
            for (let i = 0; i < length; i++) {
                this.normalizedPoints[i].data = this.points[i].data;
            }
        }

        /**
         * Input a set of points in this scale range [0, 1] and will be scaled back to
         * - Original scale ([minX, maxX], [minY, maxY], [minZ, maxZ])
         * @param points
         */
        scaleBackPoints(points) {
            return points.map(point => {
                return this.scaleBackPoint(point);
            });
        }

        /**
         * Input a single point in this scale range [0, 1] and will be scaled back to
         * - Original scale ([minX, maxX], [minY, maxY], [minZ, maxZ])
         * @param points
         */
        scaleBackPoint(point) {
            let newPoint = point.map((vs, i)=>{
                let v = this.rangeD[i]*vs + this.minD[i];
                return v;
            });
            return newPoint;
        }
    }

    class LeaderBinner {
        constructor(points, radius) {
            //TODO: Should check if there are more than 3 unique values here or even after the binning.
            //TODO: May need to clone the points to avoid modifying it, but we don't do to reserve other data or to make the process faster
            // //Clone these to avoid modifying them
            // this.points = points.map(p=>p.slice(0));
            this.points = points;
            this.radius = radius;
        }

        get leaders() {
            let self = this;
            let theLeaders = [];
            //find all the leaders
            this.points.forEach(point => {
                let leader = closestLeader(theLeaders, point);
                if (!leader) {
                    let newLeader = [];
                    newLeader.site = point.slice();
                    theLeaders.push(newLeader);
                }
            });
            //now do this again to set the closest leader.
            this.points.forEach(point => {
                let leader = closestLeader(theLeaders, point);
                leader.push(point);
            });
            return theLeaders;

            function closestLeader(leaders, point) {
                let length = leaders.length;
                let minDistance = Number.MAX_SAFE_INTEGER;
                let theLeader = null;
                for (let i = 0; i < length; ++i) {
                    let l = leaders[i];
                    let d = distance(l.site, point);
                    if (d < self.radius) {
                        if (d < minDistance) {
                            minDistance = d;
                            theLeader = l;
                        }
                    }
                }
                return theLeader;
            }
        }
    }

    function distance(a, b) {
        let sumsquared = 0;
        for (let i = 0; i < a.length; i++) {
            let d = a[i] - b[i];
            if(!Number.isNaN(d)){
                sumsquared += d*d;
            }
        }
        //For computer storage issue, some coordinates of the same distance may return different distances if we use long floating point
        //So take only 10 digits after the floating points=> this is precise enough and still have the same values for two different lines of the same distance
        return Math.round(Math.sqrt(sumsquared) * Math.pow(10, 10)) / Math.pow(10, 10);
    }

    // https://gist.github.com/bmershon/25a74f7b1c7cbd07e7456af1d2c07da1

    /**
     * This function create the pairs between node and its links.
     *
     * @param links
     * @returns [["nodeX,nodeY": Array(numberOfLinksRelatedToTheNodes)]]
     */
    function pairNodeLinks(links) {
        let nestedByNodes = {};
        links.forEach(l => {
            if(!l.source.join){
                debugger
                console.log(l);
                console.log(links);
            }
            let sourceKey = l.source.join(',');
            if (!nestedByNodes[sourceKey]) {
                nestedByNodes[sourceKey] = [];
            }
            nestedByNodes[sourceKey].push(l);
            let targetKey = l.target.join(',');
            if (!nestedByNodes[targetKey]) {
                nestedByNodes[targetKey] = [];
            }
            nestedByNodes[targetKey].push(l);
        });
        //Pair the results
        let pairedResults = underscore.pairs(nestedByNodes);
        return pairedResults;
    }
    /**
     * This function returns all vertices with degree greater than or equal 2
     * @param tree
     */
    function getAllV2OrGreaterFromTree(tree) {
        let pairedResults = pairNodeLinks(tree.links);
        //Get all pairs with length >= 2 (V2)
        let allGTEV2 = pairedResults.filter(p => p[1].length >= 2);
        return allGTEV2.map(v => v[0].split(',').map(Number));
    }

    /**
     * Create a graph from mesh
     * @param triangles is inform of set of triangles as the result from delaunay triangulations
     */
    function createGraph(tetrahedra, weights) {

        function makeLink(sourceId, targetId, weight) {
            return {"source": sourceId, "target": targetId, "weight": weight};
        }

        let graph = {};
        graph.nodes = [];
        graph.links = [];
        //Creating nodes
        tetrahedra.forEach(t => {
            t.forEach(id => {
                // TODO: Check this because this may not be needed since the tetrahedra here are just simly points (not the triangles like in the 2D, 3D case)
                // if (!idExists(graph.nodes, id)) {
                //
                // }
                graph.nodes.push(makeNode(id));
            });
        });

        //Creating links
        tetrahedra.forEach(t => {
            for (let i = 0; i < t.length - 1; i++) {
                let p1 = t[i];
                for (let j = i + 1; j < t.length; j++) {
                    let p2 = t[j];
                    let id1 = p1;
                    let id2 = p2;
                    let dist = distance$1(p1, p2, weights);
                    let link = makeLink(id1, id2, dist);
                    // TODO: Check this because this may not be needed since the tetrahedra here are just simly points (not the triangles like in the 2D, 3D case)
                    // if (!linkExists(graph.links, link)) {
                    //     graph.links.push(link);
                    // }
                    graph.links.push(link);
                }
            }
        });
        return graph;
    }

    function distance$1(a, b, weights) {
        let totalSumSquared = 0;
        if (!weights) {
            for (let i = 0; i < a.length; i++) {
                let diff = (a[i] - b[i]) * (a[i] - b[i]);
                if (!Number.isNaN(diff)) {
                    totalSumSquared += diff;
                }
            }
        } else {
            for (let i = 0; i < a.length; i++) {
                let diff = (a[i] - b[i]) * (a[i] - b[i]);
                if (!Number.isNaN(diff)) {
                    totalSumSquared += diff * weights[i];
                }
            }
        }
        //For computer storage issue, some coordinates of the same distance may return different distances if we use long floating point
        //So take only 10 digits after the floating points=> this is precise enough and still have the same values for two different lines of the same distance
        return Math.round(Math.sqrt(totalSumSquared) * Math.pow(10, 10)) / Math.pow(10, 10);
    }

    function equalPoints(id1, id2) {
        for (let i = 0; i < id1.length; i++) {
            if (id1[i] !== id2[i]) {
                return false;
            }
        }
        return true;
    }

    function pointExists(points, point) {
        for (let i = 0; i < points.length; i++) {
            let point1 = points[i];
            if (equalPoints(point1, point)) {
                return true;
            }
        }
        return false;
    }

    function makeNode(id) {
        return {"id": id};
    }

    /**
     * create the mst
     * @param graph: in form of nodes and links
     * @returns {{nodes: (selection_nodes|nodes), links: Array}}
     */
    function mst(graph) {
        let vertices = graph.nodes,
            edges = graph.links.slice(0),
            selectedEdges = [],
            forest = new DisjointSet();

        // Each vertex begins "disconnected" and isolated from all the others.
        vertices.forEach((vertex) => {
            forest.makeSet(vertex.id);
        });

        // Sort edges in descending order of weight. We will pop edges beginning
        // from the end of the array.
        edges.sort((a, b) => {
            return -(a.weight - b.weight);
        });

        while (edges.length && forest.size() > 1) {
            let edge = edges.pop();

            if (forest.find(edge.source) !== forest.find(edge.target)) {
                forest.union(edge.source, edge.target);
                selectedEdges.push(edge);
            }
        }

        return {
            nodes: vertices,
            links: selectedEdges
        }
    }

    //<editor-fold desc="This section is for the disjoint set">
    function DisjointSet() {
        this.index_ = {};
    }

    function Node(id) {
        this.id_ = id;
        this.parent_ = this;
        this.rank_ = 0;
    }

    DisjointSet.prototype.makeSet = function (id) {
        if (!this.index_[id]) {
            let created = new Node(id);
            this.index_[id] = created;
        }
    };

    // Returns the id of the representative element of this set that (id)
    // belongs to.
    DisjointSet.prototype.find = function (id) {
        if (this.index_[id] === undefined) {
            return undefined;
        }

        let current = this.index_[id].parent_;
        while (current !== current.parent_) {
            current = current.parent_;
        }
        return current.id_;
    };

    DisjointSet.prototype.union = function (x, y) {
        let xRoot = this.index_[this.find(x)];
        let yRoot = this.index_[this.find(y)];

        if (xRoot === undefined || yRoot === undefined || xRoot === yRoot) {
            // x and y already belong to the same set.
            return;
        }

        if (xRoot.rank < yRoot.rank) { // Move x into the set y is a member of.
            xRoot.parent_ = yRoot;
        } else if (yRoot.rank_ < xRoot.rank_) { // Move y into the set x is a member of.
            yRoot.parent_ = xRoot;
        } else { // Arbitrarily choose to move y into the set x is a member of.
            yRoot.parent_ = xRoot;
            xRoot.rank_++;
        }
    };

    // Returns the current number of disjoint sets.
    DisjointSet.prototype.size = function () {
        let uniqueIndices = {};
        Object.keys(this.index_).forEach((id) => {
            uniqueIndices[id] = true;
        });
        return Object.keys(uniqueIndices).length;
    };
    //</editor-fold>

    function y(r,t){var n=r.length*t;if(0===r.length)throw new Error("quantile requires at least one data point.");if(t<0||t>1)throw new Error("quantiles must be between 0 and 1");return 1===t?r[r.length-1]:0===t?r[0]:n%1!=0?r[Math.ceil(n)-1]:r.length%2==0?(r[n-1]+r[n])/2:r[n]}function b(r,t,n,e){for(n=n||0,e=e||r.length-1;e>n;){if(e-n>600){var o=e-n+1,a=t-n+1,h=Math.log(o),f=.5*Math.exp(2*h/3),u=.5*Math.sqrt(h*f*(o-f)/o);a-o/2<0&&(u*=-1),b(r,t,Math.max(n,Math.floor(t-a*f/o+u)),Math.min(e,Math.floor(t+(o-a)*f/o+u)));}var i=r[t],l=n,g=e;for(d(r,n,t),r[e]>i&&d(r,n,e);l<g;){for(d(r,l,g),l++,g--;r[l]<i;)l++;for(;r[g]>i;)g--;}r[n]===i?d(r,n,g):d(r,++g,e),g<=t&&(n=g+1),t<=g&&(e=g-1);}}function d(r,t,n){var e=r[t];r[t]=r[n],r[n]=e;}function I(r,t){var n=r.slice();if(Array.isArray(t)){!function(r,t){for(var n=[0],e=0;e<t.length;e++)n.push(N(r.length,t[e]));n.push(r.length-1),n.sort(C);var o=[0,n.length-1];for(;o.length;){var a=Math.ceil(o.pop()),h=Math.floor(o.pop());if(!(a-h<=1)){var f=Math.floor((h+a)/2);P(r,n[f],Math.floor(n[h]),Math.ceil(n[a])),o.push(h,f,f,a);}}}(n,t);for(var e=[],o=0;o<t.length;o++)e[o]=y(n,t[o]);return e}return P(n,N(n.length,t),0,n.length-1),y(n,t)}function P(r,t,n,e){t%1==0?b(r,t,n,e):(b(r,t=Math.floor(t),n,e),b(r,t+1,t+1,e));}function C(r,t){return r-t}function N(r,t){var n=r*t;return 1===t?r-1:0===t?0:n%1!=0?Math.ceil(n)-1:r%2==0?n-.5:n}var _r=Math.sqrt(2*Math.PI);function Ar(r){for(var t=r,n=r,e=1;e<15;e++)t+=n*=r*r/(2*e+1);return Math.round(1e4*(.5+t/_r*Math.exp(-r*r/2)))/1e4}for(var zr=[],Ur=0;Ur<=3.09;Ur+=.01)zr.push(Ar(Ur));

    /**
     * options may contain upperBound, outlyingCoefficient (1.5 or 3.0), and weights (different variables may have different weights)
     */
    class Outlying {
        constructor(tree, options = {}) {
            let upperBound = options.upperBound;
            let outlyingCoefficient = options.outlyingCoefficient;
            let weights = options.weights;
            //Clone the tree to avoid modifying it
            this.tree = JSON.parse(JSON.stringify(tree));
            this.upperBound = upperBound;
            this.outlyingCoefficient = outlyingCoefficient ? outlyingCoefficient : 1.5;
            //Calculate the upper bound if it is not provided.
            if (!upperBound) {
                upperBound = findUpperBound(this.tree, outlyingCoefficient);
                //Save it for displaying purpose.
                this.upperBound = upperBound;
            }
            //Mark the long links
            markLongLinks(this.tree, upperBound);
            //Finding normal nodes
            let normalNodes = findNormalNodes(this.tree);
            //Finding outlying points
            this.outlyingPoints = findOutlyingPoints(this.tree, normalNodes);

            function findOutlyingPoints(tree, normalNodes) {
                let newNodes = normalNodes;
                let oldNodes = tree.nodes;
                //Get the outlying points
                let ops = [];
                oldNodes.forEach(on => {
                    //.id since we are accessing to points and the node is in form of {id: thePoint}
                    if (!pointExists(newNodes.map(nn => nn.id), on.id)) {
                        ops.push(on.id);
                    }
                });
                return ops;
            }

            //Now mark the outlying links
            markOutlyingLinks(this.tree, this.outlyingPoints);

            //Create none outlying tree
            this.noOutlyingTree = buildNoOutlyingTree(this.tree, this.outlyingPoints);

            function buildNoOutlyingTree(tree, outlyingPoints) {
                let noOutlyingTree = {};
                noOutlyingTree.nodes = normalNodes;
                noOutlyingTree.links = tree.links.filter(l => l.isOutlying !== true);
                //If the outlying nodes has the degree of 2 or greater => it will break the tree into subtrees => so we need to rebuild the tree.
                //Take the outlying points
                let outlyingPointsStr = outlyingPoints.map(p => p.join(','));
                let v2OrGreaterStr = getAllV2OrGreaterFromTree(tree).map(p => p.join(','));

                let diff = underscore.difference(outlyingPointsStr, v2OrGreaterStr);
                if (diff.length < outlyingPointsStr.length) {
                    //Means there is outlying node(s) with degree 2 or higher (so we should rebuild the tree)
                    let graph = createGraph(noOutlyingTree.nodes.map(n => n.id), weights);
                    noOutlyingTree = mst(graph);
                }
                return noOutlyingTree;
            }

            function findNormalNodes(tree) {
                //Remove long links
                let normalLinks = tree.links.filter(l => !l.isLong);
                //Remove outlying nodes (nodes are not in any none-long links)
                let allNodesWithLinks = [];
                normalLinks.forEach(l => {
                    allNodesWithLinks.push(l.source);
                    allNodesWithLinks.push(l.target);
                });
                allNodesWithLinks = underscore.uniq(allNodesWithLinks, false, d => d.join(','));
                let normalNodes = allNodesWithLinks.map(n => {
                    return {id: n};
                });
                return normalNodes;
            }

            function markLongLinks(tree, upperBound) {
                tree.links.forEach(l => {
                    if (l.weight > upperBound) {
                        l.isLong = true;
                    }
                });
            }

            function findUpperBound(tree, coefficient) {
                let allLengths = tree.links.map(l => l.weight),
                    q1 = I(allLengths, 0.25),
                    q3 = I(allLengths, 0.75),
                    iqr = q3 - q1,
                    upperBound = q3 + coefficient * iqr;
                return upperBound;
            }

            function markOutlyingLinks(tree, outlyingPoints) {
                if (outlyingPoints.length > 0) {
                    //Check the long links only
                    tree.links.filter(l => l.isLong).forEach(l => {
                        //Also check if the link contains outlying points.
                        if (pointExists(outlyingPoints, l.source) || pointExists(outlyingPoints, l.target)) {
                            l.isOutlying = true;
                        }
                    });
                }
            }
        }

        /**
         * Returns outlying score
         * @returns {number}
         */
        score() {
            let totalLengths = 0;
            let totalOutlyingLengths = 0;
            this.tree.links.forEach(l => {
                totalLengths += l.weight;
                //If there are outlying points first.
                if (l.isOutlying) {
                    totalOutlyingLengths += l.weight;
                }
            });
            return totalOutlyingLengths / totalLengths;
        }

        /**
         * Returns outlying links
         */
        links() {
            if (!this.outlyingLinks) {
                this.outlyingLinks = this.tree.links.filter(l => l.isOutlying);
            }
            return this.outlyingLinks;
        }

        /**
         * Remove outlying links and nodes and return a new tree without outlying points/edges
         */
        removeOutlying() {
            return this.noOutlyingTree;
        }

        /**
         * Returns the outlying points (in form of points, not node object).
         * @returns {Array}
         */
        points() {
            return this.outlyingPoints;
        }
    }

    var commonjsGlobal$1 = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    (function (window) {
        /**
         * initialize a outliagnosticsnd object
         * @param inputPoints   {*[][]} set of points from the scatter plot
         * @returns {*[][]}
         */
        window.outliagnosticsnd = function (inputPoints, options = {}) {
            let result = {};
            let dims = inputPoints[0].length;
            //Clone it to avoid modifying it.
            let points = inputPoints.map(e => e.slice());
            //Add one step to pass the data over if there is.
            for (let i = 0; i < points.length; i++) {
                points[i].data = inputPoints[i].data;
            }
            let normalizedPoints = points;

            if (options.isNormalized === undefined) {
                let normalizer = new Normalizer(points);
                normalizedPoints = normalizer.normalizedPoints;
                outputValue("normalizedPoints", normalizedPoints);
                outputValue("normalizer", normalizer);
            }

            let binType = options.binType;
            /******This section isouasdtly about the outlying score and outlying score results******/
            let outlyingUpperBound = options.outlyingUpperBound;
            let outlyingCoefficient = options.outlyingCoefficient;

            /******This section is about finding number of bins and binners******/
            let sites = null;
            let bins = null;
            let binner = null;
            let binSize = null;
            let binRadius = 0;
            let startBinGridSize = options.startBinGridSize;

            if (options.isBinned === undefined) {//Only do the binning if needed.
                let incrementA = options.incrementA ? options.incrementA : 2;
                let incrementB = options.incrementB ? options.incrementB : 0;
                let decrementA = options.decrementA ? options.decrementA : 1 / 2;
                let decrementB = options.decrementB ? options.decrementB : 0;

                if (startBinGridSize === undefined) {
                    startBinGridSize = 20;
                }
                bins = [];
                //Default number of bins
                let minNumOfBins = 30;
                let maxNumOfBins = 200;
                let minBins = options.minBins;
                let maxBins = options.maxBins;
                if (minBins) {
                    minNumOfBins = minBins;
                }
                if (maxBins) {
                    maxNumOfBins = maxBins;
                }

                do {
                    //Start with binSize x binSize x binSize... bins, and then increase it as binSize = binSize * incrementA + incrementB or binSize = binSize * decrementA + decrementB.
                    if (binSize === null) {
                        binSize = startBinGridSize;
                    } else if (bins.length > maxNumOfBins) {
                        binSize = binSize * decrementA + decrementB;
                    } else if (bins.length < minNumOfBins) {
                        binSize = binSize * incrementA + incrementB;
                    }
                    if (binType === "hexagon") ; else if (!binType || binType === "leader") {
                        // This section uses leader binner
                        binRadius = Math.sqrt(dims * Math.pow(1 / (binSize * 2), 2));
                        binner = new LeaderBinner(normalizedPoints, binRadius);
                        bins = binner.leaders;
                    }
                } while (bins.length > maxNumOfBins || bins.length < minNumOfBins);
                // }
                sites = bins.map(d => d.site); //=>sites are the set of centers of all bins
                /******This section is about the binning and binning results******/
                outputValue("binner", binner);
                outputValue("bins", bins);
                outputValue("binSize", binSize);
                outputValue("binRadius", binRadius);
            } else {
                sites = normalizedPoints;
            }

            outputValue("binnedSites", sites);

            /******This section is about the spanning tree and spanning tree results******/
                //Spanning tree calculation
            let tetrahedraCoordinates = [sites];
            let weights = options.distanceWeights;
            let graph = createGraph(tetrahedraCoordinates, weights);
            let mstree = mst(graph);
            //Assigning the output values
            // outputValue("graph", graph);
            // outputValue("mst", mstree);

            /******This section is about the outlying score and outlying score results******/
                //TODO: Need to check if outlying links are really connected to outlying points
            let outlying = new Outlying(mstree, {
                    outlyingUpperBound: outlyingUpperBound,
                    outlyingCoefficient: outlyingCoefficient
                });
            let outlyingScore = outlying.score();
            outlyingUpperBound = outlying.upperBound;
            //Add outlying points from the bin to it.
            outputValue("outlyingScore", outlyingScore);
            outputValue("outlyingUpperBound", outlyingUpperBound);

            return result;

            function outputValue(name, value) {
                result[name] = value;
            }
        };

    })(commonjsGlobal$1);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0bGlhZ25vc3RpY3NuZC5taW4uanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL25vcm1hbGl6ZXIuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL2xlYWRlckJpbm5lci5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMva3J1c2thbC1tc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5tanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL291dGx5aW5nLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvb3V0bGlhZ25vc3RpY3NuZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjkuMVxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxOCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBgZ2xvYmFsYFxuICAvLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4gIC8vIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHxcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fFxuICAgICAgICAgICAgdGhpcyB8fFxuICAgICAgICAgICAge307XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgU3ltYm9sUHJvdG8gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5wcm90b3R5cGUgOiBudWxsO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXIgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgbmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlaXIgb2xkIG1vZHVsZSBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgLy8gKGBub2RlVHlwZWAgaXMgY2hlY2tlZCB0byBlbnN1cmUgdGhhdCBgbW9kdWxlYFxuICAvLyBhbmQgYGV4cG9ydHNgIGFyZSBub3QgSFRNTCBlbGVtZW50cy4pXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiAhZXhwb3J0cy5ub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOS4xJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgLy8gVGhlIDItYXJndW1lbnQgY2FzZSBpcyBvbWl0dGVkIGJlY2F1c2Ugd2XigJlyZSBub3QgdXNpbmcgaXQuXG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgYnVpbHRpbkl0ZXJhdGVlO1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGVhY2hcbiAgLy8gZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlciBgaWRlbnRpdHlgLFxuICAvLyBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKF8uaXRlcmF0ZWUgIT09IGJ1aWx0aW5JdGVyYXRlZSkgcmV0dXJuIF8uaXRlcmF0ZWUodmFsdWUsIGNvbnRleHQpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkgJiYgIV8uaXNBcnJheSh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcblxuICAvLyBFeHRlcm5hbCB3cmFwcGVyIGZvciBvdXIgY2FsbGJhY2sgZ2VuZXJhdG9yLiBVc2VycyBtYXkgY3VzdG9taXplXG4gIC8vIGBfLml0ZXJhdGVlYCBpZiB0aGV5IHdhbnQgYWRkaXRpb25hbCBwcmVkaWNhdGUvaXRlcmF0ZWUgc2hvcnRoYW5kIHN0eWxlcy5cbiAgLy8gVGhpcyBhYnN0cmFjdGlvbiBoaWRlcyB0aGUgaW50ZXJuYWwtb25seSBhcmdDb3VudCBhcmd1bWVudC5cbiAgXy5pdGVyYXRlZSA9IGJ1aWx0aW5JdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gU29tZSBmdW5jdGlvbnMgdGFrZSBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIG9yIGEgZmV3IGV4cGVjdGVkXG4gIC8vIGFyZ3VtZW50cyBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIHZhbHVlcyB0byBvcGVyYXRlXG4gIC8vIG9uLiBUaGlzIGhlbHBlciBhY2N1bXVsYXRlcyBhbGwgcmVtYWluaW5nIGFyZ3VtZW50cyBwYXN0IHRoZSBmdW5jdGlvbuKAmXNcbiAgLy8gYXJndW1lbnQgbGVuZ3RoIChvciBhbiBleHBsaWNpdCBgc3RhcnRJbmRleGApLCBpbnRvIGFuIGFycmF5IHRoYXQgYmVjb21lc1xuICAvLyB0aGUgbGFzdCBhcmd1bWVudC4gU2ltaWxhciB0byBFUzbigJlzIFwicmVzdCBwYXJhbWV0ZXJcIi5cbiAgdmFyIHJlc3RBcmd1bWVudHMgPSBmdW5jdGlvbihmdW5jLCBzdGFydEluZGV4KSB7XG4gICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPT0gbnVsbCA/IGZ1bmMubGVuZ3RoIC0gMSA6ICtzdGFydEluZGV4O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChhcmd1bWVudHMubGVuZ3RoIC0gc3RhcnRJbmRleCwgMCksXG4gICAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3RbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4ICsgc3RhcnRJbmRleF07XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCByZXN0KTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCByZXN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkoc3RhcnRJbmRleCArIDEpO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgc3RhcnRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICBhcmdzW3N0YXJ0SW5kZXhdID0gcmVzdDtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHNoYWxsb3dQcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhcyA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcGF0aCk7XG4gIH1cblxuICB2YXIgZGVlcEdldCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggPyBvYmogOiB2b2lkIDA7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3QuXG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIHZhciBjcmVhdGVSZWR1Y2UgPSBmdW5jdGlvbihkaXIpIHtcbiAgICAvLyBXcmFwIGNvZGUgdGhhdCByZWFzc2lnbnMgYXJndW1lbnQgdmFyaWFibGVzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gdGhhblxuICAgIC8vIHRoZSBvbmUgdGhhdCBhY2Nlc3NlcyBgYXJndW1lbnRzLmxlbmd0aGAgdG8gYXZvaWQgYSBwZXJmIGhpdC4gKCMxOTkxKVxuICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgaW5pdGlhbCkge1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMztcbiAgICAgIHJldHVybiByZWR1Y2VyKG9iaiwgb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCksIG1lbW8sIGluaXRpYWwpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXlGaW5kZXIgPSBpc0FycmF5TGlrZShvYmopID8gXy5maW5kSW5kZXggOiBfLmZpbmRLZXk7XG4gICAgdmFyIGtleSA9IGtleUZpbmRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIHBhdGgsIGFyZ3MpIHtcbiAgICB2YXIgY29udGV4dFBhdGgsIGZ1bmM7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihwYXRoKSkge1xuICAgICAgZnVuYyA9IHBhdGg7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICBwYXRoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kID0gZnVuYztcbiAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIGlmIChjb250ZXh0UGF0aCAmJiBjb250ZXh0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gZGVlcEdldChjb250ZXh0LCBjb250ZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgbWV0aG9kID0gY29udGV4dFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QgPT0gbnVsbCA/IG1ldGhvZCA6IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodiwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbi5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uc2FtcGxlKG9iaiwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHZhciBzYW1wbGUgPSBpc0FycmF5TGlrZShvYmopID8gXy5jbG9uZShvYmopIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKHNhbXBsZSk7XG4gICAgbiA9IE1hdGgubWF4KE1hdGgubWluKG4sIGxlbmd0aCksIDApO1xuICAgIHZhciBsYXN0ID0gbGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbjsgaW5kZXgrKykge1xuICAgICAgdmFyIHJhbmQgPSBfLnJhbmRvbShpbmRleCwgbGFzdCk7XG4gICAgICB2YXIgdGVtcCA9IHNhbXBsZVtpbmRleF07XG4gICAgICBzYW1wbGVbaW5kZXhdID0gc2FtcGxlW3JhbmRdO1xuICAgICAgc2FtcGxlW3JhbmRdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsZS5zbGljZSgwLCBuKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCsrLFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGtleSwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yLCBwYXJ0aXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpdGlvbiA/IFtbXSwgW11dIDoge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIHZhciByZVN0clN5bWJvbCA9IC9bXlxcdWQ4MDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkZmZmXS9nO1xuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoXy5pc1N0cmluZyhvYmopKSB7XG4gICAgICAvLyBLZWVwIHN1cnJvZ2F0ZSBwYWlyIGNoYXJhY3RlcnMgdG9nZXRoZXJcbiAgICAgIHJldHVybiBvYmoubWF0Y2gocmVTdHJTeW1ib2wpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBwYXNzKSB7XG4gICAgcmVzdWx0W3Bhc3MgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCA/IHZvaWQgMCA6IFtdO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgQm9vbGVhbik7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCkge1xuICAgIG91dHB1dCA9IG91dHB1dCB8fCBbXTtcbiAgICB2YXIgaWR4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vIEZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0LlxuICAgICAgICBpZiAoc2hhbGxvdykge1xuICAgICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCk7XG4gICAgICAgICAgaWR4ID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgb3RoZXJBcnJheXMpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBvdGhlckFycmF5cyk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gVGhlIGZhc3RlciBhbGdvcml0aG0gd2lsbCBub3Qgd29yayB3aXRoIGFuIGl0ZXJhdGVlIGlmIHRoZSBpdGVyYXRlZVxuICAvLyBpcyBub3QgYSBvbmUtdG8tb25lIGZ1bmN0aW9uLCBzbyBwcm92aWRpbmcgYW4gaXRlcmF0ZWUgd2lsbCBkaXNhYmxlXG4gIC8vIHRoZSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkICYmICFpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFycmF5cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCByZXN0KSB7XG4gICAgcmVzdCA9IGZsYXR0ZW4ocmVzdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlcy5cbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IHJlc3RBcmd1bWVudHMoXy51bnppcCk7XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBQYXNzaW5nIGJ5IHBhaXJzIGlzIHRoZSByZXZlcnNlIG9mIF8ucGFpcnMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlciA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3QuXG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVJbmRleEZpbmRlciA9IGZ1bmN0aW9uKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKCFzdGVwKSB7XG4gICAgICBzdGVwID0gc3RvcCA8IHN0YXJ0ID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gQ2h1bmsgYSBzaW5nbGUgYXJyYXkgaW50byBtdWx0aXBsZSBhcnJheXMsIGVhY2ggY29udGFpbmluZyBgY291bnRgIG9yIGZld2VyXG4gIC8vIGl0ZW1zLlxuICBfLmNodW5rID0gZnVuY3Rpb24oYXJyYXksIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5jYWxsKGFycmF5LCBpLCBpICs9IGNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBib3VuZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oY2FsbEFyZ3MpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciBieSBkZWZhdWx0LCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlXG4gIC8vIHByZS1maWxsZWQuIFNldCBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCBmb3IgYSBjdXN0b20gcGxhY2Vob2xkZXIgYXJndW1lbnQuXG4gIF8ucGFydGlhbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgYm91bmRBcmdzKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gXy5wYXJ0aWFsLnBsYWNlaG9sZGVyO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gcGxhY2Vob2xkZXIgPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICBfLnBhcnRpYWwucGxhY2Vob2xkZXIgPSBfO1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4IDwgMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9KTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdGhyb3R0bGVkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgdGltZW91dCA9IGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRocm90dGxlZDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoYXJncykgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlYm91bmNlZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJncykge1xuICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgdmFyIGNhbGxOb3cgPSAhdGltZW91dDtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdykgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBfLmRlbGF5KGxhdGVyLCB3YWl0LCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVib3VuY2VkO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgXy5yZXN0QXJndW1lbnRzID0gcmVzdEFyZ3VtZW50cztcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIHZhciBjb2xsZWN0Tm9uRW51bVByb3BzID0gZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSBfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYC5cbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChoYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3QuXG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0LlxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgLy8gVGhlIG9wcG9zaXRlIG9mIF8ub2JqZWN0LlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYC5cbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGRlZmF1bHRzKSBvYmogPSBPYmplY3Qob2JqKTtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghZGVmYXVsdHMgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3QuXG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEludGVybmFsIHBpY2sgaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBgb2JqYCBoYXMga2V5IGBrZXlgLlxuICB2YXIga2V5SW5PYmogPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaXRlcmF0ZWUgPSBrZXlzWzBdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBrZXlzWzFdKTtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBrZXlJbk9iajtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIGl0ZXJhdGVlID0ga2V5c1swXSwgY29udGV4dDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBjb250ZXh0ID0ga2V5c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IF8ubWFwKGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH0pO1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSwgZGVlcEVxO1xuICBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjtcbiAgICAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjayk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgZGVlcEVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3ltYm9sXSc6XG4gICAgICAgIHJldHVybiBTeW1ib2xQcm90by52YWx1ZU9mLmNhbGwoYSkgPT09IFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChiKTtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKGhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLCBpc01hcCwgaXNXZWFrTWFwLCBpc1NldCwgaXNXZWFrU2V0LlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvcicsICdTeW1ib2wnLCAnTWFwJywgJ1dlYWtNYXAnLCAnU2V0JywgJ1dlYWtTZXQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgU2FmYXJpIDggKCMxOTI5KSwgYW5kIFBoYW50b21KUyAoIzIyMzYpLlxuICB2YXIgbm9kZWxpc3QgPSByb290LmRvY3VtZW50ICYmIHJvb3QuZG9jdW1lbnQuY2hpbGROb2RlcztcbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnICYmIHR5cGVvZiBub2RlbGlzdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gIV8uaXNTeW1ib2wob2JqKSAmJiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgaXNOYU4ob2JqKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwgcGF0aCkge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgICByZXR1cm4gaGFzKG9iaiwgcGF0aCk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXTtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiAhIWxlbmd0aDtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIHBhc3NlZCBhbiBvYmplY3QsIHdpbGwgdHJhdmVyc2UgdGhhdCBvYmplY3TigJlzXG4gIC8vIHByb3BlcnRpZXMgZG93biB0aGUgZ2l2ZW4gYHBhdGhgLCBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2Yga2V5cyBvciBpbmRleGVzLlxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgICByZXR1cm4gc2hhbGxvd1Byb3BlcnR5KHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gZGVlcEdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpe307XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gIV8uaXNBcnJheShwYXRoKSA/IG9ialtwYXRoXSA6IGRlZXBHZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBUcmF2ZXJzZXMgdGhlIGNoaWxkcmVuIG9mIGBvYmpgIGFsb25nIGBwYXRoYC4gSWYgYSBjaGlsZCBpcyBhIGZ1bmN0aW9uLCBpdFxuICAvLyBpcyBpbnZva2VkIHdpdGggaXRzIHBhcmVudCBhcyBjb250ZXh0LiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmluYWxcbiAgLy8gY2hpbGQsIG9yIGBmYWxsYmFja2AgaWYgYW55IGNoaWxkIGlzIHVuZGVmaW5lZC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmosIHBhdGgsIGZhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHBhdGggPSBbcGF0aF07XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrLmNhbGwob2JqKSA6IGZhbGxiYWNrO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW3BhdGhbaV1dO1xuICAgICAgaWYgKHByb3AgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9wID0gZmFsbGJhY2s7XG4gICAgICAgIGkgPSBsZW5ndGg7IC8vIEVuc3VyZSB3ZSBkb24ndCBjb250aW51ZSBpdGVyYXRpbmcuXG4gICAgICB9XG4gICAgICBvYmogPSBfLmlzRnVuY3Rpb24ocHJvcCkgPyBwcm9wLmNhbGwob2JqKSA6IHByb3A7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVSZWdFeHAgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVSZWdFeHAsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZnNldC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB2YXIgcmVuZGVyO1xuICAgIHRyeSB7XG4gICAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIGNoYWluUmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gXztcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5fd3JhcHBlZCk7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0oKSk7XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxuZXhwb3J0IGNsYXNzIE5vcm1hbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cykge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cy5tYXAoZT0+ZS5zbGljZSgpKTtcbiAgICAgICAgLy9wYXNzIHRoZSBkYXRhIG92ZXJcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaCgocCwgaSk9PntcbiAgICAgICAgICAgIHAuZGF0YSA9IHBvaW50c1tpXS5kYXRhO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG5kcyA9IHRoaXMubmRzID0gXy51bnppcCh0aGlzLnBvaW50cyk7XG4gICAgICAgIGxldCBtYXhEID0gdGhpcy5tYXhEID0gW107XG4gICAgICAgIGxldCBtaW5EID0gdGhpcy5taW5EID0gW107XG4gICAgICAgIGxldCByYW5nZUQgPSB0aGlzLnJhbmdlRCA9IFtdO1xuICAgICAgICBsZXQgbm9ybWFsaXplZEQgPSB0aGlzLm5vcm1hbGl6ZWREID0gW107XG4gICAgICAgIG5kcy5mb3JFYWNoKChkLCBpKT0+e1xuICAgICAgICAgICAgbWF4RFtpXSA9IF8ubWF4KGQpO1xuICAgICAgICAgICAgbWluRFtpXSA9IF8ubWluKGQpO1xuICAgICAgICAgICAgcmFuZ2VEW2ldID0gKG1heERbaV0gIT0gbWluRFtpXSkgPyBtYXhEW2ldIC0gbWluRFtpXSA6IDE7XG4gICAgICAgICAgICBub3JtYWxpemVkRFtpXSA9IGQubWFwKGU9PihlLW1pbkRbaV0pL3JhbmdlRFtpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWRQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkUG9pbnRzW2ldID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkUG9pbnRzW2ldW2pdID0gbm9ybWFsaXplZERbal1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9BZGQgb25lIHN0ZXAgdG8gcGFzcyB0aGUgZGF0YSBvdmVyIGlmIHRoZXJlIGlzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRQb2ludHNbaV0uZGF0YSA9IHRoaXMucG9pbnRzW2ldLmRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBhIHNldCBvZiBwb2ludHMgaW4gdGhpcyBzY2FsZSByYW5nZSBbMCwgMV0gYW5kIHdpbGwgYmUgc2NhbGVkIGJhY2sgdG9cbiAgICAgKiAtIE9yaWdpbmFsIHNjYWxlIChbbWluWCwgbWF4WF0sIFttaW5ZLCBtYXhZXSwgW21pblosIG1heFpdKVxuICAgICAqIEBwYXJhbSBwb2ludHNcbiAgICAgKi9cbiAgICBzY2FsZUJhY2tQb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKHBvaW50ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlQmFja1BvaW50KHBvaW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgYSBzaW5nbGUgcG9pbnQgaW4gdGhpcyBzY2FsZSByYW5nZSBbMCwgMV0gYW5kIHdpbGwgYmUgc2NhbGVkIGJhY2sgdG9cbiAgICAgKiAtIE9yaWdpbmFsIHNjYWxlIChbbWluWCwgbWF4WF0sIFttaW5ZLCBtYXhZXSwgW21pblosIG1heFpdKVxuICAgICAqIEBwYXJhbSBwb2ludHNcbiAgICAgKi9cbiAgICBzY2FsZUJhY2tQb2ludChwb2ludCkge1xuICAgICAgICBsZXQgbmV3UG9pbnQgPSBwb2ludC5tYXAoKHZzLCBpKT0+e1xuICAgICAgICAgICAgbGV0IHYgPSB0aGlzLnJhbmdlRFtpXSp2cyArIHRoaXMubWluRFtpXTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xuICAgIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBMZWFkZXJCaW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cywgcmFkaXVzKSB7XG4gICAgICAgIC8vVE9ETzogU2hvdWxkIGNoZWNrIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gMyB1bmlxdWUgdmFsdWVzIGhlcmUgb3IgZXZlbiBhZnRlciB0aGUgYmlubmluZy5cbiAgICAgICAgLy9UT0RPOiBNYXkgbmVlZCB0byBjbG9uZSB0aGUgcG9pbnRzIHRvIGF2b2lkIG1vZGlmeWluZyBpdCwgYnV0IHdlIGRvbid0IGRvIHRvIHJlc2VydmUgb3RoZXIgZGF0YSBvciB0byBtYWtlIHRoZSBwcm9jZXNzIGZhc3RlclxuICAgICAgICAvLyAvL0Nsb25lIHRoZXNlIHRvIGF2b2lkIG1vZGlmeWluZyB0aGVtXG4gICAgICAgIC8vIHRoaXMucG9pbnRzID0gcG9pbnRzLm1hcChwPT5wLnNsaWNlKDApKTtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIH1cblxuICAgIGdldCBsZWFkZXJzKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCB0aGVMZWFkZXJzID0gW107XG4gICAgICAgIC8vZmluZCBhbGwgdGhlIGxlYWRlcnNcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICBsZXQgbGVhZGVyID0gY2xvc2VzdExlYWRlcih0aGVMZWFkZXJzLCBwb2ludCk7XG4gICAgICAgICAgICBpZiAoIWxlYWRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXdMZWFkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBuZXdMZWFkZXIuc2l0ZSA9IHBvaW50LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdGhlTGVhZGVycy5wdXNoKG5ld0xlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvL25vdyBkbyB0aGlzIGFnYWluIHRvIHNldCB0aGUgY2xvc2VzdCBsZWFkZXIuXG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgICAgICAgbGV0IGxlYWRlciA9IGNsb3Nlc3RMZWFkZXIodGhlTGVhZGVycywgcG9pbnQpO1xuICAgICAgICAgICAgbGVhZGVyLnB1c2gocG9pbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoZUxlYWRlcnM7XG5cbiAgICAgICAgZnVuY3Rpb24gY2xvc2VzdExlYWRlcihsZWFkZXJzLCBwb2ludCkge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGxlYWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBsZXQgdGhlTGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgbCA9IGxlYWRlcnNbaV07XG4gICAgICAgICAgICAgICAgbGV0IGQgPSBkaXN0YW5jZShsLnNpdGUsIHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IHNlbGYucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUxlYWRlciA9IGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhlTGVhZGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIGxldCBzdW1zcXVhcmVkID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGQgPSBhW2ldIC0gYltpXTtcbiAgICAgICAgaWYoIU51bWJlci5pc05hTihkKSl7XG4gICAgICAgICAgICBzdW1zcXVhcmVkICs9IGQqZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL0ZvciBjb21wdXRlciBzdG9yYWdlIGlzc3VlLCBzb21lIGNvb3JkaW5hdGVzIG9mIHRoZSBzYW1lIGRpc3RhbmNlIG1heSByZXR1cm4gZGlmZmVyZW50IGRpc3RhbmNlcyBpZiB3ZSB1c2UgbG9uZyBmbG9hdGluZyBwb2ludFxuICAgIC8vU28gdGFrZSBvbmx5IDEwIGRpZ2l0cyBhZnRlciB0aGUgZmxvYXRpbmcgcG9pbnRzPT4gdGhpcyBpcyBwcmVjaXNlIGVub3VnaCBhbmQgc3RpbGwgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMgZm9yIHR3byBkaWZmZXJlbnQgbGluZXMgb2YgdGhlIHNhbWUgZGlzdGFuY2VcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoc3Vtc3F1YXJlZCkgKiBNYXRoLnBvdygxMCwgMTApKSAvIE1hdGgucG93KDEwLCAxMCk7XG59IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYm1lcnNob24vMjVhNzRmN2IxYzdjYmQwN2U3NDU2YWYxZDJjMDdkYTFcbi8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LcnVza2FsJTI3c19hbGdvcml0aG1cXFxuLy8gRGVwZW5kcyBvbiBEaXNqb2ludFNldC5cbmltcG9ydCBfIGZyb20gXCJ1bmRlcnNjb3JlXCI7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGUgdGhlIHBhaXJzIGJldHdlZW4gbm9kZSBhbmQgaXRzIGxpbmtzLlxuICpcbiAqIEBwYXJhbSBsaW5rc1xuICogQHJldHVybnMgW1tcIm5vZGVYLG5vZGVZXCI6IEFycmF5KG51bWJlck9mTGlua3NSZWxhdGVkVG9UaGVOb2RlcyldXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFpck5vZGVMaW5rcyhsaW5rcykge1xuICAgIGxldCBuZXN0ZWRCeU5vZGVzID0ge307XG4gICAgbGlua3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgaWYoIWwuc291cmNlLmpvaW4pe1xuICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGwpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cobGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzb3VyY2VLZXkgPSBsLnNvdXJjZS5qb2luKCcsJyk7XG4gICAgICAgIGlmICghbmVzdGVkQnlOb2Rlc1tzb3VyY2VLZXldKSB7XG4gICAgICAgICAgICBuZXN0ZWRCeU5vZGVzW3NvdXJjZUtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWRCeU5vZGVzW3NvdXJjZUtleV0ucHVzaChsKTtcbiAgICAgICAgbGV0IHRhcmdldEtleSA9IGwudGFyZ2V0LmpvaW4oJywnKTtcbiAgICAgICAgaWYgKCFuZXN0ZWRCeU5vZGVzW3RhcmdldEtleV0pIHtcbiAgICAgICAgICAgIG5lc3RlZEJ5Tm9kZXNbdGFyZ2V0S2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG5lc3RlZEJ5Tm9kZXNbdGFyZ2V0S2V5XS5wdXNoKGwpO1xuICAgIH0pO1xuICAgIC8vUGFpciB0aGUgcmVzdWx0c1xuICAgIGxldCBwYWlyZWRSZXN1bHRzID0gXy5wYWlycyhuZXN0ZWRCeU5vZGVzKTtcbiAgICByZXR1cm4gcGFpcmVkUmVzdWx0cztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgY29ybmVycyAodGhyZWUgdmVydGljZXMpIG9mIHZlcnRpY2VzIG9mIGRlZ3JlZSB0d28gaW4gdGhlIGZvciBtYXQgb2ZcbiAqIHBvaW50MSwgcG9pbnQyLCBwb2ludDMgPT4gcG9pbnQxIGlzIHRoZSB0aGUgdmVydGV4IHdpdGggZGVncmVlIHR3byAodHdvIGVkZ2VzIGNvbm5lY3RlZCB0byBpdCBhcmUgW3BvaW50MSwgcG9pbnQyXSBhbmQgW3BvaW50MSwgcG9pbnQzXSAob3JkZXIgb2YgdGhlIHBvaW50cyBpbiBlYWNoIGVkZ2UgaXMgbm90IGltcG9ydGFudCkpLlxuICogQHBhcmFtIHRyZWVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVjJDb3JuZXJzRnJvbVRyZWUodHJlZSkge1xuICAgIGxldCBwYWlyZWRSZXN1bHRzID0gcGFpck5vZGVMaW5rcyh0cmVlLmxpbmtzKTtcbiAgICAvL0dldCBhbGwgcGFpcnMgd2l0aCBsZW5ndGggPSAyIChWMilcbiAgICBsZXQgYWxsVjIgPSBwYWlyZWRSZXN1bHRzLmZpbHRlcihwID0+IHBbMV0ubGVuZ3RoID09IDIpO1xuXG4gICAgbGV0IGFsbENvcm5lcnMgPSBhbGxWMi5tYXAodjIgPT4ge1xuICAgICAgICBsZXQgY29ybmVyID0gW107XG4gICAgICAgIC8vRmlyc3QgcG9pbnQgaXMgdGhlIGNvbW1vbiB2ZXJ0aWNlXG4gICAgICAgIGNvcm5lci5wdXNoKHYyWzBdLnNwbGl0KCcsJykubWFwKGQgPT4gK2QpKTsvL21hcChkPT4rZCkgaXMgdG8gY29udmVydCB0aGUgc3RyaW5ncyBpbnRvIGRpZ2l0c1xuICAgICAgICAvL1B1c2ggdGhlIHNvdXJjZSBvciB0YXJnZXQgaWYgdGhleSBhcmUgbm90IHRoZSBjb21tb24gdmVydGljZXMgb2YgdGhlIHR3byBlZGdlc1xuICAgICAgICB2MlsxXS5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmsuc291cmNlLmpvaW4oJywnKSAhPSB2MlswXSkge1xuICAgICAgICAgICAgICAgIGNvcm5lci5wdXNoKGxpbmsuc291cmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29ybmVyLnB1c2gobGluay50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvcm5lcjtcbiAgICB9KTtcbiAgICByZXR1cm4gYWxsQ29ybmVycztcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB2ZXJ0aWNlcyB3aXRoIGRlZ3JlZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgMlxuICogQHBhcmFtIHRyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFYyT3JHcmVhdGVyRnJvbVRyZWUodHJlZSkge1xuICAgIGxldCBwYWlyZWRSZXN1bHRzID0gcGFpck5vZGVMaW5rcyh0cmVlLmxpbmtzKTtcbiAgICAvL0dldCBhbGwgcGFpcnMgd2l0aCBsZW5ndGggPj0gMiAoVjIpXG4gICAgbGV0IGFsbEdURVYyID0gcGFpcmVkUmVzdWx0cy5maWx0ZXIocCA9PiBwWzFdLmxlbmd0aCA+PSAyKTtcbiAgICByZXR1cm4gYWxsR1RFVjIubWFwKHYgPT4gdlswXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCBzaW5nbGUgZGVncmVlIHZlcnRpY2VzIGZyb20gYSB0cmVlXG4gKiBAcGFyYW0gdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVjFzRnJvbVRyZWUodHJlZSkge1xuICAgIGxldCBwYWlyZWRSZXN1bHRzID0gcGFpck5vZGVMaW5rcyh0cmVlLmxpbmtzKTtcbiAgICAvL0dldCBhbGwgcGFpcnMgd2l0aCBsZW5ndGggPSAxIChWMSlcbiAgICBsZXQgYWxsVjEgPSBwYWlyZWRSZXN1bHRzLmZpbHRlcihwID0+IHBbMV0ubGVuZ3RoID09IDEpO1xuICAgIHJldHVybiBhbGxWMS5tYXAodjEgPT4gdjFbMF0uc3BsaXQoJywnKS5tYXAoTnVtYmVyKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZ3JhcGggZnJvbSBtZXNoXG4gKiBAcGFyYW0gdHJpYW5nbGVzIGlzIGluZm9ybSBvZiBzZXQgb2YgdHJpYW5nbGVzIGFzIHRoZSByZXN1bHQgZnJvbSBkZWxhdW5heSB0cmlhbmd1bGF0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGgodGV0cmFoZWRyYSwgd2VpZ2h0cykge1xuXG4gICAgZnVuY3Rpb24gbWFrZUxpbmsoc291cmNlSWQsIHRhcmdldElkLCB3ZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcInNvdXJjZVwiOiBzb3VyY2VJZCwgXCJ0YXJnZXRcIjogdGFyZ2V0SWQsIFwid2VpZ2h0XCI6IHdlaWdodH07XG4gICAgfVxuXG4gICAgbGV0IGdyYXBoID0ge307XG4gICAgZ3JhcGgubm9kZXMgPSBbXTtcbiAgICBncmFwaC5saW5rcyA9IFtdO1xuICAgIC8vQ3JlYXRpbmcgbm9kZXNcbiAgICB0ZXRyYWhlZHJhLmZvckVhY2godCA9PiB7XG4gICAgICAgIHQuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDaGVjayB0aGlzIGJlY2F1c2UgdGhpcyBtYXkgbm90IGJlIG5lZWRlZCBzaW5jZSB0aGUgdGV0cmFoZWRyYSBoZXJlIGFyZSBqdXN0IHNpbWx5IHBvaW50cyAobm90IHRoZSB0cmlhbmdsZXMgbGlrZSBpbiB0aGUgMkQsIDNEIGNhc2UpXG4gICAgICAgICAgICAvLyBpZiAoIWlkRXhpc3RzKGdyYXBoLm5vZGVzLCBpZCkpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBncmFwaC5ub2Rlcy5wdXNoKG1ha2VOb2RlKGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy9DcmVhdGluZyBsaW5rc1xuICAgIHRldHJhaGVkcmEuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IHAxID0gdFtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcDIgPSB0W2pdO1xuICAgICAgICAgICAgICAgIGxldCBpZDEgPSBwMTtcbiAgICAgICAgICAgICAgICBsZXQgaWQyID0gcDI7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBkaXN0YW5jZShwMSwgcDIsIHdlaWdodHMpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gbWFrZUxpbmsoaWQxLCBpZDIsIGRpc3QpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIHRoaXMgYmVjYXVzZSB0aGlzIG1heSBub3QgYmUgbmVlZGVkIHNpbmNlIHRoZSB0ZXRyYWhlZHJhIGhlcmUgYXJlIGp1c3Qgc2ltbHkgcG9pbnRzIChub3QgdGhlIHRyaWFuZ2xlcyBsaWtlIGluIHRoZSAyRCwgM0QgY2FzZSlcbiAgICAgICAgICAgICAgICAvLyBpZiAoIWxpbmtFeGlzdHMoZ3JhcGgubGlua3MsIGxpbmspKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGdyYXBoLmxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGdyYXBoLmxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vVE9ETzogbWF5IHNvcnQgdGhlIGlkIGFscGhhYmV0aWNhbGx5ID0+IHdoZW4gY3JlYXRpbmcgPT4gc28gd2UgY2FuIGp1c3QgY2hlY2sgMSBjb25kaXRpb24gb25seS5cbiAgICBmdW5jdGlvbiBsaW5rRXhpc3RzKGxpbmtzLCBsaW5rKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBsaW5rcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKGVxdWFsTGlua3MobGluaywgbGlua3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiLCB3ZWlnaHRzKSB7XG4gICAgbGV0IHRvdGFsU3VtU3F1YXJlZCA9IDA7XG4gICAgaWYgKCF3ZWlnaHRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSAoYVtpXSAtIGJbaV0pICogKGFbaV0gLSBiW2ldKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGRpZmYpKSB7XG4gICAgICAgICAgICAgICAgdG90YWxTdW1TcXVhcmVkICs9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkaWZmID0gKGFbaV0gLSBiW2ldKSAqIChhW2ldIC0gYltpXSk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihkaWZmKSkge1xuICAgICAgICAgICAgICAgIHRvdGFsU3VtU3F1YXJlZCArPSBkaWZmICogd2VpZ2h0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbi8vRm9yIGNvbXB1dGVyIHN0b3JhZ2UgaXNzdWUsIHNvbWUgY29vcmRpbmF0ZXMgb2YgdGhlIHNhbWUgZGlzdGFuY2UgbWF5IHJldHVybiBkaWZmZXJlbnQgZGlzdGFuY2VzIGlmIHdlIHVzZSBsb25nIGZsb2F0aW5nIHBvaW50XG4vL1NvIHRha2Ugb25seSAxMCBkaWdpdHMgYWZ0ZXIgdGhlIGZsb2F0aW5nIHBvaW50cz0+IHRoaXMgaXMgcHJlY2lzZSBlbm91Z2ggYW5kIHN0aWxsIGhhdmUgdGhlIHNhbWUgdmFsdWVzIGZvciB0d28gZGlmZmVyZW50IGxpbmVzIG9mIHRoZSBzYW1lIGRpc3RhbmNlXG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KHRvdGFsU3VtU3F1YXJlZCkgKiBNYXRoLnBvdygxMCwgMTApKSAvIE1hdGgucG93KDEwLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbFBvaW50cyhpZDEsIGlkMikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpZDFbaV0gIT09IGlkMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRFeGlzdHMocG9pbnRzLCBwb2ludCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwb2ludDEgPSBwb2ludHNbaV07XG4gICAgICAgIGlmIChlcXVhbFBvaW50cyhwb2ludDEsIHBvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxMaW5rcyhsMSwgbDIpIHtcbiAgICByZXR1cm4gKGVxdWFsUG9pbnRzKGwxLnNvdXJjZSwgbDIuc291cmNlKSAmJiBlcXVhbFBvaW50cyhsMS50YXJnZXQsIGwyLnRhcmdldCkpIHx8XG4gICAgICAgIChlcXVhbFBvaW50cyhsMS5zb3VyY2UsIGwyLnRhcmdldCkgJiYgZXF1YWxQb2ludHMobDEudGFyZ2V0LCBsMi5zb3VyY2UpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlkRXhpc3RzKG5vZGVzLCBpZCkge1xuICAgIGxldCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChlcXVhbFBvaW50cyhub2RlLmlkLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VOb2RlKGlkKSB7XG4gICAgcmV0dXJuIHtcImlkXCI6IGlkfTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgdGhlIG1zdFxuICogQHBhcmFtIGdyYXBoOiBpbiBmb3JtIG9mIG5vZGVzIGFuZCBsaW5rc1xuICogQHJldHVybnMge3tub2RlczogKHNlbGVjdGlvbl9ub2Rlc3xub2RlcyksIGxpbmtzOiBBcnJheX19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtc3QoZ3JhcGgpIHtcbiAgICBsZXQgdmVydGljZXMgPSBncmFwaC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBncmFwaC5saW5rcy5zbGljZSgwKSxcbiAgICAgICAgc2VsZWN0ZWRFZGdlcyA9IFtdLFxuICAgICAgICBmb3Jlc3QgPSBuZXcgRGlzam9pbnRTZXQoKTtcblxuICAgIC8vIEVhY2ggdmVydGV4IGJlZ2lucyBcImRpc2Nvbm5lY3RlZFwiIGFuZCBpc29sYXRlZCBmcm9tIGFsbCB0aGUgb3RoZXJzLlxuICAgIHZlcnRpY2VzLmZvckVhY2goKHZlcnRleCkgPT4ge1xuICAgICAgICBmb3Jlc3QubWFrZVNldCh2ZXJ0ZXguaWQpO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBlZGdlcyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHdlaWdodC4gV2Ugd2lsbCBwb3AgZWRnZXMgYmVnaW5uaW5nXG4gICAgLy8gZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICBlZGdlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiAtKGEud2VpZ2h0IC0gYi53ZWlnaHQpO1xuICAgIH0pO1xuXG4gICAgd2hpbGUgKGVkZ2VzLmxlbmd0aCAmJiBmb3Jlc3Quc2l6ZSgpID4gMSkge1xuICAgICAgICBsZXQgZWRnZSA9IGVkZ2VzLnBvcCgpO1xuXG4gICAgICAgIGlmIChmb3Jlc3QuZmluZChlZGdlLnNvdXJjZSkgIT09IGZvcmVzdC5maW5kKGVkZ2UudGFyZ2V0KSkge1xuICAgICAgICAgICAgZm9yZXN0LnVuaW9uKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICBzZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogdmVydGljZXMsXG4gICAgICAgIGxpbmtzOiBzZWxlY3RlZEVkZ2VzXG4gICAgfVxufVxuXG4vLzxlZGl0b3ItZm9sZCBkZXNjPVwiVGhpcyBzZWN0aW9uIGlzIGZvciB0aGUgZGlzam9pbnQgc2V0XCI+XG5mdW5jdGlvbiBEaXNqb2ludFNldCgpIHtcbiAgICB0aGlzLmluZGV4XyA9IHt9O1xufVxuXG5mdW5jdGlvbiBOb2RlKGlkKSB7XG4gICAgdGhpcy5pZF8gPSBpZDtcbiAgICB0aGlzLnBhcmVudF8gPSB0aGlzO1xuICAgIHRoaXMucmFua18gPSAwO1xufVxuXG5EaXNqb2ludFNldC5wcm90b3R5cGUubWFrZVNldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmICghdGhpcy5pbmRleF9baWRdKSB7XG4gICAgICAgIGxldCBjcmVhdGVkID0gbmV3IE5vZGUoaWQpO1xuICAgICAgICB0aGlzLmluZGV4X1tpZF0gPSBjcmVhdGVkO1xuICAgIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgaWQgb2YgdGhlIHJlcHJlc2VudGF0aXZlIGVsZW1lbnQgb2YgdGhpcyBzZXQgdGhhdCAoaWQpXG4vLyBiZWxvbmdzIHRvLlxuRGlzam9pbnRTZXQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAodGhpcy5pbmRleF9baWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudCA9IHRoaXMuaW5kZXhfW2lkXS5wYXJlbnRfO1xuICAgIHdoaWxlIChjdXJyZW50ICE9PSBjdXJyZW50LnBhcmVudF8pIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50XztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQuaWRfO1xufVxuXG5EaXNqb2ludFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGxldCB4Um9vdCA9IHRoaXMuaW5kZXhfW3RoaXMuZmluZCh4KV07XG4gICAgbGV0IHlSb290ID0gdGhpcy5pbmRleF9bdGhpcy5maW5kKHkpXTtcblxuICAgIGlmICh4Um9vdCA9PT0gdW5kZWZpbmVkIHx8IHlSb290ID09PSB1bmRlZmluZWQgfHwgeFJvb3QgPT09IHlSb290KSB7XG4gICAgICAgIC8vIHggYW5kIHkgYWxyZWFkeSBiZWxvbmcgdG8gdGhlIHNhbWUgc2V0LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHhSb290LnJhbmsgPCB5Um9vdC5yYW5rKSB7IC8vIE1vdmUgeCBpbnRvIHRoZSBzZXQgeSBpcyBhIG1lbWJlciBvZi5cbiAgICAgICAgeFJvb3QucGFyZW50XyA9IHlSb290O1xuICAgIH0gZWxzZSBpZiAoeVJvb3QucmFua18gPCB4Um9vdC5yYW5rXykgeyAvLyBNb3ZlIHkgaW50byB0aGUgc2V0IHggaXMgYSBtZW1iZXIgb2YuXG4gICAgICAgIHlSb290LnBhcmVudF8gPSB4Um9vdDtcbiAgICB9IGVsc2UgeyAvLyBBcmJpdHJhcmlseSBjaG9vc2UgdG8gbW92ZSB5IGludG8gdGhlIHNldCB4IGlzIGEgbWVtYmVyIG9mLlxuICAgICAgICB5Um9vdC5wYXJlbnRfID0geFJvb3Q7XG4gICAgICAgIHhSb290LnJhbmtfKys7XG4gICAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBjdXJyZW50IG51bWJlciBvZiBkaXNqb2ludCBzZXRzLlxuRGlzam9pbnRTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHVuaXF1ZUluZGljZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmluZGV4XykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgdW5pcXVlSW5kaWNlc1tpZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh1bmlxdWVJbmRpY2VzKS5sZW5ndGg7XG59XG4vLzwvZWRpdG9yLWZvbGQ+XG4iLCJmdW5jdGlvbiByKHIpe3ZhciB0LG4sZT1yLmxlbmd0aDtpZigxPT09ZSl0PTAsbj1yWzBdWzFdO2Vsc2V7Zm9yKHZhciBvLGEsaCxmPTAsdT0wLGk9MCxsPTAsZz0wO2c8ZTtnKyspZis9YT0obz1yW2ddKVswXSx1Kz1oPW9bMV0saSs9YSphLGwrPWEqaDtuPXUvZS0odD0oZSpsLWYqdSkvKGUqaS1mKmYpKSpmL2V9cmV0dXJue206dCxiOm59fWZ1bmN0aW9uIHQocil7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiByLmIrci5tKnR9fWZ1bmN0aW9uIG4ocil7aWYoMD09PXIubGVuZ3RoKXJldHVybiAwO2Zvcih2YXIgdCxuPXJbMF0sZT0wLG89MTtvPHIubGVuZ3RoO28rKyl0PW4rcltvXSxNYXRoLmFicyhuKT49TWF0aC5hYnMocltvXSk/ZSs9bi10K3Jbb106ZSs9cltvXS10K24sbj10O3JldHVybiBuK2V9ZnVuY3Rpb24gZShyKXtpZigwPT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibWVhbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtyZXR1cm4gbihyKS9yLmxlbmd0aH1mdW5jdGlvbiBvKHIsdCl7dmFyIG4sbyxhPWUociksaD0wO2lmKDI9PT10KWZvcihvPTA7bzxyLmxlbmd0aDtvKyspaCs9KG49cltvXS1hKSpuO2Vsc2UgZm9yKG89MDtvPHIubGVuZ3RoO28rKyloKz1NYXRoLnBvdyhyW29dLWEsdCk7cmV0dXJuIGh9ZnVuY3Rpb24gYShyKXtpZigwPT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7cmV0dXJuIG8ociwyKS9yLmxlbmd0aH1mdW5jdGlvbiBoKHIpe2lmKDE9PT1yLmxlbmd0aClyZXR1cm4gMDt2YXIgdD1hKHIpO3JldHVybiBNYXRoLnNxcnQodCl9ZnVuY3Rpb24gZihyLHQpe2lmKHIubGVuZ3RoPDIpcmV0dXJuIDE7Zm9yKHZhciBuPTAsZT0wO2U8ci5sZW5ndGg7ZSsrKW4rPXJbZV1bMV07Zm9yKHZhciBvPW4vci5sZW5ndGgsYT0wLGg9MDtoPHIubGVuZ3RoO2grKylhKz1NYXRoLnBvdyhvLXJbaF1bMV0sMik7Zm9yKHZhciBmPTAsdT0wO3U8ci5sZW5ndGg7dSsrKWYrPU1hdGgucG93KHJbdV1bMV0tdChyW3VdWzBdKSwyKTtyZXR1cm4gMS1mL2F9ZnVuY3Rpb24gdShyKXtpZigwPT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtpZigxPT09ci5sZW5ndGgpcmV0dXJuIHJbMF07Zm9yKHZhciB0PXJbMF0sbj1OYU4sZT0wLG89MSxhPTE7YTxyLmxlbmd0aCsxO2ErKylyW2FdIT09dD8obz5lJiYoZT1vLG49dCksbz0xLHQ9clthXSk6bysrO3JldHVybiBufWZ1bmN0aW9uIGkocil7cmV0dXJuIHIuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHIsdCl7cmV0dXJuIHItdH0pfWZ1bmN0aW9uIGwocil7cmV0dXJuIHUoaShyKSl9ZnVuY3Rpb24gZyhyKXtmb3IodmFyIHQsbj1uZXcgTWFwLGU9MCxvPTA7bzxyLmxlbmd0aDtvKyspe3ZhciBhPW4uZ2V0KHJbb10pO3ZvaWQgMD09PWE/YT0xOmErKyxhPmUmJih0PXJbb10sZT1hKSxuLnNldChyW29dLGEpfWlmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIm1vZGUgcmVxdWlyZXMgYXQgbGFzdCBvbmUgZGF0YSBwb2ludFwiKTtyZXR1cm4gdH1mdW5jdGlvbiB2KHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciB0PXJbMF0sbj0xO248ci5sZW5ndGg7bisrKXJbbl08dCYmKHQ9cltuXSk7cmV0dXJuIHR9ZnVuY3Rpb24gYyhyKXtpZigwPT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibWF4IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgdD1yWzBdLG49MTtuPHIubGVuZ3RoO24rKylyW25dPnQmJih0PXJbbl0pO3JldHVybiB0fWZ1bmN0aW9uIHMocil7aWYoMD09PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImV4dGVudCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHQ9clswXSxuPXJbMF0sZT0xO2U8ci5sZW5ndGg7ZSsrKXJbZV0+biYmKG49cltlXSkscltlXTx0JiYodD1yW2VdKTtyZXR1cm5bdCxuXX1mdW5jdGlvbiBwKHIpe3JldHVybiByWzBdfWZ1bmN0aW9uIE0ocil7cmV0dXJuIHJbci5sZW5ndGgtMV19ZnVuY3Rpb24gdyhyKXtyZXR1cm5bclswXSxyW3IubGVuZ3RoLTFdXX1mdW5jdGlvbiBxKHIpe2Zvcih2YXIgdD0wLG49MDtuPHIubGVuZ3RoO24rKyl0Kz1yW25dO3JldHVybiB0fWZ1bmN0aW9uIEUocil7Zm9yKHZhciB0PTEsbj0wO248ci5sZW5ndGg7bisrKXQqPXJbbl07cmV0dXJuIHR9ZnVuY3Rpb24geShyLHQpe3ZhciBuPXIubGVuZ3RoKnQ7aWYoMD09PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInF1YW50aWxlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50LlwiKTtpZih0PDB8fHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJxdWFudGlsZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIik7cmV0dXJuIDE9PT10P3Jbci5sZW5ndGgtMV06MD09PXQ/clswXTpuJTEhPTA/cltNYXRoLmNlaWwobiktMV06ci5sZW5ndGglMj09MD8ocltuLTFdK3Jbbl0pLzI6cltuXX1mdW5jdGlvbiBiKHIsdCxuLGUpe2ZvcihuPW58fDAsZT1lfHxyLmxlbmd0aC0xO2U+bjspe2lmKGUtbj42MDApe3ZhciBvPWUtbisxLGE9dC1uKzEsaD1NYXRoLmxvZyhvKSxmPS41Kk1hdGguZXhwKDIqaC8zKSx1PS41Kk1hdGguc3FydChoKmYqKG8tZikvbyk7YS1vLzI8MCYmKHUqPS0xKSxiKHIsdCxNYXRoLm1heChuLE1hdGguZmxvb3IodC1hKmYvbyt1KSksTWF0aC5taW4oZSxNYXRoLmZsb29yKHQrKG8tYSkqZi9vK3UpKSl9dmFyIGk9clt0XSxsPW4sZz1lO2ZvcihkKHIsbix0KSxyW2VdPmkmJmQocixuLGUpO2w8Zzspe2ZvcihkKHIsbCxnKSxsKyssZy0tO3JbbF08aTspbCsrO2Zvcig7cltnXT5pOylnLS19cltuXT09PWk/ZChyLG4sZyk6ZChyLCsrZyxlKSxnPD10JiYobj1nKzEpLHQ8PWcmJihlPWctMSl9fWZ1bmN0aW9uIGQocix0LG4pe3ZhciBlPXJbdF07clt0XT1yW25dLHJbbl09ZX1mdW5jdGlvbiBJKHIsdCl7dmFyIG49ci5zbGljZSgpO2lmKEFycmF5LmlzQXJyYXkodCkpeyFmdW5jdGlvbihyLHQpe2Zvcih2YXIgbj1bMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKW4ucHVzaChOKHIubGVuZ3RoLHRbZV0pKTtuLnB1c2goci5sZW5ndGgtMSksbi5zb3J0KEMpO3ZhciBvPVswLG4ubGVuZ3RoLTFdO2Zvcig7by5sZW5ndGg7KXt2YXIgYT1NYXRoLmNlaWwoby5wb3AoKSksaD1NYXRoLmZsb29yKG8ucG9wKCkpO2lmKCEoYS1oPD0xKSl7dmFyIGY9TWF0aC5mbG9vcigoaCthKS8yKTtQKHIsbltmXSxNYXRoLmZsb29yKG5baF0pLE1hdGguY2VpbChuW2FdKSksby5wdXNoKGgsZixmLGEpfX19KG4sdCk7Zm9yKHZhciBlPVtdLG89MDtvPHQubGVuZ3RoO28rKyllW29dPXkobix0W29dKTtyZXR1cm4gZX1yZXR1cm4gUChuLE4obi5sZW5ndGgsdCksMCxuLmxlbmd0aC0xKSx5KG4sdCl9ZnVuY3Rpb24gUChyLHQsbixlKXt0JTE9PTA/YihyLHQsbixlKTooYihyLHQ9TWF0aC5mbG9vcih0KSxuLGUpLGIocix0KzEsdCsxLGUpKX1mdW5jdGlvbiBDKHIsdCl7cmV0dXJuIHItdH1mdW5jdGlvbiBOKHIsdCl7dmFyIG49cip0O3JldHVybiAxPT09dD9yLTE6MD09PXQ/MDpuJTEhPTA/TWF0aC5jZWlsKG4pLTE6ciUyPT0wP24tLjU6bn1mdW5jdGlvbiBfKHIsdCl7aWYodDxyWzBdKXJldHVybiAwO2lmKHQ+cltyLmxlbmd0aC0xXSlyZXR1cm4gMTt2YXIgbj1mdW5jdGlvbihyLHQpe3ZhciBuPTAsZT0wLG89ci5sZW5ndGg7Zm9yKDtlPG87KXQ8PXJbbj1lK28+Pj4xXT9vPW46ZT0tfm47cmV0dXJuIGV9KHIsdCk7aWYocltuXSE9PXQpcmV0dXJuIG4vci5sZW5ndGg7bisrO3ZhciBlPWZ1bmN0aW9uKHIsdCl7dmFyIG49MCxlPTAsbz1yLmxlbmd0aDtmb3IoO2U8bzspdD49cltuPWUrbz4+PjFdP2U9LX5uOm89bjtyZXR1cm4gZX0ocix0KTtpZihlPT09bilyZXR1cm4gbi9yLmxlbmd0aDt2YXIgbz1lLW4rMTtyZXR1cm4gbyooZStuKS8yL28vci5sZW5ndGh9ZnVuY3Rpb24gQShyLHQpe3JldHVybiBfKGkociksdCl9ZnVuY3Rpb24geihyKXt2YXIgdD1JKHIsLjc1KSxuPUkociwuMjUpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0JiZcIm51bWJlclwiPT10eXBlb2YgbilyZXR1cm4gdC1ufWZ1bmN0aW9uIFUocil7cmV0dXJuK0kociwuNSl9ZnVuY3Rpb24gSyhyKXtmb3IodmFyIHQ9VShyKSxuPVtdLGU9MDtlPHIubGVuZ3RoO2UrKyluLnB1c2goTWF0aC5hYnMocltlXS10KSk7cmV0dXJuIFUobil9ZnVuY3Rpb24gQihyLHQpe3ZhciBuPVtdO2lmKHQ8MSl0aHJvdyBuZXcgRXJyb3IoXCJjaHVuayBzaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7aWYoTWF0aC5mbG9vcih0KSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiY2h1bmsgc2l6ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKz10KW4ucHVzaChyLnNsaWNlKGUsZSt0KSk7cmV0dXJuIG59ZnVuY3Rpb24gRyhyLHQsbil7aWYoMD09PXIubGVuZ3RoKXJldHVybltdO249bnx8TWF0aC5yYW5kb207Zm9yKHZhciBlPXIubGVuZ3RoLG89W10sYT0wO2E8dDthKyspe3ZhciBoPU1hdGguZmxvb3IobigpKmUpO28ucHVzaChyW2hdKX1yZXR1cm4gb31mdW5jdGlvbiBIKHIsdCl7dD10fHxNYXRoLnJhbmRvbTtmb3IodmFyIG4sZSxvPXIubGVuZ3RoO28+MDspZT1NYXRoLmZsb29yKHQoKSpvLS0pLG49cltvXSxyW29dPXJbZV0scltlXT1uO3JldHVybiByfWZ1bmN0aW9uIEoocix0KXtyZXR1cm4gSChyLnNsaWNlKCkuc2xpY2UoKSx0KX1mdW5jdGlvbiBRKHIsdCxuKXtyZXR1cm4gSihyLG4pLnNsaWNlKDAsdCl9ZnVuY3Rpb24gUihyKXtmb3IodmFyIHQsbj0wLGU9MDtlPHIubGVuZ3RoO2UrKykwIT09ZSYmcltlXT09PXR8fCh0PXJbZV0sbisrKTtyZXR1cm4gbn1mdW5jdGlvbiBXKHIsdCl7Zm9yKHZhciBuPVtdLGU9MDtlPHI7ZSsrKXtmb3IodmFyIG89W10sYT0wO2E8dDthKyspby5wdXNoKDApO24ucHVzaChvKX1yZXR1cm4gbn1mdW5jdGlvbiBZKHIsdCxuLGUpe3ZhciBvO2lmKHI+MCl7dmFyIGE9KG5bdF0tbltyLTFdKS8odC1yKzEpO289ZVt0XS1lW3ItMV0tKHQtcisxKSphKmF9ZWxzZSBvPWVbdF0tblt0XSpuW3RdLyh0KzEpO3JldHVybiBvPDA/MDpvfWZ1bmN0aW9uIFoocix0LG4sZSxvLGEsaCl7aWYoIShyPnQpKXt2YXIgZj1NYXRoLmZsb29yKChyK3QpLzIpO2Vbbl1bZl09ZVtuLTFdW2YtMV0sb1tuXVtmXT1mO3ZhciB1PW47cj5uJiYodT1NYXRoLm1heCh1LG9bbl1bci0xXXx8MCkpLHU9TWF0aC5tYXgodSxvW24tMV1bZl18fDApO3ZhciBpLGwsZyx2PWYtMTt0PGUubGVuZ3RoLTEmJih2PU1hdGgubWluKHYsb1tuXVt0KzFdfHwwKSk7Zm9yKHZhciBjPXY7Yz49dSYmISgoaT1ZKGMsZixhLGgpKStlW24tMV1bdS0xXT49ZVtuXVtmXSk7LS1jKShsPVkodSxmLGEsaCkrZVtuLTFdW3UtMV0pPGVbbl1bZl0mJihlW25dW2ZdPWwsb1tuXVtmXT11KSx1KyssKGc9aStlW24tMV1bYy0xXSk8ZVtuXVtmXSYmKGVbbl1bZl09ZyxvW25dW2ZdPWMpO1oocixmLTEsbixlLG8sYSxoKSxaKGYrMSx0LG4sZSxvLGEsaCl9fWZ1bmN0aW9uIHgocix0KXtpZih0PnIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZW5lcmF0ZSBtb3JlIGNsYXNzZXMgdGhhbiB0aGVyZSBhcmUgZGF0YSB2YWx1ZXNcIik7dmFyIG49aShyKTtpZigxPT09UihuKSlyZXR1cm5bbl07dmFyIGU9Vyh0LG4ubGVuZ3RoKSxvPVcodCxuLmxlbmd0aCk7IWZ1bmN0aW9uKHIsdCxuKXtmb3IodmFyIGU9dFswXS5sZW5ndGgsbz1yW01hdGguZmxvb3IoZS8yKV0sYT1bXSxoPVtdLGY9MCx1PXZvaWQgMDtmPGU7KytmKXU9cltmXS1vLDA9PT1mPyhhLnB1c2godSksaC5wdXNoKHUqdSkpOihhLnB1c2goYVtmLTFdK3UpLGgucHVzaChoW2YtMV0rdSp1KSksdFswXVtmXT1ZKDAsZixhLGgpLG5bMF1bZl09MDtmb3IodmFyIGk9MTtpPHQubGVuZ3RoOysraSlaKGk8dC5sZW5ndGgtMT9pOmUtMSxlLTEsaSx0LG4sYSxoKX0obixlLG8pO2Zvcih2YXIgYT1bXSxoPW9bMF0ubGVuZ3RoLTEsZj1vLmxlbmd0aC0xO2Y+PTA7Zi0tKXt2YXIgdT1vW2ZdW2hdO2FbZl09bi5zbGljZSh1LGgrMSksZj4wJiYoaD11LTEpfXJldHVybiBhfWZ1bmN0aW9uIFQocix0KXtpZihyLmxlbmd0aDwyKXJldHVybiByO2Zvcih2YXIgbj12KHIpLGU9YyhyKSxvPVtuXSxhPShlLW4pL3QsaD0xO2g8dDtoKyspby5wdXNoKG9bMF0rYSpoKTtyZXR1cm4gby5wdXNoKGUpLG99ZnVuY3Rpb24gRChyLHQpe2lmKHIubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlQ292YXJpYW5jZSByZXF1aXJlcyBzYW1wbGVzIHdpdGggZXF1YWwgbGVuZ3Roc1wiKTtpZihyLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlXCIpO2Zvcih2YXIgbj1lKHIpLG89ZSh0KSxhPTAsaD0wO2g8ci5sZW5ndGg7aCsrKWErPShyW2hdLW4pKih0W2hdLW8pO3JldHVybiBhLyhyLmxlbmd0aC0xKX1mdW5jdGlvbiBMKHIpe2lmKHIubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlVmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzXCIpO3JldHVybiBvKHIsMikvKHIubGVuZ3RoLTEpfWZ1bmN0aW9uIE8ocil7dmFyIHQ9TChyKTtyZXR1cm4gTWF0aC5zcXJ0KHQpfWZ1bmN0aW9uIFgocix0KXtyZXR1cm4gRChyLHQpL08ocikvTyh0KX1mdW5jdGlvbiBWKHIpe2lmKHIubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlU2tld25lc3MgcmVxdWlyZXMgYXQgbGVhc3QgdGhyZWUgZGF0YSBwb2ludHNcIik7Zm9yKHZhciB0LG49ZShyKSxvPTAsYT0wLGg9MDtoPHIubGVuZ3RoO2grKylvKz0odD1yW2hdLW4pKnQsYSs9dCp0KnQ7dmFyIGY9TWF0aC5zcXJ0KG8vKHIubGVuZ3RoLTEpKSx1PXIubGVuZ3RoO3JldHVybiB1KmEvKCh1LTEpKih1LTIpKk1hdGgucG93KGYsMykpfWZ1bmN0aW9uIG0ocil7dmFyIHQ9ci5sZW5ndGg7aWYodDw0KXRocm93IG5ldyBFcnJvcihcInNhbXBsZUt1cnRvc2lzIHJlcXVpcmVzIGF0IGxlYXN0IGZvdXIgZGF0YSBwb2ludHNcIik7Zm9yKHZhciBuLG89ZShyKSxhPTAsaD0wLGY9MDtmPHQ7ZisrKWErPShuPXJbZl0tbykqbixoKz1uKm4qbipuO3JldHVybih0LTEpLygodC0yKSoodC0zKSkqKHQqKHQrMSkqaC8oYSphKS0zKih0LTEpKX1mdW5jdGlvbiBGKHIpe2Zvcih2YXIgdD1uZXcgQXJyYXkoci5sZW5ndGgpLG49W3Iuc2xpY2UoKV0sZT0wO2U8ci5sZW5ndGg7ZSsrKXRbZV09MDtmb3IodmFyIG89MDtvPHIubGVuZ3RoOylpZih0W29dPG8pe3ZhciBhPTA7byUyIT0wJiYoYT10W29dKTt2YXIgaD1yW2FdO3JbYV09cltvXSxyW29dPWgsbi5wdXNoKHIuc2xpY2UoKSksdFtvXSsrLG89MH1lbHNlIHRbb109MCxvKys7cmV0dXJuIG59ZnVuY3Rpb24gayhyLHQpe3ZhciBuLGUsbyxhLGg9W107Zm9yKG49MDtuPHIubGVuZ3RoO24rKylpZigxPT09dCloLnB1c2goW3Jbbl1dKTtlbHNlIGZvcihvPWsoci5zbGljZShuKzEsci5sZW5ndGgpLHQtMSksZT0wO2U8by5sZW5ndGg7ZSsrKShhPW9bZV0pLnVuc2hpZnQocltuXSksaC5wdXNoKGEpO3JldHVybiBofWZ1bmN0aW9uIFMocix0KXtmb3IodmFyIG49W10sZT0wO2U8ci5sZW5ndGg7ZSsrKWlmKDE9PT10KW4ucHVzaChbcltlXV0pO2Vsc2UgZm9yKHZhciBvPVMoci5zbGljZShlLHIubGVuZ3RoKSx0LTEpLGE9MDthPG8ubGVuZ3RoO2ErKyluLnB1c2goW3JbZV1dLmNvbmNhdChvW2FdKSk7cmV0dXJuIG59ZnVuY3Rpb24gaihyLHQsbil7cmV0dXJuIHIrKG4tcikvKHQrMSl9ZnVuY3Rpb24gJChyLHQsbixlKXtyZXR1cm4ocip0K24qZSkvKHQrZSl9ZnVuY3Rpb24gcnIocix0LG4sZSxvLGEpe3ZhciBoPSQodCxuLG8sYSk7cmV0dXJuKG4qKHIrTWF0aC5wb3codC1oLDIpKSthKihlK01hdGgucG93KG8taCwyKSkpLyhuK2EpfWZ1bmN0aW9uIHRyKHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgdD0xLG49MDtuPHIubGVuZ3RoO24rKyl7aWYocltuXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyaWNNZWFuIHJlcXVpcmVzIG9ubHkgcG9zaXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiKTt0Kj1yW25dfXJldHVybiBNYXRoLnBvdyh0LDEvci5sZW5ndGgpfWZ1bmN0aW9uIG5yKHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJoYXJtb25pY01lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciB0PTAsbj0wO248ci5sZW5ndGg7bisrKXtpZihyW25dPD0wKXRocm93IG5ldyBFcnJvcihcImhhcm1vbmljTWVhbiByZXF1aXJlcyBvbmx5IHBvc2l0aXZlIG51bWJlcnMgYXMgaW5wdXRcIik7dCs9MS9yW25dfXJldHVybiByLmxlbmd0aC90fWZ1bmN0aW9uIGVyKHIpe3JldHVybiB5KHIsLjUpfWZ1bmN0aW9uIG9yKHIsdCxuKXtyZXR1cm4ocip0LW4pLyh0LTEpfWZ1bmN0aW9uIGFyKHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJyb290TWVhblNxdWFyZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHQ9MCxuPTA7bjxyLmxlbmd0aDtuKyspdCs9TWF0aC5wb3cocltuXSwyKTtyZXR1cm4gTWF0aC5zcXJ0KHQvci5sZW5ndGgpfWZ1bmN0aW9uIGhyKHIsdCl7cmV0dXJuKGUociktdCkvKGgocikvTWF0aC5zcXJ0KHIubGVuZ3RoKSl9ZnVuY3Rpb24gZnIocix0LG4pe3ZhciBvPXIubGVuZ3RoLGE9dC5sZW5ndGg7aWYoIW98fCFhKXJldHVybiBudWxsO258fChuPTApO3ZhciBoPWUociksZj1lKHQpLHU9TChyKSxpPUwodCk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGgmJlwibnVtYmVyXCI9PXR5cGVvZiBmJiZcIm51bWJlclwiPT10eXBlb2YgdSYmXCJudW1iZXJcIj09dHlwZW9mIGk/KGgtZi1uKS9NYXRoLnNxcnQoKChvLTEpKnUrKGEtMSkqaSkvKG8rYS0yKSooMS9vKzEvYSkpOnZvaWQgMH12YXIgdXI9ZnVuY3Rpb24oKXt0aGlzLnRvdGFsQ291bnQ9MCx0aGlzLmRhdGE9e319O3VyLnByb3RvdHlwZS50cmFpbj1mdW5jdGlvbihyLHQpe2Zvcih2YXIgbiBpbiB0aGlzLmRhdGFbdF18fCh0aGlzLmRhdGFbdF09e30pLHIpe3ZhciBlPXJbbl07dm9pZCAwPT09dGhpcy5kYXRhW3RdW25dJiYodGhpcy5kYXRhW3RdW25dPXt9KSx2b2lkIDA9PT10aGlzLmRhdGFbdF1bbl1bZV0mJih0aGlzLmRhdGFbdF1bbl1bZV09MCksdGhpcy5kYXRhW3RdW25dW2VdKyt9dGhpcy50b3RhbENvdW50Kyt9LHVyLnByb3RvdHlwZS5zY29yZT1mdW5jdGlvbihyKXt2YXIgdCxuPXt9O2Zvcih2YXIgZSBpbiByKXt2YXIgbz1yW2VdO2Zvcih0IGluIHRoaXMuZGF0YSluW3RdPXt9LG5bdF1bZStcIl9cIitvXT10aGlzLmRhdGFbdF1bZV0/KHRoaXMuZGF0YVt0XVtlXVtvXXx8MCkvdGhpcy50b3RhbENvdW50OjB9dmFyIGE9e307Zm9yKHQgaW4gbilmb3IodmFyIGggaW4gYVt0XT0wLG5bdF0pYVt0XSs9blt0XVtoXTtyZXR1cm4gYX07dmFyIGlyPWZ1bmN0aW9uKCl7dGhpcy53ZWlnaHRzPVtdLHRoaXMuYmlhcz0wfTtpci5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbihyKXtpZihyLmxlbmd0aCE9PXRoaXMud2VpZ2h0cy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciB0PTAsbj0wO248dGhpcy53ZWlnaHRzLmxlbmd0aDtuKyspdCs9dGhpcy53ZWlnaHRzW25dKnJbbl07cmV0dXJuKHQrPXRoaXMuYmlhcyk+MD8xOjB9LGlyLnByb3RvdHlwZS50cmFpbj1mdW5jdGlvbihyLHQpe2lmKDAhPT10JiYxIT09dClyZXR1cm4gbnVsbDtyLmxlbmd0aCE9PXRoaXMud2VpZ2h0cy5sZW5ndGgmJih0aGlzLndlaWdodHM9cix0aGlzLmJpYXM9MSk7dmFyIG49dGhpcy5wcmVkaWN0KHIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBuJiZuIT09dCl7Zm9yKHZhciBlPXQtbixvPTA7bzx0aGlzLndlaWdodHMubGVuZ3RoO28rKyl0aGlzLndlaWdodHNbb10rPWUqcltvXTt0aGlzLmJpYXMrPWV9cmV0dXJuIHRoaXN9O3ZhciBscj0xZS00O2Z1bmN0aW9uIGdyKHIpe2lmKHI8MCl0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3JpYWwgcmVxdWlyZXMgYSBub24tbmVnYXRpdmUgdmFsdWVcIik7aWYoTWF0aC5mbG9vcihyKSE9PXIpdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yaWFsIHJlcXVpcmVzIGFuIGludGVnZXIgaW5wdXRcIik7Zm9yKHZhciB0PTEsbj0yO248PXI7bisrKXQqPW47cmV0dXJuIHR9ZnVuY3Rpb24gdnIocil7aWYoTnVtYmVyLmlzSW50ZWdlcihyKSlyZXR1cm4gcjw9MD9OYU46Z3Ioci0xKTtpZigtLXI8MClyZXR1cm4gTWF0aC5QSS8oTWF0aC5zaW4oTWF0aC5QSSotcikqdnIoLXIpKTt2YXIgdD1yKy4yNTtyZXR1cm4gTWF0aC5wb3coci9NYXRoLkUscikqTWF0aC5zcXJ0KDIqTWF0aC5QSSoocisxLzYpKSooMSsxLzE0NC9NYXRoLnBvdyh0LDIpLTEvMTI5NjAvTWF0aC5wb3codCwzKS0yNTcvMjA3MzYwL01hdGgucG93KHQsNCktNTIvMjYxMjczNi9NYXRoLnBvdyh0LDUpKzU3NDExNzMvOTQwNTg0OTYwMC9NYXRoLnBvdyh0LDYpKzM3NTI5LzE4ODExNjk5MjAwL01hdGgucG93KHQsNykpfXZhciBjcj1bLjk5OTk5OTk5OTk5OTk5NzEsNTcuMTU2MjM1NjY1ODYyOTIsLTU5LjU5Nzk2MDM1NTQ3NTQ5LDE0LjEzNjA5Nzk3NDc0MTc0NiwtLjQ5MTkxMzgxNjA5NzYyMDIsMzM5OTQ2NDk5ODQ4MTE4OWUtMjAsNDY1MjM2Mjg5MjcwNDg1OGUtMjAsLTk4Mzc0NDc1MzA0ODc5NTZlLTIwLC4wMDAxNTgwODg3MDMyMjQ5MTI1LC0uMDAwMjEwMjY0NDQxNzI0MTA0ODgsLjAwMDIxNzQzOTYxODExNTIxMjY1LC0uMDAwMTY0MzE4MTA2NTM2NzYzOSw4NDQxODIyMzk4Mzg1Mjc1ZS0yMCwtMjYxOTA4Mzg0MDE1ODE0MDhlLTIxLDM2ODk5MTgyNjU5NTMxNjI1ZS0yMl0sc3I9NjA3LzEyOCxwcj1NYXRoLmxvZyhNYXRoLnNxcnQoMipNYXRoLlBJKSk7ZnVuY3Rpb24gTXIocil7aWYocjw9MClyZXR1cm4gSW5maW5pdHk7ci0tO2Zvcih2YXIgdD1jclswXSxuPTE7bjwxNTtuKyspdCs9Y3Jbbl0vKHIrbik7dmFyIGU9c3IrLjUrcjtyZXR1cm4gcHIrTWF0aC5sb2codCktZSsocisuNSkqTWF0aC5sb2coZSl9ZnVuY3Rpb24gd3Iocil7aWYocjwwfHxyPjEpdGhyb3cgbmV3IEVycm9yKFwiYmVybm91bGxpRGlzdHJpYnV0aW9uIHJlcXVpcmVzIHByb2JhYmlsaXR5IHRvIGJlIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVcIik7cmV0dXJuWzEtcixyXX1mdW5jdGlvbiBxcihyLHQpe2lmKCEodDwwfHx0PjF8fHI8PTB8fHIlMSE9MCkpe3ZhciBuPTAsZT0wLG89W10sYT0xO2Rve29bbl09YSpNYXRoLnBvdyh0LG4pKk1hdGgucG93KDEtdCxyLW4pLGUrPW9bbl0sYT1hKihyLSsrbisxKS9ufXdoaWxlKGU8MS1scik7cmV0dXJuIG99fWZ1bmN0aW9uIEVyKHIpe2lmKCEocjw9MCkpe3ZhciB0PTAsbj0wLGU9W10sbz0xO2Rve2VbdF09TWF0aC5leHAoLXIpKk1hdGgucG93KHIsdCkvbyxuKz1lW3RdLG8qPSsrdH13aGlsZShuPDEtbHIpO3JldHVybiBlfX12YXIgeXI9ezE6ey45OTU6MCwuOTk6MCwuOTc1OjAsLjk1OjAsLjk6LjAyLC41Oi40NSwuMToyLjcxLC4wNTozLjg0LC4wMjU6NS4wMiwuMDE6Ni42MywuMDA1OjcuODh9LDI6ey45OTU6LjAxLC45OTouMDIsLjk3NTouMDUsLjk1Oi4xLC45Oi4yMSwuNToxLjM5LC4xOjQuNjEsLjA1OjUuOTksLjAyNTo3LjM4LC4wMTo5LjIxLC4wMDU6MTAuNn0sMzp7Ljk5NTouMDcsLjk5Oi4xMSwuOTc1Oi4yMiwuOTU6LjM1LC45Oi41OCwuNToyLjM3LC4xOjYuMjUsLjA1OjcuODEsLjAyNTo5LjM1LC4wMToxMS4zNCwuMDA1OjEyLjg0fSw0OnsuOTk1Oi4yMSwuOTk6LjMsLjk3NTouNDgsLjk1Oi43MSwuOToxLjA2LC41OjMuMzYsLjE6Ny43OCwuMDU6OS40OSwuMDI1OjExLjE0LC4wMToxMy4yOCwuMDA1OjE0Ljg2fSw1OnsuOTk1Oi40MSwuOTk6LjU1LC45NzU6LjgzLC45NToxLjE1LC45OjEuNjEsLjU6NC4zNSwuMTo5LjI0LC4wNToxMS4wNywuMDI1OjEyLjgzLC4wMToxNS4wOSwuMDA1OjE2Ljc1fSw2OnsuOTk1Oi42OCwuOTk6Ljg3LC45NzU6MS4yNCwuOTU6MS42NCwuOToyLjIsLjU6NS4zNSwuMToxMC42NSwuMDU6MTIuNTksLjAyNToxNC40NSwuMDE6MTYuODEsLjAwNToxOC41NX0sNzp7Ljk5NTouOTksLjk5OjEuMjUsLjk3NToxLjY5LC45NToyLjE3LC45OjIuODMsLjU6Ni4zNSwuMToxMi4wMiwuMDU6MTQuMDcsLjAyNToxNi4wMSwuMDE6MTguNDgsLjAwNToyMC4yOH0sODp7Ljk5NToxLjM0LC45OToxLjY1LC45NzU6Mi4xOCwuOTU6Mi43MywuOTozLjQ5LC41OjcuMzQsLjE6MTMuMzYsLjA1OjE1LjUxLC4wMjU6MTcuNTMsLjAxOjIwLjA5LC4wMDU6MjEuOTZ9LDk6ey45OTU6MS43MywuOTk6Mi4wOSwuOTc1OjIuNywuOTU6My4zMywuOTo0LjE3LC41OjguMzQsLjE6MTQuNjgsLjA1OjE2LjkyLC4wMjU6MTkuMDIsLjAxOjIxLjY3LC4wMDU6MjMuNTl9LDEwOnsuOTk1OjIuMTYsLjk5OjIuNTYsLjk3NTozLjI1LC45NTozLjk0LC45OjQuODcsLjU6OS4zNCwuMToxNS45OSwuMDU6MTguMzEsLjAyNToyMC40OCwuMDE6MjMuMjEsLjAwNToyNS4xOX0sMTE6ey45OTU6Mi42LC45OTozLjA1LC45NzU6My44MiwuOTU6NC41NywuOTo1LjU4LC41OjEwLjM0LC4xOjE3LjI4LC4wNToxOS42OCwuMDI1OjIxLjkyLC4wMToyNC43MiwuMDA1OjI2Ljc2fSwxMjp7Ljk5NTozLjA3LC45OTozLjU3LC45NzU6NC40LC45NTo1LjIzLC45OjYuMywuNToxMS4zNCwuMToxOC41NSwuMDU6MjEuMDMsLjAyNToyMy4zNCwuMDE6MjYuMjIsLjAwNToyOC4zfSwxMzp7Ljk5NTozLjU3LC45OTo0LjExLC45NzU6NS4wMSwuOTU6NS44OSwuOTo3LjA0LC41OjEyLjM0LC4xOjE5LjgxLC4wNToyMi4zNiwuMDI1OjI0Ljc0LC4wMToyNy42OSwuMDA1OjI5LjgyfSwxNDp7Ljk5NTo0LjA3LC45OTo0LjY2LC45NzU6NS42MywuOTU6Ni41NywuOTo3Ljc5LC41OjEzLjM0LC4xOjIxLjA2LC4wNToyMy42OCwuMDI1OjI2LjEyLC4wMToyOS4xNCwuMDA1OjMxLjMyfSwxNTp7Ljk5NTo0LjYsLjk5OjUuMjMsLjk3NTo2LjI3LC45NTo3LjI2LC45OjguNTUsLjU6MTQuMzQsLjE6MjIuMzEsLjA1OjI1LC4wMjU6MjcuNDksLjAxOjMwLjU4LC4wMDU6MzIuOH0sMTY6ey45OTU6NS4xNCwuOTk6NS44MSwuOTc1OjYuOTEsLjk1OjcuOTYsLjk6OS4zMSwuNToxNS4zNCwuMToyMy41NCwuMDU6MjYuMywuMDI1OjI4Ljg1LC4wMTozMiwuMDA1OjM0LjI3fSwxNzp7Ljk5NTo1LjcsLjk5OjYuNDEsLjk3NTo3LjU2LC45NTo4LjY3LC45OjEwLjA5LC41OjE2LjM0LC4xOjI0Ljc3LC4wNToyNy41OSwuMDI1OjMwLjE5LC4wMTozMy40MSwuMDA1OjM1LjcyfSwxODp7Ljk5NTo2LjI2LC45OTo3LjAxLC45NzU6OC4yMywuOTU6OS4zOSwuOToxMC44NywuNToxNy4zNCwuMToyNS45OSwuMDU6MjguODcsLjAyNTozMS41MywuMDE6MzQuODEsLjAwNTozNy4xNn0sMTk6ey45OTU6Ni44NCwuOTk6Ny42MywuOTc1OjguOTEsLjk1OjEwLjEyLC45OjExLjY1LC41OjE4LjM0LC4xOjI3LjIsLjA1OjMwLjE0LC4wMjU6MzIuODUsLjAxOjM2LjE5LC4wMDU6MzguNTh9LDIwOnsuOTk1OjcuNDMsLjk5OjguMjYsLjk3NTo5LjU5LC45NToxMC44NSwuOToxMi40NCwuNToxOS4zNCwuMToyOC40MSwuMDU6MzEuNDEsLjAyNTozNC4xNywuMDE6MzcuNTcsLjAwNTo0MH0sMjE6ey45OTU6OC4wMywuOTk6OC45LC45NzU6MTAuMjgsLjk1OjExLjU5LC45OjEzLjI0LC41OjIwLjM0LC4xOjI5LjYyLC4wNTozMi42NywuMDI1OjM1LjQ4LC4wMTozOC45MywuMDA1OjQxLjR9LDIyOnsuOTk1OjguNjQsLjk5OjkuNTQsLjk3NToxMC45OCwuOTU6MTIuMzQsLjk6MTQuMDQsLjU6MjEuMzQsLjE6MzAuODEsLjA1OjMzLjkyLC4wMjU6MzYuNzgsLjAxOjQwLjI5LC4wMDU6NDIuOH0sMjM6ey45OTU6OS4yNiwuOTk6MTAuMiwuOTc1OjExLjY5LC45NToxMy4wOSwuOToxNC44NSwuNToyMi4zNCwuMTozMi4wMSwuMDU6MzUuMTcsLjAyNTozOC4wOCwuMDE6NDEuNjQsLjAwNTo0NC4xOH0sMjQ6ey45OTU6OS44OSwuOTk6MTAuODYsLjk3NToxMi40LC45NToxMy44NSwuOToxNS42NiwuNToyMy4zNCwuMTozMy4yLC4wNTozNi40MiwuMDI1OjM5LjM2LC4wMTo0Mi45OCwuMDA1OjQ1LjU2fSwyNTp7Ljk5NToxMC41MiwuOTk6MTEuNTIsLjk3NToxMy4xMiwuOTU6MTQuNjEsLjk6MTYuNDcsLjU6MjQuMzQsLjE6MzQuMjgsLjA1OjM3LjY1LC4wMjU6NDAuNjUsLjAxOjQ0LjMxLC4wMDU6NDYuOTN9LDI2OnsuOTk1OjExLjE2LC45OToxMi4yLC45NzU6MTMuODQsLjk1OjE1LjM4LC45OjE3LjI5LC41OjI1LjM0LC4xOjM1LjU2LC4wNTozOC44OSwuMDI1OjQxLjkyLC4wMTo0NS42NCwuMDA1OjQ4LjI5fSwyNzp7Ljk5NToxMS44MSwuOTk6MTIuODgsLjk3NToxNC41NywuOTU6MTYuMTUsLjk6MTguMTEsLjU6MjYuMzQsLjE6MzYuNzQsLjA1OjQwLjExLC4wMjU6NDMuMTksLjAxOjQ2Ljk2LC4wMDU6NDkuNjV9LDI4OnsuOTk1OjEyLjQ2LC45OToxMy41NywuOTc1OjE1LjMxLC45NToxNi45MywuOToxOC45NCwuNToyNy4zNCwuMTozNy45MiwuMDU6NDEuMzQsLjAyNTo0NC40NiwuMDE6NDguMjgsLjAwNTo1MC45OX0sMjk6ey45OTU6MTMuMTIsLjk5OjE0LjI2LC45NzU6MTYuMDUsLjk1OjE3LjcxLC45OjE5Ljc3LC41OjI4LjM0LC4xOjM5LjA5LC4wNTo0Mi41NiwuMDI1OjQ1LjcyLC4wMTo0OS41OSwuMDA1OjUyLjM0fSwzMDp7Ljk5NToxMy43OSwuOTk6MTQuOTUsLjk3NToxNi43OSwuOTU6MTguNDksLjk6MjAuNiwuNToyOS4zNCwuMTo0MC4yNiwuMDU6NDMuNzcsLjAyNTo0Ni45OCwuMDE6NTAuODksLjAwNTo1My42N30sNDA6ey45OTU6MjAuNzEsLjk5OjIyLjE2LC45NzU6MjQuNDMsLjk1OjI2LjUxLC45OjI5LjA1LC41OjM5LjM0LC4xOjUxLjgxLC4wNTo1NS43NiwuMDI1OjU5LjM0LC4wMTo2My42OSwuMDA1OjY2Ljc3fSw1MDp7Ljk5NToyNy45OSwuOTk6MjkuNzEsLjk3NTozMi4zNiwuOTU6MzQuNzYsLjk6MzcuNjksLjU6NDkuMzMsLjE6NjMuMTcsLjA1OjY3LjUsLjAyNTo3MS40MiwuMDE6NzYuMTUsLjAwNTo3OS40OX0sNjA6ey45OTU6MzUuNTMsLjk5OjM3LjQ4LC45NzU6NDAuNDgsLjk1OjQzLjE5LC45OjQ2LjQ2LC41OjU5LjMzLC4xOjc0LjQsLjA1Ojc5LjA4LC4wMjU6ODMuMywuMDE6ODguMzgsLjAwNTo5MS45NX0sNzA6ey45OTU6NDMuMjgsLjk5OjQ1LjQ0LC45NzU6NDguNzYsLjk1OjUxLjc0LC45OjU1LjMzLC41OjY5LjMzLC4xOjg1LjUzLC4wNTo5MC41MywuMDI1Ojk1LjAyLC4wMToxMDAuNDIsLjAwNToxMDQuMjJ9LDgwOnsuOTk1OjUxLjE3LC45OTo1My41NCwuOTc1OjU3LjE1LC45NTo2MC4zOSwuOTo2NC4yOCwuNTo3OS4zMywuMTo5Ni41OCwuMDU6MTAxLjg4LC4wMjU6MTA2LjYzLC4wMToxMTIuMzMsLjAwNToxMTYuMzJ9LDkwOnsuOTk1OjU5LjIsLjk5OjYxLjc1LC45NzU6NjUuNjUsLjk1OjY5LjEzLC45OjczLjI5LC41Ojg5LjMzLC4xOjEwNy41NywuMDU6MTEzLjE0LC4wMjU6MTE4LjE0LC4wMToxMjQuMTIsLjAwNToxMjguM30sMTAwOnsuOTk1OjY3LjMzLC45OTo3MC4wNiwuOTc1Ojc0LjIyLC45NTo3Ny45MywuOTo4Mi4zNiwuNTo5OS4zMywuMToxMTguNSwuMDU6MTI0LjM0LC4wMjU6MTI5LjU2LC4wMToxMzUuODEsLjAwNToxNDAuMTd9fTtmdW5jdGlvbiBicihyLHQsbil7Zm9yKHZhciBvPTAsYT10KGUocikpLGg9W10sZj1bXSx1PTA7dTxyLmxlbmd0aDt1Kyspdm9pZCAwPT09aFtyW3VdXSYmKGhbclt1XV09MCksaFtyW3VdXSsrO2Zvcih2YXIgaT0wO2k8aC5sZW5ndGg7aSsrKXZvaWQgMD09PWhbaV0mJihoW2ldPTApO2Zvcih2YXIgbCBpbiBhKWwgaW4gaCYmKGZbK2xdPWFbbF0qci5sZW5ndGgpO2Zvcih2YXIgZz1mLmxlbmd0aC0xO2c+PTA7Zy0tKWZbZ108MyYmKGZbZy0xXSs9ZltnXSxmLnBvcCgpLGhbZy0xXSs9aFtnXSxoLnBvcCgpKTtmb3IodmFyIHY9MDt2PGgubGVuZ3RoO3YrKylvKz1NYXRoLnBvdyhoW3ZdLWZbdl0sMikvZlt2XTtyZXR1cm4geXJbaC5sZW5ndGgtMS0xXVtuXTxvfXZhciBkcj1NYXRoLnNxcnQoMipNYXRoLlBJKSxJcj17Z2F1c3NpYW46ZnVuY3Rpb24ocil7cmV0dXJuIE1hdGguZXhwKC0uNSpyKnIpL2RyfX0sUHI9e25yZDpmdW5jdGlvbihyKXt2YXIgdD1PKHIpLG49eihyKTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgbiYmKHQ9TWF0aC5taW4odCxuLzEuMzQpKSwxLjA2KnQqTWF0aC5wb3coci5sZW5ndGgsLS4yKX19O2Z1bmN0aW9uIENyKHIsdCxuKXt2YXIgZSxvO2lmKHZvaWQgMD09PXQpZT1Jci5nYXVzc2lhbjtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtpZighSXJbdF0pdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGtlcm5lbCBcIicrdCsnXCInKTtlPUlyW3RdfWVsc2UgZT10O2lmKHZvaWQgMD09PW4pbz1Qci5ucmQocik7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2Ygbil7aWYoIVByW25dKXRocm93IG5ldyBFcnJvcignVW5rbm93biBiYW5kd2lkdGggbWV0aG9kIFwiJytuKydcIicpO289UHJbbl0ocil9ZWxzZSBvPW47cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPTAsYT0wO2ZvcihuPTA7bjxyLmxlbmd0aDtuKyspYSs9ZSgodC1yW25dKS9vKTtyZXR1cm4gYS9vL3IubGVuZ3RofX1mdW5jdGlvbiBOcihyLHQsbil7cmV0dXJuKHItdCkvbn12YXIgX3I9TWF0aC5zcXJ0KDIqTWF0aC5QSSk7ZnVuY3Rpb24gQXIocil7Zm9yKHZhciB0PXIsbj1yLGU9MTtlPDE1O2UrKyl0Kz1uKj1yKnIvKDIqZSsxKTtyZXR1cm4gTWF0aC5yb3VuZCgxZTQqKC41K3QvX3IqTWF0aC5leHAoLXIqci8yKSkpLzFlNH1mb3IodmFyIHpyPVtdLFVyPTA7VXI8PTMuMDk7VXIrPS4wMSl6ci5wdXNoKEFyKFVyKSk7ZnVuY3Rpb24gS3Iocil7dmFyIHQ9TWF0aC5hYnMociksbj1NYXRoLm1pbihNYXRoLnJvdW5kKDEwMCp0KSx6ci5sZW5ndGgtMSk7cmV0dXJuIHI+PTA/enJbbl06KygxLXpyW25dKS50b0ZpeGVkKDQpfWZ1bmN0aW9uIEJyKHIpe3ZhciB0PTEvKDErLjUqTWF0aC5hYnMocikpLG49dCpNYXRoLmV4cCgtTWF0aC5wb3cociwyKS0xLjI2NTUxMjIzKzEuMDAwMDIzNjgqdCsuMzc0MDkxOTYqTWF0aC5wb3codCwyKSsuMDk2Nzg0MTgqTWF0aC5wb3codCwzKS0uMTg2Mjg4MDYqTWF0aC5wb3codCw0KSsuMjc4ODY4MDcqTWF0aC5wb3codCw1KS0xLjEzNTIwMzk4Kk1hdGgucG93KHQsNikrMS40ODg1MTU4NypNYXRoLnBvdyh0LDcpLS44MjIxNTIyMypNYXRoLnBvdyh0LDgpKy4xNzA4NzI3NypNYXRoLnBvdyh0LDkpKTtyZXR1cm4gcj49MD8xLW46bi0xfWZ1bmN0aW9uIEdyKHIpe3ZhciB0PTgqKE1hdGguUEktMykvKDMqTWF0aC5QSSooNC1NYXRoLlBJKSksbj1NYXRoLnNxcnQoTWF0aC5zcXJ0KE1hdGgucG93KDIvKE1hdGguUEkqdCkrTWF0aC5sb2coMS1yKnIpLzIsMiktTWF0aC5sb2coMS1yKnIpL3QpLSgyLyhNYXRoLlBJKnQpK01hdGgubG9nKDEtcipyKS8yKSk7cmV0dXJuIHI+PTA/bjotbn1mdW5jdGlvbiBIcihyKXtyZXR1cm4gMD09PXI/cj1scjpyPj0xJiYocj0xLWxyKSxNYXRoLnNxcnQoMikqR3IoMipyLTEpfWZ1bmN0aW9uIEpyKHIsdCxuLG8pe2lmKHZvaWQgMD09PW8mJihvPTFlNCksdm9pZCAwPT09biYmKG49XCJ0d29fc2lkZVwiKSxcInR3b19zaWRlXCIhPT1uJiZcImdyZWF0ZXJcIiE9PW4mJlwibGVzc1wiIT09bil0aHJvdyBuZXcgRXJyb3IoXCJgYWx0ZXJuYXRpdmVgIG11c3QgYmUgZWl0aGVyICd0d29fc2lkZScsICdncmVhdGVyJywgb3IgJ2xlc3MnXCIpO2Zvcih2YXIgYT1lKHIpLWUodCksaD1uZXcgQXJyYXkobyksZj1yLmNvbmNhdCh0KSx1PU1hdGguZmxvb3IoZi5sZW5ndGgvMiksaT0wO2k8bztpKyspe0goZik7dmFyIGw9Zi5zbGljZSgwLHUpLGc9Zi5zbGljZSh1LGYubGVuZ3RoKSx2PWUobCktZShnKTtoW2ldPXZ9dmFyIGM9MDtpZihcInR3b19zaWRlXCI9PT1uKWZvcih2YXIgcz0wO3M8PW87cysrKU1hdGguYWJzKGhbc10pPj1NYXRoLmFicyhhKSYmKGMrPTEpO2Vsc2UgaWYoXCJncmVhdGVyXCI9PT1uKWZvcih2YXIgcD0wO3A8PW87cCsrKWhbcF0+PWEmJihjKz0xKTtlbHNlIGZvcih2YXIgTT0wO008PW87TSsrKWhbTV08PWEmJihjKz0xKTtyZXR1cm4gYy9vfWZ1bmN0aW9uIFFyKHIpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiByKXJldHVybiByPDA/LTE6MD09PXI/MDoxO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSBudW1iZXJcIil9ZnVuY3Rpb24gUnIocix0LG4sZSxvKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoXCJmdW5jIG11c3QgYmUgYSBmdW5jdGlvblwiKTtmb3IodmFyIGE9MDthPGU7YSsrKXt2YXIgaD0odCtuKS8yO2lmKDA9PT1yKGgpfHxNYXRoLmFicygobi10KS8yKTxvKXJldHVybiBoO1FyKHIoaCkpPT09UXIocih0KSk/dD1oOm49aH10aHJvdyBuZXcgRXJyb3IoXCJtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIGV4Y2VlZGVkXCIpfWV4cG9ydHtyIGFzIGxpbmVhclJlZ3Jlc3Npb24sdCBhcyBsaW5lYXJSZWdyZXNzaW9uTGluZSxoIGFzIHN0YW5kYXJkRGV2aWF0aW9uLGYgYXMgclNxdWFyZWQsbCBhcyBtb2RlLGcgYXMgbW9kZUZhc3QsdSBhcyBtb2RlU29ydGVkLHYgYXMgbWluLGMgYXMgbWF4LHMgYXMgZXh0ZW50LHAgYXMgbWluU29ydGVkLE0gYXMgbWF4U29ydGVkLHcgYXMgZXh0ZW50U29ydGVkLG4gYXMgc3VtLHEgYXMgc3VtU2ltcGxlLEUgYXMgcHJvZHVjdCxJIGFzIHF1YW50aWxlLHkgYXMgcXVhbnRpbGVTb3J0ZWQsQSBhcyBxdWFudGlsZVJhbmssXyBhcyBxdWFudGlsZVJhbmtTb3J0ZWQseiBhcyBpbnRlcnF1YXJ0aWxlUmFuZ2UseiBhcyBpcXIsSyBhcyBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbixLIGFzIG1hZCxCIGFzIGNodW5rLEcgYXMgc2FtcGxlV2l0aFJlcGxhY2VtZW50LEogYXMgc2h1ZmZsZSxIIGFzIHNodWZmbGVJblBsYWNlLFEgYXMgc2FtcGxlLHggYXMgY2ttZWFucyxSIGFzIHVuaXF1ZUNvdW50U29ydGVkLG8gYXMgc3VtTnRoUG93ZXJEZXZpYXRpb25zLFQgYXMgZXF1YWxJbnRlcnZhbEJyZWFrcyxEIGFzIHNhbXBsZUNvdmFyaWFuY2UsWCBhcyBzYW1wbGVDb3JyZWxhdGlvbixMIGFzIHNhbXBsZVZhcmlhbmNlLE8gYXMgc2FtcGxlU3RhbmRhcmREZXZpYXRpb24sViBhcyBzYW1wbGVTa2V3bmVzcyxtIGFzIHNhbXBsZUt1cnRvc2lzLEYgYXMgcGVybXV0YXRpb25zSGVhcCxrIGFzIGNvbWJpbmF0aW9ucyxTIGFzIGNvbWJpbmF0aW9uc1JlcGxhY2VtZW50LGogYXMgYWRkVG9NZWFuLCQgYXMgY29tYmluZU1lYW5zLHJyIGFzIGNvbWJpbmVWYXJpYW5jZXMsdHIgYXMgZ2VvbWV0cmljTWVhbixuciBhcyBoYXJtb25pY01lYW4sZSBhcyBhdmVyYWdlLGUgYXMgbWVhbixVIGFzIG1lZGlhbixlciBhcyBtZWRpYW5Tb3J0ZWQsb3IgYXMgc3VidHJhY3RGcm9tTWVhbixhciBhcyByb290TWVhblNxdWFyZSxhciBhcyBybXMsYSBhcyB2YXJpYW5jZSxociBhcyB0VGVzdCxmciBhcyB0VGVzdFR3b1NhbXBsZSx1ciBhcyBCYXllc2lhbkNsYXNzaWZpZXIsdXIgYXMgYmF5ZXNpYW4saXIgYXMgUGVyY2VwdHJvbk1vZGVsLGlyIGFzIHBlcmNlcHRyb24sbHIgYXMgZXBzaWxvbixnciBhcyBmYWN0b3JpYWwsdnIgYXMgZ2FtbWEsTXIgYXMgZ2FtbWFsbix3ciBhcyBiZXJub3VsbGlEaXN0cmlidXRpb24scXIgYXMgYmlub21pYWxEaXN0cmlidXRpb24sRXIgYXMgcG9pc3NvbkRpc3RyaWJ1dGlvbix5ciBhcyBjaGlTcXVhcmVkRGlzdHJpYnV0aW9uVGFibGUsYnIgYXMgY2hpU3F1YXJlZEdvb2RuZXNzT2ZGaXQsQ3IgYXMga2VybmVsRGVuc2l0eUVzdGltYXRpb24sQ3IgYXMga2RlLE5yIGFzIHpTY29yZSxLciBhcyBjdW11bGF0aXZlU3RkTm9ybWFsUHJvYmFiaWxpdHksenIgYXMgc3RhbmRhcmROb3JtYWxUYWJsZSxCciBhcyBlcnJvckZ1bmN0aW9uLEJyIGFzIGVyZixHciBhcyBpbnZlcnNlRXJyb3JGdW5jdGlvbixIciBhcyBwcm9iaXQsSnIgYXMgcGVybXV0YXRpb25UZXN0LFJyIGFzIGJpc2VjdCxiIGFzIHF1aWNrc2VsZWN0LFFyIGFzIHNpZ24saSBhcyBudW1lcmljU29ydH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtc3RhdGlzdGljcy5tanMubWFwXG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcbmltcG9ydCB7cXVhbnRpbGV9IGZyb20gJ3NpbXBsZS1zdGF0aXN0aWNzJztcbmltcG9ydCB7cG9pbnRFeGlzdHMsIGNyZWF0ZUdyYXBoLCBtc3QsIGdldEFsbFYyT3JHcmVhdGVyRnJvbVRyZWV9IGZyb20gXCIuL2tydXNrYWwtbXN0XCI7XG5cbi8qKlxuICogb3B0aW9ucyBtYXkgY29udGFpbiB1cHBlckJvdW5kLCBvdXRseWluZ0NvZWZmaWNpZW50ICgxLjUgb3IgMy4wKSwgYW5kIHdlaWdodHMgKGRpZmZlcmVudCB2YXJpYWJsZXMgbWF5IGhhdmUgZGlmZmVyZW50IHdlaWdodHMpXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRseWluZyB7XG4gICAgY29uc3RydWN0b3IodHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB1cHBlckJvdW5kID0gb3B0aW9ucy51cHBlckJvdW5kO1xuICAgICAgICBsZXQgb3V0bHlpbmdDb2VmZmljaWVudCA9IG9wdGlvbnMub3V0bHlpbmdDb2VmZmljaWVudDtcbiAgICAgICAgbGV0IHdlaWdodHMgPSBvcHRpb25zLndlaWdodHM7XG4gICAgICAgIC8vQ2xvbmUgdGhlIHRyZWUgdG8gYXZvaWQgbW9kaWZ5aW5nIGl0XG4gICAgICAgIHRoaXMudHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQgPSB1cHBlckJvdW5kO1xuICAgICAgICB0aGlzLm91dGx5aW5nQ29lZmZpY2llbnQgPSBvdXRseWluZ0NvZWZmaWNpZW50ID8gb3V0bHlpbmdDb2VmZmljaWVudCA6IDEuNTtcbiAgICAgICAgLy9DYWxjdWxhdGUgdGhlIHVwcGVyIGJvdW5kIGlmIGl0IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgICAgaWYgKCF1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB1cHBlckJvdW5kID0gZmluZFVwcGVyQm91bmQodGhpcy50cmVlLCBvdXRseWluZ0NvZWZmaWNpZW50KTtcbiAgICAgICAgICAgIC8vU2F2ZSBpdCBmb3IgZGlzcGxheWluZyBwdXJwb3NlLlxuICAgICAgICAgICAgdGhpcy51cHBlckJvdW5kID0gdXBwZXJCb3VuZDtcbiAgICAgICAgfVxuICAgICAgICAvL01hcmsgdGhlIGxvbmcgbGlua3NcbiAgICAgICAgbWFya0xvbmdMaW5rcyh0aGlzLnRyZWUsIHVwcGVyQm91bmQpO1xuICAgICAgICAvL0ZpbmRpbmcgbm9ybWFsIG5vZGVzXG4gICAgICAgIGxldCBub3JtYWxOb2RlcyA9IGZpbmROb3JtYWxOb2Rlcyh0aGlzLnRyZWUpO1xuICAgICAgICAvL0ZpbmRpbmcgb3V0bHlpbmcgcG9pbnRzXG4gICAgICAgIHRoaXMub3V0bHlpbmdQb2ludHMgPSBmaW5kT3V0bHlpbmdQb2ludHModGhpcy50cmVlLCBub3JtYWxOb2Rlcyk7XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZE91dGx5aW5nUG9pbnRzKHRyZWUsIG5vcm1hbE5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZXMgPSBub3JtYWxOb2RlcztcbiAgICAgICAgICAgIGxldCBvbGROb2RlcyA9IHRyZWUubm9kZXM7XG4gICAgICAgICAgICAvL0dldCB0aGUgb3V0bHlpbmcgcG9pbnRzXG4gICAgICAgICAgICBsZXQgb3BzID0gW107XG4gICAgICAgICAgICBvbGROb2Rlcy5mb3JFYWNoKG9uID0+IHtcbiAgICAgICAgICAgICAgICAvLy5pZCBzaW5jZSB3ZSBhcmUgYWNjZXNzaW5nIHRvIHBvaW50cyBhbmQgdGhlIG5vZGUgaXMgaW4gZm9ybSBvZiB7aWQ6IHRoZVBvaW50fVxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRFeGlzdHMobmV3Tm9kZXMubWFwKG5uID0+IG5uLmlkKSwgb24uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wcy5wdXNoKG9uLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcHM7XG4gICAgICAgIH1cblxuICAgICAgICAvL05vdyBtYXJrIHRoZSBvdXRseWluZyBsaW5rc1xuICAgICAgICBtYXJrT3V0bHlpbmdMaW5rcyh0aGlzLnRyZWUsIHRoaXMub3V0bHlpbmdQb2ludHMpO1xuXG4gICAgICAgIC8vQ3JlYXRlIG5vbmUgb3V0bHlpbmcgdHJlZVxuICAgICAgICB0aGlzLm5vT3V0bHlpbmdUcmVlID0gYnVpbGROb091dGx5aW5nVHJlZSh0aGlzLnRyZWUsIHRoaXMub3V0bHlpbmdQb2ludHMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTm9PdXRseWluZ1RyZWUodHJlZSwgb3V0bHlpbmdQb2ludHMpIHtcbiAgICAgICAgICAgIGxldCBub091dGx5aW5nVHJlZSA9IHt9O1xuICAgICAgICAgICAgbm9PdXRseWluZ1RyZWUubm9kZXMgPSBub3JtYWxOb2RlcztcbiAgICAgICAgICAgIG5vT3V0bHlpbmdUcmVlLmxpbmtzID0gdHJlZS5saW5rcy5maWx0ZXIobCA9PiBsLmlzT3V0bHlpbmcgIT09IHRydWUpXG4gICAgICAgICAgICAvL0lmIHRoZSBvdXRseWluZyBub2RlcyBoYXMgdGhlIGRlZ3JlZSBvZiAyIG9yIGdyZWF0ZXIgPT4gaXQgd2lsbCBicmVhayB0aGUgdHJlZSBpbnRvIHN1YnRyZWVzID0+IHNvIHdlIG5lZWQgdG8gcmVidWlsZCB0aGUgdHJlZS5cbiAgICAgICAgICAgIC8vVGFrZSB0aGUgb3V0bHlpbmcgcG9pbnRzXG4gICAgICAgICAgICBsZXQgb3V0bHlpbmdQb2ludHNTdHIgPSBvdXRseWluZ1BvaW50cy5tYXAocCA9PiBwLmpvaW4oJywnKSk7XG4gICAgICAgICAgICBsZXQgdjJPckdyZWF0ZXJTdHIgPSBnZXRBbGxWMk9yR3JlYXRlckZyb21UcmVlKHRyZWUpLm1hcChwID0+IHAuam9pbignLCcpKTtcblxuICAgICAgICAgICAgbGV0IGRpZmYgPSBfLmRpZmZlcmVuY2Uob3V0bHlpbmdQb2ludHNTdHIsIHYyT3JHcmVhdGVyU3RyKTtcbiAgICAgICAgICAgIGlmIChkaWZmLmxlbmd0aCA8IG91dGx5aW5nUG9pbnRzU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vTWVhbnMgdGhlcmUgaXMgb3V0bHlpbmcgbm9kZShzKSB3aXRoIGRlZ3JlZSAyIG9yIGhpZ2hlciAoc28gd2Ugc2hvdWxkIHJlYnVpbGQgdGhlIHRyZWUpXG4gICAgICAgICAgICAgICAgbGV0IGdyYXBoID0gY3JlYXRlR3JhcGgobm9PdXRseWluZ1RyZWUubm9kZXMubWFwKG4gPT4gbi5pZCksIHdlaWdodHMpXG4gICAgICAgICAgICAgICAgbm9PdXRseWluZ1RyZWUgPSBtc3QoZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vT3V0bHlpbmdUcmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZE5vcm1hbE5vZGVzKHRyZWUpIHtcbiAgICAgICAgICAgIC8vUmVtb3ZlIGxvbmcgbGlua3NcbiAgICAgICAgICAgIGxldCBub3JtYWxMaW5rcyA9IHRyZWUubGlua3MuZmlsdGVyKGwgPT4gIWwuaXNMb25nKTtcbiAgICAgICAgICAgIC8vUmVtb3ZlIG91dGx5aW5nIG5vZGVzIChub2RlcyBhcmUgbm90IGluIGFueSBub25lLWxvbmcgbGlua3MpXG4gICAgICAgICAgICBsZXQgYWxsTm9kZXNXaXRoTGlua3MgPSBbXTtcbiAgICAgICAgICAgIG5vcm1hbExpbmtzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNXaXRoTGlua3MucHVzaChsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNXaXRoTGlua3MucHVzaChsLnRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFsbE5vZGVzV2l0aExpbmtzID0gXy51bmlxKGFsbE5vZGVzV2l0aExpbmtzLCBmYWxzZSwgZCA9PiBkLmpvaW4oJywnKSk7XG4gICAgICAgICAgICBsZXQgbm9ybWFsTm9kZXMgPSBhbGxOb2Rlc1dpdGhMaW5rcy5tYXAobiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtpZDogbn07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxOb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcmtMb25nTGlua3ModHJlZSwgdXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdHJlZS5saW5rcy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsLndlaWdodCA+IHVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbC5pc0xvbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZFVwcGVyQm91bmQodHJlZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgICAgIGxldCBhbGxMZW5ndGhzID0gdHJlZS5saW5rcy5tYXAobCA9PiBsLndlaWdodCksXG4gICAgICAgICAgICAgICAgcTEgPSBxdWFudGlsZShhbGxMZW5ndGhzLCAwLjI1KSxcbiAgICAgICAgICAgICAgICBxMyA9IHF1YW50aWxlKGFsbExlbmd0aHMsIDAuNzUpLFxuICAgICAgICAgICAgICAgIGlxciA9IHEzIC0gcTEsXG4gICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IHEzICsgY29lZmZpY2llbnQgKiBpcXI7XG4gICAgICAgICAgICByZXR1cm4gdXBwZXJCb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcmtPdXRseWluZ0xpbmtzKHRyZWUsIG91dGx5aW5nUG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAob3V0bHlpbmdQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vQ2hlY2sgdGhlIGxvbmcgbGlua3Mgb25seVxuICAgICAgICAgICAgICAgIHRyZWUubGlua3MuZmlsdGVyKGwgPT4gbC5pc0xvbmcpLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vQWxzbyBjaGVjayBpZiB0aGUgbGluayBjb250YWlucyBvdXRseWluZyBwb2ludHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEV4aXN0cyhvdXRseWluZ1BvaW50cywgbC5zb3VyY2UpIHx8IHBvaW50RXhpc3RzKG91dGx5aW5nUG9pbnRzLCBsLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwuaXNPdXRseWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb3V0bHlpbmcgc2NvcmVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjb3JlKCkge1xuICAgICAgICBsZXQgdG90YWxMZW5ndGhzID0gMDtcbiAgICAgICAgbGV0IHRvdGFsT3V0bHlpbmdMZW5ndGhzID0gMDtcbiAgICAgICAgdGhpcy50cmVlLmxpbmtzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aHMgKz0gbC53ZWlnaHQ7XG4gICAgICAgICAgICAvL0lmIHRoZXJlIGFyZSBvdXRseWluZyBwb2ludHMgZmlyc3QuXG4gICAgICAgICAgICBpZiAobC5pc091dGx5aW5nKSB7XG4gICAgICAgICAgICAgICAgdG90YWxPdXRseWluZ0xlbmd0aHMgKz0gbC53ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG90YWxPdXRseWluZ0xlbmd0aHMgLyB0b3RhbExlbmd0aHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvdXRseWluZyBsaW5rc1xuICAgICAqL1xuICAgIGxpbmtzKCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0bHlpbmdMaW5rcykge1xuICAgICAgICAgICAgdGhpcy5vdXRseWluZ0xpbmtzID0gdGhpcy50cmVlLmxpbmtzLmZpbHRlcihsID0+IGwuaXNPdXRseWluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bHlpbmdMaW5rcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgb3V0bHlpbmcgbGlua3MgYW5kIG5vZGVzIGFuZCByZXR1cm4gYSBuZXcgdHJlZSB3aXRob3V0IG91dGx5aW5nIHBvaW50cy9lZGdlc1xuICAgICAqL1xuICAgIHJlbW92ZU91dGx5aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub091dGx5aW5nVHJlZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdXRseWluZyBwb2ludHMgKGluIGZvcm0gb2YgcG9pbnRzLCBub3Qgbm9kZSBvYmplY3QpLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBwb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGx5aW5nUG9pbnRzO1xuICAgIH1cbn0iLCJpbXBvcnQge05vcm1hbGl6ZXJ9IGZyb20gXCIuL21vZHVsZXMvbm9ybWFsaXplclwiO1xuaW1wb3J0IHtMZWFkZXJCaW5uZXJ9IGZyb20gXCIuL21vZHVsZXMvbGVhZGVyQmlubmVyXCI7XG5pbXBvcnQge199IGZyb20gJ3VuZGVyc2NvcmUnXG5pbXBvcnQge2NyZWF0ZUdyYXBoLCBtc3QsIGVxdWFsUG9pbnRzfSBmcm9tIFwiLi9tb2R1bGVzL2tydXNrYWwtbXN0XCI7XG5pbXBvcnQge091dGx5aW5nfSBmcm9tIFwiLi9tb2R1bGVzL291dGx5aW5nXCI7XG5pbXBvcnQge1NrZXdlZH0gZnJvbSBcIi4vbW9kdWxlcy9za2V3ZWRcIjtcbmltcG9ydCB7U3BhcnNlfSBmcm9tIFwiLi9tb2R1bGVzL3NwYXJzZVwiO1xuaW1wb3J0IHtDbHVtcHl9IGZyb20gXCIuL21vZHVsZXMvY2x1bXB5XCI7XG4vLyBpbXBvcnQge1N0cmlhdGVkfSBmcm9tIFwiLi9tb2R1bGVzL3N0cmlhdGVkXCI7XG4vLyBpbXBvcnQge0NvbnZleH0gZnJvbSBcIi4vbW9kdWxlcy9jb252ZXhcIjtcbi8vIGltcG9ydCB7U2tpbm55fSBmcm9tIFwiLi9tb2R1bGVzL3NraW5ueVwiO1xuaW1wb3J0IHtTdHJpbmd5fSBmcm9tIFwiLi9tb2R1bGVzL3N0cmluZ3lcIjtcbmltcG9ydCB7TW9ub3RvbmljfSBmcm9tIFwiLi9tb2R1bGVzL21vbm90b25pY1wiO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuKGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIGEgb3V0bGlhZ25vc3RpY3NuZCBvYmplY3RcbiAgICAgKiBAcGFyYW0gaW5wdXRQb2ludHMgICB7KltdW119IHNldCBvZiBwb2ludHMgZnJvbSB0aGUgc2NhdHRlciBwbG90XG4gICAgICogQHJldHVybnMgeypbXVtdfVxuICAgICAqL1xuICAgIHdpbmRvdy5vdXRsaWFnbm9zdGljc25kID0gZnVuY3Rpb24gKGlucHV0UG9pbnRzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQgZGltcyA9IGlucHV0UG9pbnRzWzBdLmxlbmd0aDtcbiAgICAgICAgLy9DbG9uZSBpdCB0byBhdm9pZCBtb2RpZnlpbmcgaXQuXG4gICAgICAgIGxldCBwb2ludHMgPSBpbnB1dFBvaW50cy5tYXAoZSA9PiBlLnNsaWNlKCkpO1xuICAgICAgICAvL0FkZCBvbmUgc3RlcCB0byBwYXNzIHRoZSBkYXRhIG92ZXIgaWYgdGhlcmUgaXMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0uZGF0YSA9IGlucHV0UG9pbnRzW2ldLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQb2ludHMgPSBwb2ludHM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNOb3JtYWxpemVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVyID0gbmV3IE5vcm1hbGl6ZXIocG9pbnRzKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQb2ludHMgPSBub3JtYWxpemVyLm5vcm1hbGl6ZWRQb2ludHM7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZShcIm5vcm1hbGl6ZWRQb2ludHNcIiwgbm9ybWFsaXplZFBvaW50cyk7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZShcIm5vcm1hbGl6ZXJcIiwgbm9ybWFsaXplcik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYmluVHlwZSA9IG9wdGlvbnMuYmluVHlwZTtcbiAgICAgICAgLyoqKioqKlRoaXMgc2VjdGlvbiBpc291YXNkdGx5IGFib3V0IHRoZSBvdXRseWluZyBzY29yZSBhbmQgb3V0bHlpbmcgc2NvcmUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgbGV0IG91dGx5aW5nVXBwZXJCb3VuZCA9IG9wdGlvbnMub3V0bHlpbmdVcHBlckJvdW5kO1xuICAgICAgICBsZXQgb3V0bHlpbmdDb2VmZmljaWVudCA9IG9wdGlvbnMub3V0bHlpbmdDb2VmZmljaWVudDtcblxuICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IGZpbmRpbmcgbnVtYmVyIG9mIGJpbnMgYW5kIGJpbm5lcnMqKioqKiovXG4gICAgICAgIGxldCBzaXRlcyA9IG51bGw7XG4gICAgICAgIGxldCBiaW5zID0gbnVsbDtcbiAgICAgICAgbGV0IGJpbm5lciA9IG51bGw7XG4gICAgICAgIGxldCBiaW5TaXplID0gbnVsbDtcbiAgICAgICAgbGV0IGJpblJhZGl1cyA9IDA7XG4gICAgICAgIGxldCBzdGFydEJpbkdyaWRTaXplID0gb3B0aW9ucy5zdGFydEJpbkdyaWRTaXplO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmlzQmlubmVkID09PSB1bmRlZmluZWQpIHsvL09ubHkgZG8gdGhlIGJpbm5pbmcgaWYgbmVlZGVkLlxuICAgICAgICAgICAgbGV0IGluY3JlbWVudEEgPSBvcHRpb25zLmluY3JlbWVudEEgPyBvcHRpb25zLmluY3JlbWVudEEgOiAyO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudEIgPSBvcHRpb25zLmluY3JlbWVudEIgPyBvcHRpb25zLmluY3JlbWVudEIgOiAwO1xuICAgICAgICAgICAgbGV0IGRlY3JlbWVudEEgPSBvcHRpb25zLmRlY3JlbWVudEEgPyBvcHRpb25zLmRlY3JlbWVudEEgOiAxIC8gMjtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRCID0gb3B0aW9ucy5kZWNyZW1lbnRCID8gb3B0aW9ucy5kZWNyZW1lbnRCIDogMDtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0QmluR3JpZFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmluR3JpZFNpemUgPSAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbnMgPSBbXTtcbiAgICAgICAgICAgIC8vRGVmYXVsdCBudW1iZXIgb2YgYmluc1xuICAgICAgICAgICAgbGV0IG1pbk51bU9mQmlucyA9IDMwO1xuICAgICAgICAgICAgbGV0IG1heE51bU9mQmlucyA9IDIwMDtcbiAgICAgICAgICAgIGxldCBtaW5CaW5zID0gb3B0aW9ucy5taW5CaW5zO1xuICAgICAgICAgICAgbGV0IG1heEJpbnMgPSBvcHRpb25zLm1heEJpbnM7XG4gICAgICAgICAgICBpZiAobWluQmlucykge1xuICAgICAgICAgICAgICAgIG1pbk51bU9mQmlucyA9IG1pbkJpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4Qmlucykge1xuICAgICAgICAgICAgICAgIG1heE51bU9mQmlucyA9IG1heEJpbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvL1N0YXJ0IHdpdGggYmluU2l6ZSB4IGJpblNpemUgeCBiaW5TaXplLi4uIGJpbnMsIGFuZCB0aGVuIGluY3JlYXNlIGl0IGFzIGJpblNpemUgPSBiaW5TaXplICogaW5jcmVtZW50QSArIGluY3JlbWVudEIgb3IgYmluU2l6ZSA9IGJpblNpemUgKiBkZWNyZW1lbnRBICsgZGVjcmVtZW50Qi5cbiAgICAgICAgICAgICAgICBpZiAoYmluU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5TaXplID0gc3RhcnRCaW5HcmlkU2l6ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJpbnMubGVuZ3RoID4gbWF4TnVtT2ZCaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpblNpemUgPSBiaW5TaXplICogZGVjcmVtZW50QSArIGRlY3JlbWVudEI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiaW5zLmxlbmd0aCA8IG1pbk51bU9mQmlucykge1xuICAgICAgICAgICAgICAgICAgICBiaW5TaXplID0gYmluU2l6ZSAqIGluY3JlbWVudEEgKyBpbmNyZW1lbnRCO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmluVHlwZSA9PT0gXCJoZXhhZ29uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLy8gVGhpcyBzZWN0aW9uIHVzZXMgaGV4YWdvbiBiaW5uaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBzaG9ydERpYWdvbmFsID0gMS9iaW5TaXplO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaW5SYWRpdXMgPSBNYXRoLnNxcnQoMykqc2hvcnREaWFnb25hbC8yO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaW5uZXIgPSBuZXcgQmlubmVyKCkucmFkaXVzKGJpblJhZGl1cykuZXh0ZW50KFtbMCwgMF0sIFsxLCAxXV0pOy8vZXh0ZW50IGZyb20gWzAsIDBdIHRvIFsxLCAxXSBzaW5jZSB3ZSBhbHJlYWR5IG5vcm1hbGl6ZWQgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgLy8gYmlucyA9IGJpbm5lci5oZXhiaW4obm9ybWFsaXplZFBvaW50cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYmluVHlwZSB8fCBiaW5UeXBlID09PSBcImxlYWRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VjdGlvbiB1c2VzIGxlYWRlciBiaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgYmluUmFkaXVzID0gTWF0aC5zcXJ0KGRpbXMgKiBNYXRoLnBvdygxIC8gKGJpblNpemUgKiAyKSwgMikpO1xuICAgICAgICAgICAgICAgICAgICBiaW5uZXIgPSBuZXcgTGVhZGVyQmlubmVyKG5vcm1hbGl6ZWRQb2ludHMsIGJpblJhZGl1cyk7XG4gICAgICAgICAgICAgICAgICAgIGJpbnMgPSBiaW5uZXIubGVhZGVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChiaW5zLmxlbmd0aCA+IG1heE51bU9mQmlucyB8fCBiaW5zLmxlbmd0aCA8IG1pbk51bU9mQmlucyk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBzaXRlcyA9IGJpbnMubWFwKGQgPT4gZC5zaXRlKTsgLy89PnNpdGVzIGFyZSB0aGUgc2V0IG9mIGNlbnRlcnMgb2YgYWxsIGJpbnNcbiAgICAgICAgICAgIC8qKioqKipUaGlzIHNlY3Rpb24gaXMgYWJvdXQgdGhlIGJpbm5pbmcgYW5kIGJpbm5pbmcgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgICAgIG91dHB1dFZhbHVlKFwiYmlubmVyXCIsIGJpbm5lcik7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZShcImJpbnNcIiwgYmlucyk7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZShcImJpblNpemVcIiwgYmluU2l6ZSk7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZShcImJpblJhZGl1c1wiLCBiaW5SYWRpdXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXRlcyA9IG5vcm1hbGl6ZWRQb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXRWYWx1ZShcImJpbm5lZFNpdGVzXCIsIHNpdGVzKTtcblxuICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IHRoZSBzcGFubmluZyB0cmVlIGFuZCBzcGFubmluZyB0cmVlIHJlc3VsdHMqKioqKiovXG4gICAgICAgICAgICAvL1NwYW5uaW5nIHRyZWUgY2FsY3VsYXRpb25cbiAgICAgICAgbGV0IHRldHJhaGVkcmFDb29yZGluYXRlcyA9IFtzaXRlc107XG4gICAgICAgIGxldCB3ZWlnaHRzID0gb3B0aW9ucy5kaXN0YW5jZVdlaWdodHM7XG4gICAgICAgIGxldCBncmFwaCA9IGNyZWF0ZUdyYXBoKHRldHJhaGVkcmFDb29yZGluYXRlcywgd2VpZ2h0cyk7XG4gICAgICAgIGxldCBtc3RyZWUgPSBtc3QoZ3JhcGgpO1xuICAgICAgICAvL0Fzc2lnbmluZyB0aGUgb3V0cHV0IHZhbHVlc1xuICAgICAgICAvLyBvdXRwdXRWYWx1ZShcImdyYXBoXCIsIGdyYXBoKTtcbiAgICAgICAgLy8gb3V0cHV0VmFsdWUoXCJtc3RcIiwgbXN0cmVlKTtcblxuICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IHRoZSBvdXRseWluZyBzY29yZSBhbmQgb3V0bHlpbmcgc2NvcmUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgICAgIC8vVE9ETzogTmVlZCB0byBjaGVjayBpZiBvdXRseWluZyBsaW5rcyBhcmUgcmVhbGx5IGNvbm5lY3RlZCB0byBvdXRseWluZyBwb2ludHNcbiAgICAgICAgbGV0IG91dGx5aW5nID0gbmV3IE91dGx5aW5nKG1zdHJlZSwge1xuICAgICAgICAgICAgICAgIG91dGx5aW5nVXBwZXJCb3VuZDogb3V0bHlpbmdVcHBlckJvdW5kLFxuICAgICAgICAgICAgICAgIG91dGx5aW5nQ29lZmZpY2llbnQ6IG91dGx5aW5nQ29lZmZpY2llbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsZXQgb3V0bHlpbmdTY29yZSA9IG91dGx5aW5nLnNjb3JlKCk7XG4gICAgICAgIG91dGx5aW5nVXBwZXJCb3VuZCA9IG91dGx5aW5nLnVwcGVyQm91bmQ7XG4gICAgICAgIC8vQWRkIG91dGx5aW5nIHBvaW50cyBmcm9tIHRoZSBiaW4gdG8gaXQuXG4gICAgICAgIG91dHB1dFZhbHVlKFwib3V0bHlpbmdTY29yZVwiLCBvdXRseWluZ1Njb3JlKTtcbiAgICAgICAgb3V0cHV0VmFsdWUoXCJvdXRseWluZ1VwcGVyQm91bmRcIiwgb3V0bHlpbmdVcHBlckJvdW5kKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGZ1bmN0aW9uIG91dHB1dFZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKGNvbW1vbmpzR2xvYmFsKTsiXSwibmFtZXMiOlsiZ2xvYmFsIiwiXyIsImRpc3RhbmNlIiwicXVhbnRpbGUiLCJjb21tb25qc0dsb2JhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztDQUFBOzs7OztDQUtBLENBQUMsV0FBVzs7Ozs7Ozs7R0FRVixJQUFJLElBQUksR0FBRyxPQUFPLElBQUksSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksSUFBSTthQUN0RCxPQUFPQSxjQUFNLElBQUksUUFBUSxJQUFJQSxjQUFNLENBQUMsTUFBTSxLQUFLQSxjQUFNLElBQUlBLGNBQU07YUFDL0QsSUFBSTthQUNKLEVBQUUsQ0FBQzs7O0dBR2IsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDOzs7R0FHaEMsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztHQUM5RCxJQUFJLFdBQVcsR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7OztHQUcxRSxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSTtPQUN0QixLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUs7T0FDeEIsUUFBUSxHQUFHLFFBQVEsQ0FBQyxRQUFRO09BQzVCLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDOzs7O0dBSTdDLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQyxPQUFPO09BQzdCLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSTtPQUN4QixZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7O0dBR2pDLElBQUksSUFBSSxHQUFHLFVBQVUsRUFBRSxDQUFDOzs7R0FHeEIsSUFBSSxDQUFDLEdBQUcsU0FBUyxHQUFHLEVBQUU7S0FDcEIsSUFBSSxHQUFHLFlBQVksQ0FBQyxFQUFFLE9BQU8sR0FBRyxDQUFDO0tBQ2pDLElBQUksRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUM1QyxJQUFJLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztJQUNyQixDQUFDOzs7Ozs7O0dBT0YsS0FBcUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFO0tBQ3RELEtBQW9DLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO09BQ3RFLE9BQU8sR0FBRyxjQUFjLEdBQUcsQ0FBQyxDQUFDO01BQzlCO0tBQ0QsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNmLE1BQU07S0FDTCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaOzs7R0FHRCxDQUFDLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7Ozs7R0FLcEIsSUFBSSxVQUFVLEdBQUcsU0FBUyxJQUFJLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRTtLQUNqRCxJQUFJLE9BQU8sS0FBSyxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksQ0FBQztLQUNwQyxRQUFRLFFBQVEsSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLFFBQVE7T0FDckMsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLEtBQUssRUFBRTtTQUM3QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2xDLENBQUM7O09BRUYsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFO1NBQ2hELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNyRCxDQUFDO09BQ0YsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFTLFdBQVcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRTtTQUM3RCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ2xFLENBQUM7TUFDSDtLQUNELE9BQU8sV0FBVztPQUNoQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO01BQ3ZDLENBQUM7SUFDSCxDQUFDOztHQUVGLElBQUksZUFBZSxDQUFDOzs7OztHQUtwQixJQUFJLEVBQUUsR0FBRyxTQUFTLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFO0tBQzFDLElBQUksQ0FBQyxDQUFDLFFBQVEsS0FBSyxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztLQUN0RSxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDO0tBQ3JDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLFVBQVUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ3JFLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3BFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQixDQUFDOzs7OztHQUtGLENBQUMsQ0FBQyxRQUFRLEdBQUcsZUFBZSxHQUFHLFNBQVMsS0FBSyxFQUFFLE9BQU8sRUFBRTtLQUN0RCxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Ozs7Ozs7R0FPRixJQUFJLGFBQWEsR0FBRyxTQUFTLElBQUksRUFBRSxVQUFVLEVBQUU7S0FDN0MsVUFBVSxHQUFHLFVBQVUsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7S0FDaEUsT0FBTyxXQUFXO09BQ2hCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1dBQ25ELElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1dBQ3BCLEtBQUssR0FBRyxDQUFDLENBQUM7T0FDZCxPQUFPLEtBQUssR0FBRyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUU7U0FDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLENBQUM7UUFDN0M7T0FDRCxRQUFRLFVBQVU7U0FDaEIsS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNyQyxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNuRCxLQUFLLENBQUMsRUFBRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbEU7T0FDRCxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO09BQ2pDLEtBQUssS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsVUFBVSxFQUFFLEtBQUssRUFBRSxFQUFFO1NBQzNDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEM7T0FDRCxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQ3hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDL0IsQ0FBQztJQUNILENBQUM7OztHQUdGLElBQUksVUFBVSxHQUFHLFNBQVMsU0FBUyxFQUFFO0tBQ25DLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDO0tBQ3RDLElBQUksWUFBWSxFQUFFLE9BQU8sWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ2pELElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0tBQzNCLElBQUksTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDO0tBQ3RCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0tBQ3RCLE9BQU8sTUFBTSxDQUFDO0lBQ2YsQ0FBQzs7R0FFRixJQUFJLGVBQWUsR0FBRyxTQUFTLEdBQUcsRUFBRTtLQUNsQyxPQUFPLFNBQVMsR0FBRyxFQUFFO09BQ25CLE9BQU8sR0FBRyxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDeEMsQ0FBQztJQUNILENBQUM7O0dBRUYsSUFBSSxHQUFHLEdBQUcsU0FBUyxHQUFHLEVBQUUsSUFBSSxFQUFFO0tBQzVCLE9BQU8sR0FBRyxJQUFJLElBQUksSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUN0RDs7R0FFRCxJQUFJLE9BQU8sR0FBRyxTQUFTLEdBQUcsRUFBRSxJQUFJLEVBQUU7S0FDaEMsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztLQUN6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO09BQy9CLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxPQUFPLEtBQUssQ0FBQyxDQUFDO09BQy9CLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDcEI7S0FDRCxPQUFPLE1BQU0sR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDOUIsQ0FBQzs7Ozs7O0dBTUYsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQzFDLElBQUksU0FBUyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUMxQyxJQUFJLFdBQVcsR0FBRyxTQUFTLFVBQVUsRUFBRTtLQUNyQyxJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDbkMsT0FBTyxPQUFPLE1BQU0sSUFBSSxRQUFRLElBQUksTUFBTSxJQUFJLENBQUMsSUFBSSxNQUFNLElBQUksZUFBZSxDQUFDO0lBQzlFLENBQUM7Ozs7Ozs7O0dBUUYsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTyxHQUFHLFNBQVMsR0FBRyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUU7S0FDcEQsUUFBUSxHQUFHLFVBQVUsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDekMsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDO0tBQ2QsSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7T0FDcEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7U0FDaEQsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDMUI7TUFDRixNQUFNO09BQ0wsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUN2QixLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtTQUNqRCxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN0QztNQUNGO0tBQ0QsT0FBTyxHQUFHLENBQUM7SUFDWixDQUFDOzs7R0FHRixDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtLQUNuRCxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUNqQyxJQUFJLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUN2QyxNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLE1BQU07U0FDN0IsT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUM1QixLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFO09BQzNDLElBQUksVUFBVSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO09BQzVDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQztNQUM3RDtLQUNELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7OztHQUdGLElBQUksWUFBWSxHQUFHLFNBQVMsR0FBRyxFQUFFOzs7S0FHL0IsSUFBSSxPQUFPLEdBQUcsU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7T0FDbkQsSUFBSSxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7V0FDdkMsTUFBTSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxNQUFNO1dBQzdCLEtBQUssR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO09BQ3JDLElBQUksQ0FBQyxPQUFPLEVBQUU7U0FDWixJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7U0FDdkMsS0FBSyxJQUFJLEdBQUcsQ0FBQztRQUNkO09BQ0QsT0FBTyxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRyxNQUFNLEVBQUUsS0FBSyxJQUFJLEdBQUcsRUFBRTtTQUNqRCxJQUFJLFVBQVUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUM1QyxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3pEO09BQ0QsT0FBTyxJQUFJLENBQUM7TUFDYixDQUFDOztLQUVGLE9BQU8sU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7T0FDNUMsSUFBSSxPQUFPLEdBQUcsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUM7T0FDcEMsT0FBTyxPQUFPLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztNQUN0RSxDQUFDO0lBQ0gsQ0FBQzs7OztHQUlGLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7O0dBR2hELENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7O0dBRzNDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxTQUFTLEdBQUcsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0tBQ3BELElBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7S0FDM0QsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDN0MsSUFBSSxHQUFHLEtBQUssS0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25ELENBQUM7Ozs7R0FJRixDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsU0FBUyxHQUFHLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRTtLQUN0RCxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7S0FDakIsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDbkMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsU0FBUyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtPQUN2QyxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDeEQsQ0FBQyxDQUFDO0tBQ0gsT0FBTyxPQUFPLENBQUM7SUFDaEIsQ0FBQzs7O0dBR0YsQ0FBQyxDQUFDLE1BQU0sR0FBRyxTQUFTLEdBQUcsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0tBQzNDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN4RCxDQUFDOzs7O0dBSUYsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7S0FDbEQsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDbkMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7U0FDdkMsTUFBTSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxNQUFNLENBQUM7S0FDbEMsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRTtPQUMzQyxJQUFJLFVBQVUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztPQUM1QyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxVQUFVLEVBQUUsR0FBRyxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7TUFDaEU7S0FDRCxPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7Ozs7R0FJRixDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsU0FBUyxHQUFHLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRTtLQUNqRCxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUNuQyxJQUFJLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUN2QyxNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLE1BQU0sQ0FBQztLQUNsQyxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFO09BQzNDLElBQUksVUFBVSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO09BQzVDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxVQUFVLEVBQUUsR0FBRyxDQUFDLEVBQUUsT0FBTyxJQUFJLENBQUM7TUFDOUQ7S0FDRCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7Ozs7R0FJRixDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLE9BQU8sR0FBRyxTQUFTLEdBQUcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRTtLQUMxRSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzNDLElBQUksT0FBTyxTQUFTLElBQUksUUFBUSxJQUFJLEtBQUssRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0tBQ3pELE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QyxDQUFDOzs7R0FHRixDQUFDLENBQUMsTUFBTSxHQUFHLGFBQWEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0tBQ2pELElBQUksV0FBVyxFQUFFLElBQUksQ0FBQztLQUN0QixJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7T0FDdEIsSUFBSSxHQUFHLElBQUksQ0FBQztNQUNiLE1BQU0sSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO09BQzFCLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2hDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztNQUM5QjtLQUNELE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsU0FBUyxPQUFPLEVBQUU7T0FDbEMsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO09BQ2xCLElBQUksQ0FBQyxNQUFNLEVBQUU7U0FDWCxJQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBTSxFQUFFO1dBQ3JDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1VBQ3pDO1NBQ0QsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFLE9BQU8sS0FBSyxDQUFDLENBQUM7U0FDbkMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QjtPQUNELE9BQU8sTUFBTSxJQUFJLElBQUksR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7TUFDOUQsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDOzs7R0FHSCxDQUFDLENBQUMsS0FBSyxHQUFHLFNBQVMsR0FBRyxFQUFFLEdBQUcsRUFBRTtLQUMzQixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDOzs7O0dBSUYsQ0FBQyxDQUFDLEtBQUssR0FBRyxTQUFTLEdBQUcsRUFBRSxLQUFLLEVBQUU7S0FDN0IsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQzs7OztHQUlGLENBQUMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0tBQ2pDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7OztHQUdGLENBQUMsQ0FBQyxHQUFHLEdBQUcsU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtLQUN2QyxJQUFJLE1BQU0sR0FBRyxDQUFDLFFBQVEsRUFBRSxZQUFZLEdBQUcsQ0FBQyxRQUFRO1NBQzVDLEtBQUssRUFBRSxRQUFRLENBQUM7S0FDcEIsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLE9BQU8sUUFBUSxJQUFJLFFBQVEsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtPQUMvRixHQUFHLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzdDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7U0FDcEQsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNmLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsTUFBTSxFQUFFO1dBQ25DLE1BQU0sR0FBRyxLQUFLLENBQUM7VUFDaEI7UUFDRjtNQUNGLE1BQU07T0FDTCxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztPQUNqQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO1NBQ25DLFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNwQyxJQUFJLFFBQVEsR0FBRyxZQUFZLElBQUksUUFBUSxLQUFLLENBQUMsUUFBUSxJQUFJLE1BQU0sS0FBSyxDQUFDLFFBQVEsRUFBRTtXQUM3RSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1dBQ1gsWUFBWSxHQUFHLFFBQVEsQ0FBQztVQUN6QjtRQUNGLENBQUMsQ0FBQztNQUNKO0tBQ0QsT0FBTyxNQUFNLENBQUM7SUFDZixDQUFDOzs7R0FHRixDQUFDLENBQUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUU7S0FDdkMsSUFBSSxNQUFNLEdBQUcsUUFBUSxFQUFFLFlBQVksR0FBRyxRQUFRO1NBQzFDLEtBQUssRUFBRSxRQUFRLENBQUM7S0FDcEIsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLE9BQU8sUUFBUSxJQUFJLFFBQVEsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtPQUMvRixHQUFHLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzdDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7U0FDcEQsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNmLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsTUFBTSxFQUFFO1dBQ25DLE1BQU0sR0FBRyxLQUFLLENBQUM7VUFDaEI7UUFDRjtNQUNGLE1BQU07T0FDTCxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztPQUNqQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO1NBQ25DLFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNwQyxJQUFJLFFBQVEsR0FBRyxZQUFZLElBQUksUUFBUSxLQUFLLFFBQVEsSUFBSSxNQUFNLEtBQUssUUFBUSxFQUFFO1dBQzNFLE1BQU0sR0FBRyxDQUFDLENBQUM7V0FDWCxZQUFZLEdBQUcsUUFBUSxDQUFDO1VBQ3pCO1FBQ0YsQ0FBQyxDQUFDO01BQ0o7S0FDRCxPQUFPLE1BQU0sQ0FBQztJQUNmLENBQUM7OztHQUdGLENBQUMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxHQUFHLEVBQUU7S0FDeEIsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNoQyxDQUFDOzs7Ozs7R0FNRixDQUFDLENBQUMsTUFBTSxHQUFHLFNBQVMsR0FBRyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUU7S0FDakMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLEtBQUssRUFBRTtPQUN0QixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzNDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3RDO0tBQ0QsSUFBSSxNQUFNLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUM3RCxJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDL0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDckMsSUFBSSxJQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztLQUN0QixLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFO09BQ3RDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO09BQ2pDLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztPQUN6QixNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7TUFDckI7S0FDRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7OztHQUdGLENBQUMsQ0FBQyxNQUFNLEdBQUcsU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtLQUMxQyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDZCxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUNqQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsU0FBUyxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRTtPQUNuRCxPQUFPO1NBQ0wsS0FBSyxFQUFFLEtBQUs7U0FDWixLQUFLLEVBQUUsS0FBSyxFQUFFO1NBQ2QsUUFBUSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQztRQUNyQyxDQUFDO01BQ0gsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksRUFBRSxLQUFLLEVBQUU7T0FDNUIsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztPQUN0QixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO09BQ3ZCLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtTQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDcEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3RDO09BQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7TUFDakMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2QsQ0FBQzs7O0dBR0YsSUFBSSxLQUFLLEdBQUcsU0FBUyxRQUFRLEVBQUUsU0FBUyxFQUFFO0tBQ3hDLE9BQU8sU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRTtPQUN0QyxJQUFJLE1BQU0sR0FBRyxTQUFTLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO09BQ3ZDLFFBQVEsR0FBRyxFQUFFLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2pDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRTtTQUNqQyxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztTQUN0QyxRQUFRLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM5QixDQUFDLENBQUM7T0FDSCxPQUFPLE1BQU0sQ0FBQztNQUNmLENBQUM7SUFDSCxDQUFDOzs7O0dBSUYsQ0FBQyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtLQUM3QyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNFLENBQUMsQ0FBQzs7OztHQUlILENBQUMsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFNBQVMsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUU7S0FDN0MsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDLENBQUM7Ozs7O0dBS0gsQ0FBQyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtLQUM3QyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNELENBQUMsQ0FBQzs7R0FFSCxJQUFJLFdBQVcsR0FBRyxrRUFBa0UsQ0FBQzs7R0FFckYsQ0FBQyxDQUFDLE9BQU8sR0FBRyxTQUFTLEdBQUcsRUFBRTtLQUN4QixJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDO0tBQ3BCLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDM0MsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFOztPQUVuQixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7TUFDL0I7S0FDRCxJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNwRCxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsQ0FBQzs7O0dBR0YsQ0FBQyxDQUFDLElBQUksR0FBRyxTQUFTLEdBQUcsRUFBRTtLQUNyQixJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDMUIsT0FBTyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUMzRCxDQUFDOzs7O0dBSUYsQ0FBQyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtLQUNoRCxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEMsRUFBRSxJQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7R0FRVCxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxTQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0tBQ3BELElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3RFLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUUsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDeEMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7Ozs7O0dBS0YsQ0FBQyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0tBQ3BDLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2RixDQUFDOzs7O0dBSUYsQ0FBQyxDQUFDLElBQUksR0FBRyxTQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0tBQ2pDLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLEdBQUcsS0FBSyxD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RDtDQUNBLFdBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVUsRUFBRSxFQUFFO0NBQzlDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7Q0FDMUIsUUFBUSxJQUFJLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUNuQyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDO0NBQ2xDLEtBQUs7Q0FDTCxFQUFDO0FBQ0Q7Q0FDQTtDQUNBO0NBQ0EsV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBVSxFQUFFLEVBQUU7Q0FDM0MsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssU0FBUyxFQUFFO0NBQ3ZDLFFBQVEsT0FBTyxTQUFTLENBQUM7Q0FDekIsS0FBSztBQUNMO0NBQ0EsSUFBSSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQztDQUMxQyxJQUFJLE9BQU8sT0FBTyxLQUFLLE9BQU8sQ0FBQyxPQUFPLEVBQUU7Q0FDeEMsUUFBUSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztDQUNsQyxLQUFLO0NBQ0wsSUFBSSxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUM7Q0FDdkIsRUFBQztBQUNEO0NBQ0EsV0FBVyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0NBQzlDLElBQUksSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDMUMsSUFBSSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQztDQUNBLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLEtBQUssRUFBRTtDQUN2RTtDQUNBLFFBQVEsT0FBTztDQUNmLEtBQUs7QUFDTDtDQUNBLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUU7Q0FDakMsUUFBUSxLQUFLLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztDQUM5QixLQUFLLE1BQU0sSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUU7Q0FDMUMsUUFBUSxLQUFLLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztDQUM5QixLQUFLLE1BQU07Q0FDWCxRQUFRLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0NBQzlCLFFBQVEsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0NBQ3RCLEtBQUs7Q0FDTCxFQUFDO0FBQ0Q7Q0FDQTtDQUNBLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFlBQVk7Q0FDekMsSUFBSSxJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUM7Q0FDM0IsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEtBQUs7Q0FDN0MsUUFBUSxhQUFhLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO0NBQ2pDLEtBQUssQ0FBQyxDQUFDO0NBQ1AsSUFBSSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxDQUFDO0NBQzdDLEVBQUM7Q0FDRCxnQkFBZ0I7O0NDeFN3c0UsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxBQUE0cFosSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcs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
