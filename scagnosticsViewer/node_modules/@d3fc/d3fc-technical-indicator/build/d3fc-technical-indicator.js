(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('@d3fc/d3fc-rebind')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-array', '@d3fc/d3fc-rebind'], factory) :
    (global = global || self, factory(global.fc = global.fc || {}, global.d3, global.fc));
}(this, function (exports, d3Array, d3fcRebind) { 'use strict';

    function identity(d) {
      return d;
    }
    function noop(d) {}
    function functor(v) {
      return typeof v === 'function' ? v : function () {
        return v;
      };
    }
    function convertNaN(value) {
      return typeof value === 'number' && isNaN(value) ? undefined : value;
    }

    function _slidingWindow () {
      var period = function period() {
        return 10;
      };

      var accumulator = noop;
      var value = identity;

      var defined = function defined(d) {
        return d != null;
      };

      var slidingWindow = function slidingWindow(data) {
        var size = period.apply(this, arguments);
        var windowData = data.slice(0, size).map(value);
        return data.map(function (d, i) {
          if (i >= size) {
            // Treat windowData as FIFO rolling buffer
            windowData.shift();
            windowData.push(value(d, i));
          }

          if (i < size - 1 || windowData.some(function (d) {
            return !defined(d);
          })) {
            return accumulator(undefined, i);
          }

          return accumulator(windowData, i);
        });
      };

      slidingWindow.period = function () {
        if (!arguments.length) {
          return period;
        }

        period = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return slidingWindow;
      };

      slidingWindow.accumulator = function () {
        if (!arguments.length) {
          return accumulator;
        }

        accumulator = arguments.length <= 0 ? undefined : arguments[0];
        return slidingWindow;
      };

      slidingWindow.defined = function () {
        if (!arguments.length) {
          return defined;
        }

        defined = arguments.length <= 0 ? undefined : arguments[0];
        return slidingWindow;
      };

      slidingWindow.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        return slidingWindow;
      };

      return slidingWindow;
    }

    function bollingerBands () {
      var multiplier = 2;

      var slidingWindow = _slidingWindow().accumulator(function (values) {
        var stdDev = values && d3Array.deviation(values);
        var average = values && d3Array.mean(values);
        return {
          average: average,
          upper: convertNaN(average + multiplier * stdDev),
          lower: convertNaN(average - multiplier * stdDev)
        };
      });

      var bollingerBands = function bollingerBands(data) {
        return slidingWindow(data);
      };

      bollingerBands.multiplier = function () {
        if (!arguments.length) {
          return multiplier;
        }

        multiplier = arguments.length <= 0 ? undefined : arguments[0];
        return bollingerBands;
      };

      d3fcRebind.rebind(bollingerBands, slidingWindow, 'period', 'value');
      return bollingerBands;
    }

    function exponentialMovingAverage () {
      var value = identity;

      var period = function period() {
        return 9;
      };

      var initialMovingAverageAccumulator = function initialMovingAverageAccumulator(period) {
        var values = [];
        return function (value) {
          var movingAverage;

          if (values.length < period) {
            if (value != null) {
              values.push(value);
            } else {
              values = [];
            }
          }

          if (values.length >= period) {
            movingAverage = d3Array.mean(values);
          }

          return movingAverage;
        };
      };

      var exponentialMovingAverage = function exponentialMovingAverage(data) {
        var size = period.apply(this, arguments);
        var alpha = 2 / (size + 1);
        var initialAccumulator = initialMovingAverageAccumulator(size);
        var ema;
        return data.map(function (d, i) {
          var v = value(d, i);

          if (ema === undefined) {
            ema = initialAccumulator(v);
          } else {
            ema = v * alpha + (1 - alpha) * ema;
          }

          return convertNaN(ema);
        });
      };

      exponentialMovingAverage.period = function () {
        if (!arguments.length) {
          return period;
        }

        period = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return exponentialMovingAverage;
      };

      exponentialMovingAverage.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        return exponentialMovingAverage;
      };

      return exponentialMovingAverage;
    }

    function macd () {
      var value = identity;
      var fastEMA = exponentialMovingAverage().period(12);
      var slowEMA = exponentialMovingAverage().period(26);
      var signalEMA = exponentialMovingAverage().period(9);

      var macd = function macd(data) {
        fastEMA.value(value);
        slowEMA.value(value);
        var diff = d3Array.zip(fastEMA(data), slowEMA(data)).map(function (d) {
          return d[0] !== undefined && d[1] !== undefined ? d[0] - d[1] : undefined;
        });
        var averageDiff = signalEMA(diff);
        return d3Array.zip(diff, averageDiff).map(function (d) {
          return {
            macd: d[0],
            signal: d[1],
            divergence: d[0] !== undefined && d[1] !== undefined ? d[0] - d[1] : undefined
          };
        });
      };

      macd.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        return macd;
      };

      d3fcRebind.rebindAll(macd, fastEMA, d3fcRebind.includeMap({
        'period': 'fastPeriod'
      }));
      d3fcRebind.rebindAll(macd, slowEMA, d3fcRebind.includeMap({
        'period': 'slowPeriod'
      }));
      d3fcRebind.rebindAll(macd, signalEMA, d3fcRebind.includeMap({
        'period': 'signalPeriod'
      }));
      return macd;
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    function relativeStrengthIndex () {
      var slidingWindow = _slidingWindow().period(14);

      var wildersSmoothing = function wildersSmoothing(values, prevAvg) {
        return prevAvg + (values[values.length - 1] - prevAvg) / values.length;
      };

      var downChange = function downChange(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            prevClose = _ref2[0],
            close = _ref2[1];

        return prevClose < close ? 0 : prevClose - close;
      };

      var upChange = function upChange(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            prevClose = _ref4[0],
            close = _ref4[1];

        return prevClose > close ? 0 : close - prevClose;
      };

      var updateAverage = function updateAverage(changes, prevAverage) {
        return prevAverage !== undefined ? wildersSmoothing(changes, prevAverage) : d3Array.mean(changes);
      };

      var makeAccumulator = function makeAccumulator() {
        var prevClose;
        var downChangesAvg;
        var upChangesAvg;
        return function (closes) {
          if (!closes) {
            if (prevClose !== undefined) {
              prevClose = NaN;
            }

            return undefined;
          }

          if (prevClose === undefined) {
            prevClose = closes[0];
            return undefined;
          }

          var closePairs = d3Array.pairs([prevClose].concat(_toConsumableArray(closes)));
          downChangesAvg = updateAverage(closePairs.map(downChange), downChangesAvg);
          upChangesAvg = updateAverage(closePairs.map(upChange), upChangesAvg);
          var rs = !isNaN(prevClose) ? upChangesAvg / downChangesAvg : NaN;
          return convertNaN(100 - 100 / (1 + rs));
        };
      };

      var rsi = function rsi(data) {
        var rsiAccumulator = makeAccumulator();
        slidingWindow.accumulator(rsiAccumulator);
        return slidingWindow(data);
      };

      d3fcRebind.rebind(rsi, slidingWindow, 'period', 'value');
      return rsi;
    }

    function movingAverage () {
      var slidingWindow = _slidingWindow().accumulator(function (values) {
        return values && d3Array.mean(values);
      });

      var movingAverage = function movingAverage(data) {
        return slidingWindow(data);
      };

      d3fcRebind.rebind(movingAverage, slidingWindow, 'period', 'value');
      return movingAverage;
    }

    function stochasticOscillator () {
      var closeValue = function closeValue(d, i) {
        return d.close;
      };

      var highValue = function highValue(d, i) {
        return d.high;
      };

      var lowValue = function lowValue(d, i) {
        return d.low;
      };

      var kWindow = _slidingWindow().period(5).defined(function (d) {
        return closeValue(d) != null && highValue(d) != null && lowValue(d) != null;
      }).accumulator(function (values) {
        var maxHigh = values && d3Array.max(values, highValue);
        var minLow = values && d3Array.min(values, lowValue);
        var kValue = values && 100 * (closeValue(values[values.length - 1]) - minLow) / (maxHigh - minLow);
        return convertNaN(kValue);
      });
      var dWindow = movingAverage().period(3);

      var stochastic = function stochastic(data) {
        var kValues = kWindow(data);
        var dValues = dWindow(kValues);
        return kValues.map(function (k, i) {
          return {
            k: k,
            d: dValues[i]
          };
        });
      };

      stochastic.closeValue = function () {
        if (!arguments.length) {
          return closeValue;
        }

        closeValue = arguments.length <= 0 ? undefined : arguments[0];
        return stochastic;
      };

      stochastic.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = arguments.length <= 0 ? undefined : arguments[0];
        return stochastic;
      };

      stochastic.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = arguments.length <= 0 ? undefined : arguments[0];
        return stochastic;
      };

      d3fcRebind.rebindAll(stochastic, kWindow, d3fcRebind.includeMap({
        'period': 'kPeriod'
      }));
      d3fcRebind.rebindAll(stochastic, dWindow, d3fcRebind.includeMap({
        'period': 'dPeriod'
      }));
      return stochastic;
    }

    function forceIndex () {
      var volumeValue = function volumeValue(d, i) {
        return d.volume;
      };

      var closeValue = function closeValue(d, i) {
        return d.close;
      };

      var emaComputer = exponentialMovingAverage().period(13);

      var slidingWindow = _slidingWindow().period(2).defined(function (d) {
        return closeValue(d) != null && volumeValue(d) != null;
      }).accumulator(function (values) {
        return values && convertNaN((closeValue(values[1]) - closeValue(values[0])) * volumeValue(values[1]));
      });

      var force = function force(data) {
        var forceIndex = slidingWindow(data);
        return emaComputer(forceIndex);
      };

      force.volumeValue = function () {
        if (!arguments.length) {
          return volumeValue;
        }

        volumeValue = arguments.length <= 0 ? undefined : arguments[0];
        return force;
      };

      force.closeValue = function () {
        if (!arguments.length) {
          return closeValue;
        }

        closeValue = arguments.length <= 0 ? undefined : arguments[0];
        return force;
      };

      d3fcRebind.rebind(force, emaComputer, 'period');
      return force;
    }

    function envelope () {
      var factor = 0.1;
      var value = identity;

      var envelope = function envelope(data) {
        return data.map(function (d) {
          var lower = convertNaN(value(d) * (1.0 - factor));
          var upper = convertNaN(value(d) * (1.0 + factor));
          return {
            lower: lower,
            upper: upper
          };
        });
      };

      envelope.factor = function () {
        if (!arguments.length) {
          return factor;
        }

        factor = arguments.length <= 0 ? undefined : arguments[0];
        return envelope;
      };

      envelope.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        return envelope;
      };

      return envelope;
    }

    function elderRay () {
      var closeValue = function closeValue(d, i) {
        return d.close;
      };

      var highValue = function highValue(d, i) {
        return d.high;
      };

      var lowValue = function lowValue(d, i) {
        return d.low;
      };

      var emaComputer = exponentialMovingAverage().period(13);

      var elderRay = function elderRay(data) {
        emaComputer.value(closeValue);
        return d3Array.zip(data, emaComputer(data)).map(function (d) {
          var bullPower = convertNaN(highValue(d[0]) - d[1]);
          var bearPower = convertNaN(lowValue(d[0]) - d[1]);
          return {
            bullPower: bullPower,
            bearPower: bearPower
          };
        });
      };

      elderRay.closeValue = function () {
        if (!arguments.length) {
          return closeValue;
        }

        closeValue = arguments.length <= 0 ? undefined : arguments[0];
        return elderRay;
      };

      elderRay.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = arguments.length <= 0 ? undefined : arguments[0];
        return elderRay;
      };

      elderRay.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = arguments.length <= 0 ? undefined : arguments[0];
        return elderRay;
      };

      d3fcRebind.rebind(elderRay, emaComputer, 'period');
      return elderRay;
    }

    exports.indicatorBollingerBands = bollingerBands;
    exports.indicatorElderRay = elderRay;
    exports.indicatorEnvelope = envelope;
    exports.indicatorExponentialMovingAverage = exponentialMovingAverage;
    exports.indicatorForceIndex = forceIndex;
    exports.indicatorMacd = macd;
    exports.indicatorMovingAverage = movingAverage;
    exports.indicatorRelativeStrengthIndex = relativeStrengthIndex;
    exports.indicatorStochasticOscillator = stochasticOscillator;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
