(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@d3fc/d3fc-data-join'), require('d3-shape'), require('d3-selection'), require('@d3fc/d3fc-rebind'), require('d3-scale'), require('@d3fc/d3fc-webgl'), require('@d3fc/d3fc-shape'), require('d3-array'), require('d3-scale-chromatic')) :
    typeof define === 'function' && define.amd ? define(['exports', '@d3fc/d3fc-data-join', 'd3-shape', 'd3-selection', '@d3fc/d3fc-rebind', 'd3-scale', '@d3fc/d3fc-webgl', '@d3fc/d3fc-shape', 'd3-array', 'd3-scale-chromatic'], factory) :
    (global = global || self, factory(global.fc = global.fc || {}, global.fc, global.d3, global.d3, global.fc, global.d3, global.fc, global.fc, global.d3, global.d3));
}(this, function (exports, d3fcDataJoin, d3Shape, d3Selection, d3fcRebind, d3Scale, d3fcWebgl, d3fcShape, d3Array, d3ScaleChromatic) { 'use strict';

    var functor = (function (d) {
      return typeof d === 'function' ? d : function () {
        return d;
      };
    });

    // Checks that passed properties are 'defined', meaning that calling them with (d, i) returns non null values
    function defined() {
      var outerArguments = arguments;
      return function (d, i) {
        for (var c = 0, j = outerArguments.length; c < j; c++) {
          if (outerArguments[c](d, i) == null) {
            return false;
          }
        }

        return true;
      };
    }

    // determines the offset required along the cross scale based
    // on the series alignment
    var alignOffset = (function (align, width) {
      switch (align) {
        case 'left':
          return width / 2;

        case 'right':
          return -width / 2;

        default:
          return 0;
      }
    });

    var createBase = (function (initialValues) {
      var env = Object.assign({}, initialValues);

      var base = function base() {};

      Object.keys(env).forEach(function (key) {
        base[key] = function () {
          if (!arguments.length) {
            return env[key];
          }

          env[key] = arguments.length <= 0 ? undefined : arguments[0];
          return base;
        };
      });
      return base;
    });

    var xyBase = (function () {
      var baseValue = function baseValue() {
        return 0;
      };

      var crossValue = function crossValue(d) {
        return d.x;
      };

      var mainValue = function mainValue(d) {
        return d.y;
      };

      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var orient = 'vertical';
      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(baseValue, crossValue, mainValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(mainValue(d, i), i);
          var y0 = yScale(baseValue(d, i), i);
          var x = xScale(crossValue(d, i), i) + offset;
          return {
            d: d,
            x: x,
            y: y,
            y0: y0,
            width: width,
            height: y - y0,
            origin: [x, y],
            baseOrigin: [x, y0],
            transposedX: x,
            transposedY: y
          };
        } else {
          var _y = xScale(mainValue(d, i), i);

          var _y2 = xScale(baseValue(d, i), i);

          var _x = yScale(crossValue(d, i), i) + offset;

          return {
            d: d,
            x: _x,
            y: _y,
            y0: _y2,
            width: width,
            height: _y - _y2,
            origin: [_y, _x],
            baseOrigin: [_y2, _x],
            transposedX: _y,
            transposedY: _x
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [baseValue, mainValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [baseValue, mainValue];
      };

      base.baseValue = function () {
        if (!arguments.length) {
          return baseValue;
        }

        baseValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.mainValue = function () {
        if (!arguments.length) {
          return mainValue;
        }

        mainValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var red = '#c60';
    var green = '#6c0';
    var black = '#000';
    var gray = '#ddd';
    var darkGray = '#999';
    var colors = {
      red: red,
      green: green,
      black: black,
      gray: gray,
      darkGray: darkGray
    };

    var line = (function () {
      var base = xyBase();
      var lineData = d3Shape.line().x(function (d, i) {
        return base.values(d, i).transposedX;
      }).y(function (d, i) {
        return base.values(d, i).transposedY;
      });
      var join = d3fcDataJoin.dataJoin('path', 'line');

      var line = function line(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        lineData.defined(base.defined());
        selection.each(function (data, index, group) {
          var path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', 'none').attr('stroke', colors.black);
          path.attr('d', lineData);
          base.decorate()(path, data, index);
        });
      };

      d3fcRebind.rebindAll(line, base, d3fcRebind.exclude('baseValue', 'bandwidth', 'align'));
      d3fcRebind.rebind(line, join, 'key');
      d3fcRebind.rebind(line, lineData, 'curve');
      return line;
    });

    var line$1 = (function () {
      var base = xyBase();
      var lineData = d3Shape.line().x(function (d, i) {
        return base.values(d, i).transposedX;
      }).y(function (d, i) {
        return base.values(d, i).transposedY;
      });

      var line = function line(data) {
        var context = lineData.context();
        context.beginPath();
        context.strokeStyle = colors.black;
        context.fillStyle = 'transparent';
        base.decorate()(context, data);
        lineData.defined(base.defined())(data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      d3fcRebind.rebindAll(line, base, d3fcRebind.exclude('baseValue', 'bandwidth', 'align'));
      d3fcRebind.rebind(line, lineData, 'curve', 'context');
      return line;
    });

    var line$2 = (function () {
      var base = xyBase();
      var crossValueAttribute = d3fcWebgl.webglAdjacentAttribute(-1, 2);
      var crossPreviousValueAttribute = crossValueAttribute.offset(-1);
      var crossNextValueAttribute = crossValueAttribute.offset(1);
      var crossNextNextValueAttribute = crossValueAttribute.offset(2);
      var mainValueAttribute = d3fcWebgl.webglAdjacentAttribute(-1, 2);
      var mainPreviousValueAttribute = mainValueAttribute.offset(-1);
      var mainNextValueAttribute = mainValueAttribute.offset(1);
      var mainNextNextValueAttribute = mainValueAttribute.offset(2);
      var definedAttribute = d3fcWebgl.webglAdjacentAttribute(0, 1).type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      var definedNextAttribute = definedAttribute.offset(1);
      var draw = d3fcWebgl.webglSeriesLine().crossPreviousValueAttribute(crossPreviousValueAttribute).crossValueAttribute(crossValueAttribute).crossNextValueAttribute(crossNextValueAttribute).crossNextNextValueAttribute(crossNextNextValueAttribute).mainPreviousValueAttribute(mainPreviousValueAttribute).mainValueAttribute(mainValueAttribute).mainNextValueAttribute(mainNextValueAttribute).mainNextNextValueAttribute(mainNextNextValueAttribute).definedAttribute(definedAttribute).definedNextAttribute(definedNextAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;

      var line = function line(data) {
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;

          if (base.orient() === 'vertical') {
            crossValueAttribute.value(function (d, i) {
              return xScale.scale(base.crossValue()(d, i));
            }).data(data);
          } else {
            crossValueAttribute.value(function (d, i) {
              return xScale.scale(base.mainValue()(d, i));
            }).data(data);
          }
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;

          if (base.orient() === 'vertical') {
            mainValueAttribute.value(function (d, i) {
              return yScale.scale(base.mainValue()(d, i));
            }).data(data);
          } else {
            mainValueAttribute.value(function (d, i) {
              return yScale.scale(base.crossValue()(d, i));
            }).data(data);
          }
        }

        draw.xScale(xScale.webglScale).yScale(yScale.webglScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      line.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return line;
      };

      line.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return line;
      };

      d3fcRebind.rebindAll(line, base, d3fcRebind.exclude('baseValue', 'bandwidth', 'align'));
      d3fcRebind.rebind(line, draw, 'context', 'lineWidth');
      return line;
    });

    var point = (function () {
      var symbol = d3Shape.symbol();
      var base = xyBase();
      var join = d3fcDataJoin.dataJoin('g', 'point');

      var containerTransform = function containerTransform(origin) {
        return 'translate(' + origin[0] + ', ' + origin[1] + ')';
      };

      var point = function point(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', function (d, i) {
            return containerTransform(base.values(d, i).origin);
          }).attr('fill', colors.gray).attr('stroke', colors.black).append('path');
          g.attr('transform', function (d, i) {
            return containerTransform(base.values(d, i).origin);
          }).select('path').attr('d', symbol);
          base.decorate()(g, data, index);
        });
      };

      d3fcRebind.rebindAll(point, base, d3fcRebind.exclude('baseValue', 'bandwidth', 'align'));
      d3fcRebind.rebind(point, join, 'key');
      d3fcRebind.rebind(point, symbol, 'type', 'size');
      return point;
    });

    var point$1 = (function () {
      var symbol = d3Shape.symbol();
      var base = xyBase();

      var point = function point(data) {
        var filteredData = data.filter(base.defined());
        var context = symbol.context();
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          symbol(d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      d3fcRebind.rebindAll(point, base, d3fcRebind.exclude('baseValue', 'bandwidth', 'align'));
      d3fcRebind.rebind(point, symbol, 'size', 'type', 'context');
      return point;
    });

    var point$2 = (function () {
      var base = xyBase();
      var size = functor(64);
      var type = d3Shape.symbolCircle;
      var crossValueAttribute = d3fcWebgl.webglAttribute();
      var mainValueAttribute = d3fcWebgl.webglAttribute();
      var sizeAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_SHORT);
      var definedAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      var draw = d3fcWebgl.webglSeriesPoint().crossValueAttribute(crossValueAttribute).mainValueAttribute(mainValueAttribute).sizeAttribute(sizeAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;

      var point = function point(data) {
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          sizeAttribute.value(function (d, i) {
            return size(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;

          if (base.orient() === 'vertical') {
            crossValueAttribute.value(function (d, i) {
              return xScale.scale(base.crossValue()(d, i));
            }).data(data);
          } else {
            crossValueAttribute.value(function (d, i) {
              return xScale.scale(base.mainValue()(d, i));
            }).data(data);
          }
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;

          if (base.orient() === 'vertical') {
            mainValueAttribute.value(function (d, i) {
              return yScale.scale(base.mainValue()(d, i));
            }).data(data);
          } else {
            mainValueAttribute.value(function (d, i) {
              return yScale.scale(base.crossValue()(d, i));
            }).data(data);
          }
        }

        draw.xScale(xScale.webglScale).yScale(yScale.webglScale).type(d3fcWebgl.webglSymbolMapper(type)).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      point.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return point;
      };

      point.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      point.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      point.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      d3fcRebind.rebindAll(point, base, d3fcRebind.exclude('baseValue', 'bandwidth', 'align'));
      d3fcRebind.rebind(point, draw, 'context');
      return point;
    });

    var bar = (function () {
      var pathGenerator = d3fcShape.shapeBar().x(0).y(0);
      var base = xyBase();
      var join = d3fcDataJoin.dataJoin('g', 'bar');

      var valueAxisDimension = function valueAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.height : generator.width;
      };

      var crossAxisDimension = function crossAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.width : generator.height;
      };

      var translation = function translation(origin) {
        return 'translate(' + origin[0] + ', ' + origin[1] + ')';
      };

      var bar = function bar(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var orient = base.orient();

          if (orient !== 'vertical' && orient !== 'horizontal') {
            throw new Error('The bar series does not support an orientation of ' + orient);
          }

          var filteredData = data.filter(base.defined());
          var projectedData = filteredData.map(base.values);
          pathGenerator.width(0).height(0);

          if (base.orient() === 'vertical') {
            pathGenerator.verticalAlign('top');
            pathGenerator.horizontalAlign('center');
          } else {
            pathGenerator.horizontalAlign('right');
            pathGenerator.verticalAlign('center');
          }

          var g = join(d3Selection.select(group[index]), filteredData); // within the enter selection the pathGenerator creates a zero
          // height bar on the baseline. As a result, when used with a transition the bar grows
          // from y0 to y1 (y)

          g.enter().attr('transform', function (_, i) {
            return translation(projectedData[i].baseOrigin);
          }).attr('class', 'bar ' + base.orient()).attr('fill', colors.darkGray).append('path').attr('d', function (d, i) {
            crossAxisDimension(pathGenerator)(projectedData[i].width);
            return pathGenerator([d]);
          }); // the container translation sets the origin to the 'tip'
          // of each bar as per the decorate pattern

          g.attr('transform', function (_, i) {
            return translation(projectedData[i].origin);
          }).select('path').attr('d', function (d, i) {
            crossAxisDimension(pathGenerator)(projectedData[i].width);
            valueAxisDimension(pathGenerator)(-projectedData[i].height);
            return pathGenerator([d]);
          });
          base.decorate()(g, filteredData, index);
        });
      };

      d3fcRebind.rebindAll(bar, base);
      d3fcRebind.rebind(bar, join, 'key');
      return bar;
    });

    var bar$1 = (function () {
      var base = xyBase();
      var pathGenerator = d3fcShape.shapeBar().x(0).y(0);

      var valueAxisDimension = function valueAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.height : generator.width;
      };

      var crossAxisDimension = function crossAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.width : generator.height;
      };

      var bar = function bar(data) {
        var context = pathGenerator.context();
        var filteredData = data.filter(base.defined());
        var projectedData = filteredData.map(base.values);

        if (base.orient() === 'vertical') {
          pathGenerator.verticalAlign('top');
          pathGenerator.horizontalAlign('center');
        } else {
          pathGenerator.horizontalAlign('right');
          pathGenerator.verticalAlign('center');
        }

        projectedData.forEach(function (datum, i) {
          context.save();
          context.beginPath();
          context.translate(datum.origin[0], datum.origin[1]);
          context.fillStyle = colors.darkGray;
          context.strokeStyle = 'transparent';
          base.decorate()(context, datum.d, i);
          valueAxisDimension(pathGenerator)(-datum.height);
          crossAxisDimension(pathGenerator)(datum.width);
          pathGenerator([datum]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      d3fcRebind.rebindAll(bar, base);
      d3fcRebind.rebind(bar, pathGenerator, 'context');
      return bar;
    });

    var bar$2 = (function () {
      var base = xyBase();
      var crossValueAttribute = d3fcWebgl.webglAttribute();
      var mainValueAttribute = d3fcWebgl.webglAttribute();
      var baseValueAttribute = d3fcWebgl.webglAttribute();
      var bandwidthAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_SHORT);
      var definedAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      var draw = d3fcWebgl.webglSeriesBar().crossValueAttribute(crossValueAttribute).mainValueAttribute(mainValueAttribute).baseValueAttribute(baseValueAttribute).bandwidthAttribute(bandwidthAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;

      var bar = function bar(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;
          baseValueAttribute.value(function (d, i) {
            return yScale.scale(base.baseValue()(d, i));
          }).data(data);
          mainValueAttribute.value(function (d, i) {
            return yScale.scale(base.mainValue()(d, i));
          }).data(data);
        }

        draw.xScale(xScale.webglScale).yScale(yScale.webglScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      bar.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return bar;
      };

      bar.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return bar;
      };

      d3fcRebind.rebindAll(bar, base, d3fcRebind.exclude('align'));
      d3fcRebind.rebind(bar, draw, 'context');
      return bar;
    });

    var errorBarBase = (function () {
      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var crossValue = function crossValue(d) {
        return d.cross;
      };

      var orient = 'vertical';
      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(lowValue, highValue, crossValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(highValue(d, i));
          return {
            origin: [xScale(crossValue(d, i)) + offset, y],
            high: 0,
            low: yScale(lowValue(d, i)) - y,
            width: width
          };
        } else {
          var x = xScale(lowValue(d, i));
          return {
            origin: [x, yScale(crossValue(d, i)) + offset],
            high: xScale(highValue(d, i)) - x,
            low: 0,
            width: width
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [highValue, lowValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [highValue, lowValue];
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var errorBar = (function () {
      var base = errorBarBase();
      var join = d3fcDataJoin.dataJoin('g', 'error-bar');
      var pathGenerator = d3fcShape.shapeErrorBar().value(0);

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.origin[0] + ', ' + values.origin[1] + ')';
      };

      var errorBar = function errorBar(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var projectedData = filteredData.map(base.values);
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('stroke', colors.black).attr('fill', colors.gray).attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          pathGenerator.orient(base.orient());
          g.each(function (d, i, g) {
            var values = projectedData[i];
            pathGenerator.high(values.high).low(values.low).width(values.width);
            transitionPropagator(d3Selection.select(g[i])).attr('transform', containerTranslation(values) + ' scale(1)').select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      d3fcRebind.rebindAll(errorBar, base);
      d3fcRebind.rebind(errorBar, join, 'key');
      return errorBar;
    });

    var errorBar$1 = (function () {
      var base = errorBarBase();
      var pathGenerator = d3fcShape.shapeErrorBar().value(0);

      var errorBar = function errorBar(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        pathGenerator.orient(base.orient());
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          pathGenerator.high(values.high).width(values.width).low(values.low)([d]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      d3fcRebind.rebindAll(errorBar, base);
      d3fcRebind.rebind(errorBar, pathGenerator, 'context');
      return errorBar;
    });

    var errorBar$2 = (function () {
      var base = errorBarBase();
      var crossValueAttribute = d3fcWebgl.webglAttribute();
      var highValueAttribute = d3fcWebgl.webglAttribute();
      var lowValueAttribute = d3fcWebgl.webglAttribute();
      var bandwidthAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_SHORT);
      var definedAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      var draw = d3fcWebgl.webglSeriesErrorBar().crossValueAttribute(crossValueAttribute).highValueAttribute(highValueAttribute).lowValueAttribute(lowValueAttribute).bandwidthAttribute(bandwidthAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;

      var errorBar = function errorBar(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;
          highValueAttribute.value(function (d, i) {
            return yScale.scale(base.highValue()(d, i));
          }).data(data);
          lowValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowValue()(d, i));
          }).data(data);
        }

        draw.xScale(xScale.webglScale).yScale(yScale.webglScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      errorBar.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return errorBar;
      };

      errorBar.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return errorBar;
      };

      d3fcRebind.rebindAll(errorBar, base, d3fcRebind.exclude('align'));
      d3fcRebind.rebind(errorBar, draw, 'context', 'lineWidth');
      return errorBar;
    });

    var area = (function () {
      var base = xyBase();
      var areaData = d3Shape.area();
      var join = d3fcDataJoin.dataJoin('path', 'area');

      var area = function area(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        areaData.defined(base.defined());
        selection.each(function (data, index, group) {
          var projectedData = data.map(base.values);
          areaData.x(function (_, i) {
            return projectedData[i].transposedX;
          }).y(function (_, i) {
            return projectedData[i].transposedY;
          });
          var valueComponent = base.orient() === 'vertical' ? 'y' : 'x';
          areaData[valueComponent + '0'](function (_, i) {
            return projectedData[i].y0;
          });
          areaData[valueComponent + '1'](function (_, i) {
            return projectedData[i].y;
          });
          var path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', colors.gray);
          path.attr('d', areaData);
          base.decorate()(path, data, index);
        });
      };

      d3fcRebind.rebindAll(area, base, d3fcRebind.exclude('bandwidth', 'align'));
      d3fcRebind.rebind(area, join, 'key');
      d3fcRebind.rebind(area, areaData, 'curve');
      return area;
    });

    var area$1 = (function () {
      var base = xyBase();
      var areaData = d3Shape.area();

      var area = function area(data) {
        var context = areaData.context();
        areaData.defined(base.defined());
        var projectedData = data.map(base.values);
        areaData.x(function (_, i) {
          return projectedData[i].transposedX;
        }).y(function (_, i) {
          return projectedData[i].transposedY;
        });
        var valueComponent = base.orient() === 'vertical' ? 'y' : 'x';
        areaData[valueComponent + '0'](function (_, i) {
          return projectedData[i].y0;
        });
        areaData[valueComponent + '1'](function (_, i) {
          return projectedData[i].y;
        });
        context.beginPath();
        context.fillStyle = colors.gray;
        context.strokeStyle = 'transparent';
        base.decorate()(context, data);
        areaData(data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      d3fcRebind.rebindAll(area, base, d3fcRebind.exclude('bandwidth', 'align'));
      d3fcRebind.rebind(area, areaData, 'curve', 'context');
      return area;
    });

    var area$2 = (function () {
      var base = xyBase();
      var crossValueAttribute = d3fcWebgl.webglAdjacentAttribute(0, 1);
      var crossNextValueAttribute = crossValueAttribute.offset(1);
      var mainValueAttribute = d3fcWebgl.webglAdjacentAttribute(0, 1);
      var mainNextValueAttribute = mainValueAttribute.offset(1);
      var baseValueAttribute = d3fcWebgl.webglAdjacentAttribute(0, 1);
      var baseNextValueAttribute = baseValueAttribute.offset(1);
      var definedAttribute = d3fcWebgl.webglAdjacentAttribute(0, 1).type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      var definedNextAttribute = definedAttribute.offset(1);
      var draw = d3fcWebgl.webglSeriesArea().crossValueAttribute(crossValueAttribute).crossNextValueAttribute(crossNextValueAttribute).mainValueAttribute(mainValueAttribute).mainNextValueAttribute(mainNextValueAttribute).baseValueAttribute(baseValueAttribute).baseNextValueAttribute(baseNextValueAttribute).definedAttribute(definedAttribute).definedNextAttribute(definedNextAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;

      var area = function area(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;
          baseValueAttribute.value(function (d, i) {
            return yScale.scale(base.baseValue()(d, i));
          }).data(data);
          mainValueAttribute.value(function (d, i) {
            return yScale.scale(base.mainValue()(d, i));
          }).data(data);
        }

        draw.xScale(xScale.webglScale).yScale(yScale.webglScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      area.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return area;
      };

      area.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return area;
      };

      d3fcRebind.rebindAll(area, base, d3fcRebind.exclude('bandwidth', 'align'));
      d3fcRebind.rebind(area, draw, 'context');
      return area;
    });

    var ohlcBase = (function () {
      var base;

      var crossValue = function crossValue(d) {
        return d.date;
      };

      var openValue = function openValue(d) {
        return d.open;
      };

      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var closeValue = function closeValue(d) {
        return d.close;
      };

      var bandwidth = function bandwidth() {
        return 5;
      };

      var align = 'center';

      var crossValueScaled = function crossValueScaled(d, i) {
        return base.xScale()(crossValue(d, i));
      };

      base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(crossValue, openValue, lowValue, highValue, closeValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var closeRaw = closeValue(d, i);
        var openRaw = openValue(d, i);
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var direction = '';

        if (closeRaw > openRaw) {
          direction = 'up';
        } else if (closeRaw < openRaw) {
          direction = 'down';
        }

        return {
          cross: crossValueScaled(d, i) + offset,
          open: base.yScale()(openRaw),
          high: base.yScale()(highValue(d, i)),
          low: base.yScale()(lowValue(d, i)),
          close: base.yScale()(closeRaw),
          width: width,
          direction: direction
        };
      };

      base.xValues = function () {
        return [crossValue];
      };

      base.yValues = function () {
        return [openValue, highValue, lowValue, closeValue];
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.openValue = function () {
        if (!arguments.length) {
          return openValue;
        }

        openValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.yValue = base.closeValue = function () {
        if (!arguments.length) {
          return closeValue;
        }

        closeValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var ohlcBase$1 = (function (pathGenerator, seriesName) {
      var base = ohlcBase();
      var join = d3fcDataJoin.dataJoin('g', seriesName);

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.cross + ', ' + values.high + ')';
      };

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var candlestick = function candlestick(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          g.each(function (d, i, g) {
            var values = base.values(d, i);
            var color = values.direction === 'up' ? colors.green : colors.red;
            var singleCandlestick = transitionPropagator(d3Selection.select(g[i])).attr('class', seriesName + ' ' + values.direction).attr('stroke', color).attr('fill', color).attr('transform', function () {
              return containerTranslation(values) + ' scale(1)';
            });
            pathGenerator.x(0).width(values.width).open(function () {
              return values.open - values.high;
            }).high(0).low(function () {
              return values.low - values.high;
            }).close(function () {
              return values.close - values.high;
            });
            singleCandlestick.select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      d3fcRebind.rebind(candlestick, join, 'key');
      d3fcRebind.rebindAll(candlestick, base);
      return candlestick;
    });

    var candlestick = (function () {
      return ohlcBase$1(d3fcShape.shapeCandlestick(), 'candlestick');
    });

    var ohlcBase$2 = (function (pathGenerator) {
      var base = ohlcBase();

      var candlestick = function candlestick(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.cross, values.high);
          context.beginPath();
          pathGenerator.x(0).open(function () {
            return values.open - values.high;
          }).width(values.width).high(0).low(function () {
            return values.low - values.high;
          }).close(function () {
            return values.close - values.high;
          })([d]);
          var color = values.direction === 'up' ? colors.green : colors.red;
          context.strokeStyle = color;
          context.fillStyle = color;
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      d3fcRebind.rebind(candlestick, pathGenerator, 'context');
      d3fcRebind.rebindAll(candlestick, base);
      return candlestick;
    });

    var candlestick$1 = (function () {
      return ohlcBase$2(d3fcShape.shapeCandlestick());
    });

    var ohlcBase$3 = (function (pathGenerator) {
      var base = ohlcBase();
      var crossValueAttribute = d3fcWebgl.webglAttribute();
      var openValueAttribute = d3fcWebgl.webglAttribute();
      var highValueAttribute = d3fcWebgl.webglAttribute();
      var lowValueAttribute = d3fcWebgl.webglAttribute();
      var closeValueAttribute = d3fcWebgl.webglAttribute();
      var bandwidthAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_SHORT);
      var definedAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      pathGenerator.crossValueAttribute(crossValueAttribute).openValueAttribute(openValueAttribute).highValueAttribute(highValueAttribute).lowValueAttribute(lowValueAttribute).closeValueAttribute(closeValueAttribute).bandwidthAttribute(bandwidthAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;

      var candlestick = function candlestick(data) {
        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;
          openValueAttribute.value(function (d, i) {
            return yScale.scale(base.openValue()(d, i));
          }).data(data);
          highValueAttribute.value(function (d, i) {
            return yScale.scale(base.highValue()(d, i));
          }).data(data);
          lowValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowValue()(d, i));
          }).data(data);
          closeValueAttribute.value(function (d, i) {
            return yScale.scale(base.closeValue()(d, i));
          }).data(data);
        }

        pathGenerator.xScale(xScale.webglScale).yScale(yScale.webglScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        pathGenerator(data.length);
      };

      candlestick.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return candlestick;
      };

      candlestick.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return candlestick;
      };

      d3fcRebind.rebindAll(candlestick, base, d3fcRebind.exclude('align'));
      d3fcRebind.rebind(candlestick, pathGenerator, 'context', 'lineWidth');
      return candlestick;
    });

    var candlestick$2 = (function () {
      return ohlcBase$3(d3fcWebgl.webglSeriesCandlestick());
    });

    var boxPlotBase = (function () {
      var upperQuartileValue = function upperQuartileValue(d) {
        return d.upperQuartile;
      };

      var lowerQuartileValue = function lowerQuartileValue(d) {
        return d.lowerQuartile;
      };

      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var crossValue = function crossValue(d) {
        return d.value;
      };

      var medianValue = function medianValue(d) {
        return d.median;
      };

      var orient = 'vertical';
      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(lowValue, highValue, lowerQuartileValue, upperQuartileValue, crossValue, medianValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(highValue(d, i));
          return {
            origin: [xScale(crossValue(d, i)) + offset, y],
            high: 0,
            upperQuartile: yScale(upperQuartileValue(d, i)) - y,
            median: yScale(medianValue(d, i)) - y,
            lowerQuartile: yScale(lowerQuartileValue(d, i)) - y,
            low: yScale(lowValue(d, i)) - y,
            width: width
          };
        } else {
          var x = xScale(lowValue(d, i));
          return {
            origin: [x, yScale(crossValue(d, i)) + offset],
            high: xScale(highValue(d, i)) - x,
            upperQuartile: xScale(upperQuartileValue(d, i)) - x,
            median: xScale(medianValue(d, i)) - x,
            lowerQuartile: xScale(lowerQuartileValue(d, i)) - x,
            low: 0,
            width: width
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [upperQuartileValue, lowerQuartileValue, highValue, lowValue, medianValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [upperQuartileValue, lowerQuartileValue, highValue, lowValue, medianValue];
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowerQuartileValue = function () {
        if (!arguments.length) {
          return lowerQuartileValue;
        }

        lowerQuartileValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.upperQuartileValue = function () {
        if (!arguments.length) {
          return upperQuartileValue;
        }

        upperQuartileValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.medianValue = function () {
        if (!arguments.length) {
          return medianValue;
        }

        medianValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var boxPlot = (function () {
      var base = boxPlotBase();
      var join = d3fcDataJoin.dataJoin('g', 'box-plot');
      var pathGenerator = d3fcShape.shapeBoxPlot().value(0);

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.origin[0] + ', ' + values.origin[1] + ')';
      };

      var boxPlot = function boxPlot(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('stroke', colors.black).attr('fill', colors.gray).attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          pathGenerator.orient(base.orient());
          g.each(function (d, i, g) {
            var values = base.values(d, i);
            pathGenerator.median(values.median).upperQuartile(values.upperQuartile).lowerQuartile(values.lowerQuartile).width(values.width).high(values.high).low(values.low);
            transitionPropagator(d3Selection.select(g[i])).attr('transform', containerTranslation(values)).select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      d3fcRebind.rebindAll(boxPlot, base);
      d3fcRebind.rebind(boxPlot, join, 'key');
      d3fcRebind.rebind(boxPlot, pathGenerator, 'cap');
      return boxPlot;
    });

    var boxPlot$1 = (function () {
      var base = boxPlotBase();
      var pathGenerator = d3fcShape.shapeBoxPlot().value(0);

      var boxPlot = function boxPlot(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        pathGenerator.orient(base.orient());
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.fillStyle = colors.gray;
          context.strokeStyle = colors.black;
          base.decorate()(context, d, i);
          pathGenerator.median(values.median).upperQuartile(values.upperQuartile).lowerQuartile(values.lowerQuartile).high(values.high).width(values.width).low(values.low)([d]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      d3fcRebind.rebindAll(boxPlot, base);
      d3fcRebind.rebind(boxPlot, pathGenerator, 'cap', 'context');
      return boxPlot;
    });

    var boxPlot$2 = (function () {
      var base = boxPlotBase();
      var crossValueAttribute = d3fcWebgl.webglAttribute();
      var highValueAttribute = d3fcWebgl.webglAttribute();
      var upperQuartileValueAttribute = d3fcWebgl.webglAttribute();
      var medianValueAttribute = d3fcWebgl.webglAttribute();
      var lowerQuartileValueAttribute = d3fcWebgl.webglAttribute();
      var lowValueAttribute = d3fcWebgl.webglAttribute();
      var bandwidthAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_SHORT);
      var capAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_SHORT);
      var definedAttribute = d3fcWebgl.webglAttribute().type(d3fcWebgl.webglTypes.UNSIGNED_BYTE);
      var draw = d3fcWebgl.webglSeriesBoxPlot().crossValueAttribute(crossValueAttribute).highValueAttribute(highValueAttribute).upperQuartileValueAttribute(upperQuartileValueAttribute).medianValueAttribute(medianValueAttribute).lowerQuartileValueAttribute(lowerQuartileValueAttribute).lowValueAttribute(lowValueAttribute).bandwidthAttribute(bandwidthAttribute).capAttribute(capAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var scaleMapper = d3fcWebgl.webglScaleMapper;
      var previousData = [];
      var previousXScale = null;
      var previousYScale = null;
      var cap = functor(20);

      var boxPlot = function boxPlot(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = scaleMapper(base.xScale());
        var yScale = scaleMapper(base.yScale());
        var dataChanged = !equals(previousData, data);

        if (dataChanged) {
          previousData = data;
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          capAttribute.value(function (d, i) {
            return cap(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        if (dataChanged || xScale.scale !== previousXScale) {
          previousXScale = xScale.scale;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
        }

        if (dataChanged || yScale.scale !== previousYScale) {
          previousYScale = yScale.scale;
          highValueAttribute.value(function (d, i) {
            return yScale.scale(base.highValue()(d, i));
          }).data(data);
          upperQuartileValueAttribute.value(function (d, i) {
            return yScale.scale(base.upperQuartileValue()(d, i));
          }).data(data);
          medianValueAttribute.value(function (d, i) {
            return yScale.scale(base.medianValue()(d, i));
          }).data(data);
          lowerQuartileValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowerQuartileValue()(d, i));
          }).data(data);
          lowValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowValue()(d, i));
          }).data(data);
        }

        draw.xScale(xScale.webglScale).yScale(yScale.webglScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      boxPlot.cap = function () {
        if (!arguments.length) {
          return cap;
        }

        cap = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return boxPlot;
      };

      boxPlot.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return boxPlot;
      };

      boxPlot.scaleMapper = function () {
        if (!arguments.length) {
          return scaleMapper;
        }

        scaleMapper = arguments.length <= 0 ? undefined : arguments[0];
        return boxPlot;
      };

      d3fcRebind.rebindAll(boxPlot, base, d3fcRebind.exclude('align'));
      d3fcRebind.rebind(boxPlot, draw, 'context', 'lineWidth');
      return boxPlot;
    });

    var ohlc = (function () {
      return ohlcBase$1(d3fcShape.shapeOhlc(), 'ohlc');
    });

    var ohlc$1 = (function () {
      return ohlcBase$2(d3fcShape.shapeOhlc());
    });

    var ohlc$2 = (function () {
      return ohlcBase$3(d3fcWebgl.webglSeriesOhlc());
    });

    var multiBase = (function () {
      var series = [];

      var mapping = function mapping(d) {
        return d;
      };

      var key = function key(_, i) {
        return i;
      };

      var multi = createBase({
        decorate: function decorate() {},
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      multi.xValues = function () {
        return series.map(function (s) {
          return s.xValues();
        }).reduce(function (a, b) {
          return a.concat(b);
        });
      };

      multi.yValues = function () {
        return series.map(function (s) {
          return s.yValues();
        }).reduce(function (a, b) {
          return a.concat(b);
        });
      };

      multi.mapping = function () {
        if (!arguments.length) {
          return mapping;
        }

        mapping = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      multi.key = function () {
        if (!arguments.length) {
          return key;
        }

        key = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      multi.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      return multi;
    });

    var multiSeries = (function () {
      var base = multiBase();
      var innerJoin = d3fcDataJoin.dataJoin('g');
      var join = d3fcDataJoin.dataJoin('g', 'multi');

      var multi = function multi(selection) {
        if (selection.selection) {
          join.transition(selection);
          innerJoin.transition(selection);
        }

        var mapping = base.mapping();
        var series = base.series();
        var xScale = base.xScale();
        var yScale = base.yScale();
        selection.each(function (data, index, group) {
          var container = join(d3Selection.select(group[index]), series); // iterate over the containers, 'call'-ing the series for each

          container.each(function (dataSeries, seriesIndex, seriesGroup) {
            dataSeries.xScale(xScale).yScale(yScale);
            var seriesData = mapping(data, seriesIndex, series);
            var innerContainer = innerJoin(d3Selection.select(seriesGroup[seriesIndex]), [seriesData]);
            innerContainer.call(dataSeries);
          });
          var unwrappedSelection = container.selection ? container.selection() : container;
          unwrappedSelection.order();
          base.decorate()(container, data, index);
        });
      };

      d3fcRebind.rebindAll(multi, base);
      d3fcRebind.rebind(multi, join, 'key');
      return multi;
    });

    var multiSeries$1 = (function () {
      var context = null;
      var base = multiBase();

      var multi = function multi(data) {
        var mapping = base.mapping();
        var series = base.series();
        var xScale = base.xScale();
        var yScale = base.yScale();
        series.forEach(function (dataSeries, index) {
          var seriesData = mapping(data, index, series);
          dataSeries.context(context).xScale(xScale).yScale(yScale);
          var adaptedDecorate;

          if (dataSeries.decorate) {
            adaptedDecorate = dataSeries.decorate();
            dataSeries.decorate(function (c, d, i) {
              base.decorate()(c, data, index);
              adaptedDecorate(c, d, i);
            });
          } else {
            base.decorate()(context, data, index);
          }

          dataSeries(seriesData);

          if (adaptedDecorate) {
            dataSeries.decorate(adaptedDecorate);
          }
        });
      };

      multi.context = function () {
        if (!arguments.length) {
          return context;
        }

        context = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      d3fcRebind.rebindAll(multi, base);
      return multi;
    });

    var groupedBase = (function (series) {
      var bandwidth = function bandwidth() {
        return 50;
      };

      var align = 'center'; // the offset scale is used to offset each of the series within a group

      var offsetScale = d3Scale.scaleBand();
      var grouped = createBase({
        decorate: function decorate() {},
        xScale: d3Scale.scaleLinear(),
        yScale: d3Scale.scaleLinear()
      }); // the bandwidth for the grouped series can be a function of datum / index. As a result
      // the offset scale required to cluster the 'sub' series is also dependent on datum / index.
      // This function computes the offset scale for a specific datum / index of the grouped series

      grouped.offsetScaleForDatum = function (data, d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var halfWidth = width / 2;
        return offsetScale.domain(d3Array.range(0, data.length)).range([-halfWidth + offset, halfWidth + offset]);
      };

      grouped.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return grouped;
      };

      grouped.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return grouped;
      };

      d3fcRebind.rebindAll(grouped, offsetScale, d3fcRebind.includeMap({
        'paddingInner': 'paddingOuter'
      }));
      return grouped;
    });

    var grouped = (function (series) {
      var base = groupedBase();
      var join = d3fcDataJoin.dataJoin('g', 'grouped');

      var grouped = function grouped(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var g = join(d3Selection.select(group[index]), data);
          g.enter().append('g');
          g.select('g').each(function (_, index, group) {
            var container = d3Selection.select(group[index]); // create a composite scale that applies the required offset

            var isVertical = series.orient() !== 'horizontal';

            var compositeScale = function compositeScale(d, i) {
              var offset = base.offsetScaleForDatum(data, d, i);
              var baseScale = isVertical ? base.xScale() : base.yScale();
              return baseScale(d) + offset(index) + offset.bandwidth() / 2;
            };

            if (isVertical) {
              series.xScale(compositeScale);
              series.yScale(base.yScale());
            } else {
              series.yScale(compositeScale);
              series.xScale(base.xScale());
            } // if the sub-series has a bandwidth, set this from the offset scale


            if (series.bandwidth) {
              series.bandwidth(function (d, i) {
                return base.offsetScaleForDatum(data, d, i).bandwidth();
              });
            } // adapt the decorate function to give each series the correct index


            series.decorate(function (s, d) {
              return base.decorate()(s, d, index);
            });
            container.call(series);
          });
        });
      };

      d3fcRebind.rebindAll(grouped, series, d3fcRebind.exclude('decorate', 'xScale', 'yScale'));
      d3fcRebind.rebindAll(grouped, base, d3fcRebind.exclude('offsetScaleForDatum'));
      return grouped;
    });

    function grouped$1 (series) {
      var base = groupedBase();

      var grouped = function grouped(data) {
        data.forEach(function (seriesData, index) {
          // create a composite scale that applies the required offset
          var isVertical = series.orient() !== 'horizontal';

          var compositeScale = function compositeScale(d, i) {
            var offset = base.offsetScaleForDatum(data, d, i);
            var baseScale = isVertical ? base.xScale() : base.yScale();
            return baseScale(d) + offset(index) + offset.bandwidth() / 2;
          };

          if (isVertical) {
            series.xScale(compositeScale);
            series.yScale(base.yScale());
          } else {
            series.yScale(compositeScale);
            series.xScale(base.xScale());
          } // if the sub-series has a bandwidth, set this from the offset scale


          if (series.bandwidth) {
            series.bandwidth(function (d, i) {
              return base.offsetScaleForDatum(data, d, i).bandwidth();
            });
          } // adapt the decorate function to give each series the correct index


          series.decorate(function (c, d) {
            return base.decorate()(c, d, index);
          });
          series(seriesData);
        });
      };

      d3fcRebind.rebindAll(grouped, series, d3fcRebind.exclude('decorate', 'xScale', 'yScale'));
      d3fcRebind.rebindAll(grouped, base, d3fcRebind.exclude('offsetScaleForDatum'));
      return grouped;
    }

    var repeat = (function () {
      var orient = 'vertical';
      var series = line();
      var multi = multiSeries();

      var repeat = function repeat(selection) {
        return selection.each(function (data, index, group) {
          if (orient === 'vertical') {
            multi.series(data[0].map(function (_) {
              return series;
            })).mapping(function (data, index) {
              return data.map(function (d) {
                return d[index];
              });
            });
          } else {
            multi.series(data.map(function (_) {
              return series;
            })).mapping(function (data, index) {
              return data[index];
            });
          }

          d3Selection.select(group[index]).call(multi);
        });
      };

      repeat.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      d3fcRebind.rebindAll(repeat, multi, d3fcRebind.exclude('series', 'mapping'));
      return repeat;
    });

    var repeat$1 = (function () {
      var orient = 'vertical';
      var series = line$1();
      var multi = multiSeries$1();

      var repeat = function repeat(data) {
        if (orient === 'vertical') {
          multi.series(data[0].map(function (_) {
            return series;
          })).mapping(function (data, index) {
            return data.map(function (d) {
              return d[index];
            });
          });
        } else {
          multi.series(data.map(function (_) {
            return series;
          })).mapping(function (data, index) {
            return data[index];
          });
        }

        multi(data);
      };

      repeat.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      d3fcRebind.rebindAll(repeat, multi, d3fcRebind.exclude('series', 'mapping'));
      return repeat;
    });

    var repeat$2 = (function () {
      var orient = 'vertical';

      var series = function series() {
        return line$2();
      };

      var multi = multiSeries$1();
      var seriesCache = [];

      var repeat = function repeat(data) {
        if (orient === 'vertical') {
          var previousSeriesCache = seriesCache;
          seriesCache = data[0].map(function (d, i) {
            return i < previousSeriesCache.length ? previousSeriesCache[i] : series();
          });
          multi.series(seriesCache).mapping(function (data, index) {
            return data.map(function (d) {
              return d[index];
            });
          });
        } else {
          var _previousSeriesCache = seriesCache;
          seriesCache = data.map(function (d, i) {
            return i < _previousSeriesCache.length ? _previousSeriesCache[i] : series();
          });
          multi.series(seriesCache).mapping(function (data, index) {
            return data[index];
          });
        }

        multi(data);
      };

      repeat.series = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!args.length) {
          return series;
        }

        if (typeof args[0].xScale === 'function' && typeof args[0].yScale === 'function') {
          series = function series() {
            return args[0];
          };
        } else {
          series = args[0];
        }

        seriesCache = [];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        seriesCache = [];
        return repeat;
      };

      d3fcRebind.rebindAll(repeat, multi, d3fcRebind.exclude('series', 'mapping'));
      return repeat;
    });

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    var sortUnique = function sortUnique(arr) {
      return arr.sort(d3Array.ascending).filter(function (value, index, self) {
        return self.indexOf(value, index + 1) === -1;
      });
    };

    var autoBandwidth = (function (adaptee) {
      var widthFraction = 0.75; // computes the bandwidth as a fraction of the smallest distance between the datapoints

      var computeBandwidth = function computeBandwidth(screenValues) {
        // return some default value if there are not enough datapoints to compute the width
        if (screenValues.length <= 1) {
          return 10;
        }

        screenValues = sortUnique(screenValues); // compute the distance between neighbouring items

        var neighbourDistances = d3Array.pairs(screenValues).map(function (tuple) {
          return Math.abs(tuple[0] - tuple[1]);
        });
        var minDistance = d3Array.min(neighbourDistances);
        return widthFraction * minDistance;
      };

      var determineBandwith = function determineBandwith(crossScale, data, accessor) {
        // if the cross-scale has a bandwidth function, i.e. it is a scaleBand, use
        // this to determine the width
        if (crossScale.bandwidth) {
          return crossScale.bandwidth();
        } else {
          var _ref;

          // grouped series expect a nested array, which is flattened out
          var flattenedData = Array.isArray(data) ? (_ref = []).concat.apply(_ref, _toConsumableArray(data)) : data; // obtain an array of points along the crossValue axis, mapped to screen coordinates.

          var crossValuePoints = flattenedData.filter(adaptee.defined()).map(accessor()).map(crossScale);
          var width = computeBandwidth(crossValuePoints);
          return width;
        }
      };

      var autoBandwidth = function autoBandwidth(arg) {
        var computeWidth = function computeWidth(data) {
          if (adaptee.xBandwidth && adaptee.yBandwidth) {
            adaptee.xBandwidth(determineBandwith(adaptee.xScale(), data, adaptee.xValue));
            adaptee.yBandwidth(determineBandwith(adaptee.yScale(), data, adaptee.yValue));
          } else {
            // if the series has an orient property, use this to determine the cross-scale, otherwise
            // assume it is the x-scale
            var crossScale = adaptee.orient && adaptee.orient() === 'horizontal' ? adaptee.yScale() : adaptee.xScale();
            adaptee.bandwidth(determineBandwith(crossScale, data, adaptee.crossValue));
          }
        };

        if (arg instanceof d3Selection.selection) {
          arg.each(function (data, index, group) {
            computeWidth(data);
            adaptee(d3Selection.select(group[index]));
          });
        } else {
          computeWidth(arg);
          adaptee(arg);
        }
      };

      d3fcRebind.rebindAll(autoBandwidth, adaptee);

      autoBandwidth.widthFraction = function () {
        if (!arguments.length) {
          return widthFraction;
        }

        widthFraction = arguments.length <= 0 ? undefined : arguments[0];
        return autoBandwidth;
      };

      return autoBandwidth;
    });

    var heatmapBase = (function () {
      var xValue = function xValue(d) {
        return d.x;
      };

      var yValue = function yValue(d) {
        return d.y;
      };

      var colorValue = function colorValue(d) {
        return d.color;
      };

      var yBandwidth = function yBandwidth() {
        return 5;
      };

      var xBandwidth = function xBandwidth() {
        return 5;
      };

      var colorInterpolate = d3ScaleChromatic.interpolateViridis;
      var heatmap = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(xValue, yValue, colorValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });
      heatmap.pathGenerator = d3fcShape.shapeBar().x(0).y(0);

      heatmap.colorScale = function (data) {
        var colorValues = data.map(colorValue); // a scale that maps the color values onto a unit range, [0, 1]

        return d3Scale.scaleLinear().domain([d3Array.min(colorValues), d3Array.max(colorValues)]);
      };

      heatmap.values = function (d, i) {
        return {
          x: heatmap.xScale()(xValue(d, i)),
          y: heatmap.yScale()(yValue(d, i)),
          colorValue: colorValue(d, i),
          width: xBandwidth(d, i),
          height: yBandwidth(d, i)
        };
      };

      heatmap.xValues = function () {
        return [xValue];
      };

      heatmap.yValues = function () {
        return [yValue];
      };

      heatmap.xValue = function () {
        if (!arguments.length) {
          return xValue;
        }

        xValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.yValue = function () {
        if (!arguments.length) {
          return yValue;
        }

        yValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.colorValue = function () {
        if (!arguments.length) {
          return colorValue;
        }

        colorValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.colorInterpolate = function () {
        if (!arguments.length) {
          return colorInterpolate;
        }

        colorInterpolate = arguments.length <= 0 ? undefined : arguments[0];
        return heatmap;
      };

      heatmap.xBandwidth = function () {
        if (!arguments.length) {
          return xBandwidth;
        }

        xBandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.yBandwidth = function () {
        if (!arguments.length) {
          return yBandwidth;
        }

        yBandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      d3fcRebind.rebindAll(heatmap, heatmap.pathGenerator, d3fcRebind.includeMap({
        'horizontalAlign': 'xAlign',
        'verticalAlign': 'yAlign'
      }));
      return heatmap;
    });

    var heatmap = (function () {
      var base = heatmapBase();
      var join = d3fcDataJoin.dataJoin('g', 'box');

      var containerTransform = function containerTransform(values) {
        return 'translate(' + values.x + ', ' + values.y + ')';
      };

      var heatmap = function heatmap(selection) {
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var colorValue = base.colorValue();
          var colorInterpolate = base.colorInterpolate();
          var colorScale = base.colorScale(filteredData);
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().append('path').attr('stroke', 'transparent');
          g.attr('transform', function (d, i) {
            return containerTransform(base.values(d, i));
          }).select('path').attr('d', function (d, i) {
            return base.pathGenerator.width(base.values(d, i).width).height(base.values(d, i).height)([d]);
          }).attr('fill', function (d, i) {
            return colorInterpolate(colorScale(colorValue(d, i)));
          });
          base.decorate()(g, data, index);
        });
      };

      d3fcRebind.rebindAll(heatmap, base);
      return heatmap;
    });

    var heatmap$1 = (function () {
      var base = heatmapBase();

      var heatmap = function heatmap(data) {
        var filteredData = data.filter(base.defined());
        var colorInterpolate = base.colorInterpolate();
        var colorScale = base.colorScale(filteredData);
        var context = base.pathGenerator.context();
        filteredData.forEach(function (d, i) {
          context.save();
          context.beginPath();
          var values = base.values(d, i);
          context.translate(values.x, values.y);
          context.fillStyle = colorInterpolate(colorScale(values.colorValue));
          context.strokeStyle = 'transparent';
          base.decorate()(context, d, i);
          base.pathGenerator.height(values.height).width(values.width)([d]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      d3fcRebind.rebind(heatmap, base.pathGenerator, 'context');
      d3fcRebind.rebindAll(heatmap, base);
      return heatmap;
    });

    exports.autoBandwidth = autoBandwidth;
    exports.seriesCanvasArea = area$1;
    exports.seriesCanvasBar = bar$1;
    exports.seriesCanvasBoxPlot = boxPlot$1;
    exports.seriesCanvasCandlestick = candlestick$1;
    exports.seriesCanvasErrorBar = errorBar$1;
    exports.seriesCanvasGrouped = grouped$1;
    exports.seriesCanvasHeatmap = heatmap$1;
    exports.seriesCanvasLine = line$1;
    exports.seriesCanvasMulti = multiSeries$1;
    exports.seriesCanvasOhlc = ohlc$1;
    exports.seriesCanvasPoint = point$1;
    exports.seriesCanvasRepeat = repeat$1;
    exports.seriesSvgArea = area;
    exports.seriesSvgBar = bar;
    exports.seriesSvgBoxPlot = boxPlot;
    exports.seriesSvgCandlestick = candlestick;
    exports.seriesSvgErrorBar = errorBar;
    exports.seriesSvgGrouped = grouped;
    exports.seriesSvgHeatmap = heatmap;
    exports.seriesSvgLine = line;
    exports.seriesSvgMulti = multiSeries;
    exports.seriesSvgOhlc = ohlc;
    exports.seriesSvgPoint = point;
    exports.seriesSvgRepeat = repeat;
    exports.seriesWebglArea = area$2;
    exports.seriesWebglBar = bar$2;
    exports.seriesWebglBoxPlot = boxPlot$2;
    exports.seriesWebglCandlestick = candlestick$2;
    exports.seriesWebglErrorBar = errorBar$2;
    exports.seriesWebglLine = line$2;
    exports.seriesWebglMulti = multiSeries$1;
    exports.seriesWebglOhlc = ohlc$2;
    exports.seriesWebglPoint = point$2;
    exports.seriesWebglRepeat = repeat$2;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
