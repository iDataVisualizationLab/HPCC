(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@d3fc/d3fc-rebind"),require("d3-scale"),require("d3-shape")):"function"==typeof define&&define.amd?define(["exports","@d3fc/d3fc-rebind","d3-scale","d3-shape"],t):(e=e||self,t(e.fc=e.fc||{},e.fc,e.d3,e.d3))})(this,function(e,t,a,r){'use strict';var n=Math.abs;function i(e){switch(e){case Z.BYTE:case Z.UNSIGNED_BYTE:return 1;case Z.SHORT:case Z.UNSIGNED_SHORT:return 2;case Z.FLOAT:return 4;default:throw new Error("Unknown type ".concat(e));}}function o(e){switch(e){case Z.BYTE:return Int8Array;case Z.UNSIGNED_BYTE:return Uint8Array;case Z.SHORT:return Int16Array;case Z.UNSIGNED_SHORT:return Uint16Array;case Z.FLOAT:return Float32Array;default:throw new Error("Unknown type ".concat(e));}}var l=function(){var e=[0,1],t=[-1,1],a=function(){};return a.domain=function(){return arguments.length?(e=0>=arguments.length?void 0:arguments[0],a):e},a.range=function(){return arguments.length?(t=0>=arguments.length?void 0:arguments[0],a):t},a},d=function(){var e={},t={},a=null,r=function(r,i){var o=r.context();Object.keys(e).forEach(function(t){var a=e[t];if("function"!=typeof a)throw new Error("Expected an attribute for ".concat(t,", found ").concat(a));var n=o.getAttribLocation(i,t);a.location(n)(r)}),Object.keys(t).forEach(function(e){var a=t[e];if("function"!=typeof a)throw new Error("Expected a uniform for ".concat(e,", found ").concat(a));var n=o.getUniformLocation(i,e);a.location(n)(r)}),null!==a&&a(r)};return r.flush=function(){Object.values(e).forEach(function(e){return e.clear()}),Object.values(t).forEach(function(e){return e.clear()}),null!==a&&a.clear()},r.attribute=function(){for(var t=arguments.length,a=Array(t),i=0;i<t;i++)a[i]=arguments[i];return 1===a.length?e[a[0]]:(e[a[0]]=a[1],r)},r.uniform=function(){for(var e=arguments.length,a=Array(e),i=0;i<e;i++)a[i]=arguments[i];return 1===a.length?t[a[0]]:(t[a[0]]=a[1],r)},r.elementIndices=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],r):a},r},f=function(e){var t=-1,a=e,r=!0,i=function(e){if(r){var i=e.context();if(Array.isArray(a))switch(a.length){case 1:i.uniform1fv(t,a);break;case 2:i.uniform2fv(t,a);break;case 3:i.uniform3fv(t,a);break;case 4:i.uniform4fv(t,a);break;default:throw new Error("Uniform supports up to 4 elements. ".concat(a.length," provided."));}else i.uniform1f(t,a);r=!1}};return i.clear=function(){r=!0},i.location=function(){return arguments.length?(t!==(0>=arguments.length?void 0:arguments[0])&&(t=0>=arguments.length?void 0:arguments[0],r=!0),i):t},i.data=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],r=!0,i):a},i},u={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},s=function(){function e(e,t,a){return!e||y||t!==l||a!==s}function t(e,t){var i=a(e,r.VERTEX_SHADER),o=a(t,r.FRAGMENT_SHADER),n=r.createProgram();if(r.attachShader(n,i),r.attachShader(n,o),r.linkProgram(n),h&&!r.getProgramParameter(n,r.LINK_STATUS)){var l=r.getProgramInfoLog(n);throw r.deleteProgram(n),new Error("Failed to link program : ".concat(l,"\n            Vertex Shader : ").concat(e,"\n            Fragment Shader : ").concat(t))}return n}function a(e,t){var a=r.createShader(t);if(r.shaderSource(a,e),r.compileShader(a),h&&!r.getShaderParameter(a,r.COMPILE_STATUS)){var i=r.getShaderInfoLog(a);throw r.deleteShader(a),new Error("Failed to compile shader : ".concat(i,"\n            Shader : ").concat(e))}return a}var r=null,i=null,o=null,n=null,l=null,s=null,c=u.TRIANGLES,b=0,g=d(),h=!1,v=null,y=!0,x=function a(d){if(null!=r){var u=o(),h=n();if(e(i,u,h)&&(i=t(u,h),l=u,s=h,y=!1),r.useProgram(i),g.uniform("uScreen",f([r.canvas.width,r.canvas.height])),g(a,i),0===b)null==g.elementIndices()?r.drawArrays(c,0,d):r.drawElements(c,d,r.UNSIGNED_SHORT,0);else if(null==g.elementIndices())v.drawArraysInstancedANGLE(c,0,b,d);else{var x=g.elementIndices().data().length;if(b!==x)throw new Error("Expected elementIndices length ".concat(x)+" to match subInstanceCount ".concat(b,"."));v.drawElementsInstancedANGLE(c,b,r.UNSIGNED_SHORT,0,d)}}};return x.extInstancedArrays=function(){return v},x.context=function(){for(var e=arguments.length,t=Array(e),a=0;a<e;a++)t[a]=arguments[a];return t.length?((null==t[0]||t[0]!==r)&&(g.flush(),y=!0),null!=t[0]&&t[0]!==r&&(v=t[0].getExtension("ANGLE_instanced_arrays")),r=t[0],x):r},x.buffers=function(){return arguments.length?(g=0>=arguments.length?void 0:arguments[0],x):g},x.vertexShader=function(){return arguments.length?(o=0>=arguments.length?void 0:arguments[0],x):o},x.fragmentShader=function(){return arguments.length?(n=0>=arguments.length?void 0:arguments[0],x):n},x.mode=function(){return arguments.length?(c=0>=arguments.length?void 0:arguments[0],x):c},x.subInstanceCount=function(){return arguments.length?(b=0>=arguments.length?void 0:arguments[0],x):b},x.debug=function(){return arguments.length?(h=0>=arguments.length?void 0:arguments[0],x):h},x},c=function(e){function t(e,t){e.push(t)}function a(e,t,a){var r=e.indexOf(a);e.splice(0<=r?r:e.length,0,t)}function r(e,t){var a=e.indexOf(t);-1===a&&e.push(t)}var i=[],o=[],n=function(){return e(i.join("\n"),o.join("\n"))};return n.appendHeader=function(e){return t(i,e),n},n.insertHeader=function(e,t){return a(i,e,t),n},n.appendHeaderIfNotExists=function(e){return r(i,e),n},n.appendBody=function(e){return t(o,e),n},n.insertBody=function(e,t){return a(o,e,t),n},n.appendBodyIfNotExists=function(e){return r(o,e),n},n},b=function(e,t){return"\nprecision mediump float;\nfloat inf = 1.0 / 0.0;\n".concat(e,"\nvoid main() {\n    ").concat(t,"\n}")},g=function(e,t){return"\nprecision mediump float;\n".concat(e,"\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ").concat(t,"\n}")},h={header:"attribute vec4 aFillColor;\n             varying vec4 vFillColor;",body:"vFillColor = aFillColor;"},v={header:"attribute vec4 aStrokeColor;\n             varying vec4 vStrokeColor;",body:"vStrokeColor = aStrokeColor;"},y={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = 2.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},x={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = 4.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},p={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},m={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},S={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = 2.0 * (vSize + uStrokeWidth + 1.0);\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},V={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = sqrt((16.0 * aSize) / (3.0 * sqrt(3.0)));\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},C={header:"\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 5.0);\n        vStrokeWidthRatio = uStrokeWidth / (vSize + uStrokeWidth + 1.0);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"},D={header:"\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n         (isPositiveY * isExtremeY * aLowValue) +\n         (isPositiveY * isNotExtremeY * aCloseValue) +\n         (isNotPositiveY * isNotExtremeY * aOpenValue) +\n         (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = (isNotExtremeY * aCorner.x) + (isExtremeY * aCorner.z);\n        float lineWidthYDirection = isNotExtremeY * sign(aCloseValue - aOpenValue) * aCorner.y;\n\n        float bandwidthModifier = aBandwidth * aCorner.x / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"},N={header:"\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n            (isPositiveY * isExtremeY * aLowValue) +\n            (isPositiveY * isNotExtremeY * aCloseValue) +\n            (isNotPositiveY * isNotExtremeY * aOpenValue) +\n            (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = isExtremeY * aCorner.z;\n        float lineWidthYDirection = isNotExtremeY * aCorner.z;\n\n        float bandwidthModifier = isNotExtremeY * aCorner.x * aBandwidth / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"},E={header:"\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aMainValue;\n        attribute float aBaseValue;\n        attribute vec2 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        float isBaseline = (1.0 - aCorner.y) / 2.0;\n        float yValue = (isBaseline * aBaseValue) + ((1.0 - isBaseline) * aMainValue);\n\n        float xModifier = aCorner.x * (aBandwidth) / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"},A={header:"\n        attribute vec3 aCorner;\n        attribute float aCrossNextNextValue;\n        attribute float aMainNextNextValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossPrevValue;\n        attribute float aMainPrevValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        uniform float uStrokeWidth;\n        uniform vec2 uScreen;\n\n        varying float vDefined;",body:"\n        vDefined = aDefined * aDefinedNext;\n        vec4 prev = vec4(aCrossPrevValue, aMainPrevValue, 0, 0);\n        vec4 curr = vec4(aCrossValue, aMainValue, 0, 0);\n        gl_Position = vec4(aCrossNextValue, aMainNextValue, 0, 1);\n        vec4 nextNext = vec4(aCrossNextNextValue, aMainNextNextValue, 0, 0);"},P={body:"\n        vec4 currVertexPosition = gl_Position;\n        vec4 nextVertexPosition = gl_Position;\n\n        if (all(equal(curr.xy, prev.xy))) {\n            prev.xy = curr.xy + normalize(curr.xy - currVertexPosition.xy);\n        }\n        if (all(equal(curr.xy, currVertexPosition.xy))) {\n            currVertexPosition.xy = curr.xy + normalize(curr.xy - prev.xy);\n        }\n        vec2 A = normalize(normalize(curr.xy - prev.xy) * uScreen);\n        vec2 B = normalize(normalize(currVertexPosition.xy - curr.xy) * uScreen);\n        vec2 tangent = normalize(A + B);\n        vec2 miter = vec2(-tangent.y, tangent.x);\n        vec2 normalA = vec2(-A.y, A.x);\n        float miterLength = 1.0 / dot(miter, normalA);\n        vec2 point = normalize(A - B);\n        if (miterLength > 10.0 && sign(aCorner.x * dot(miter, point)) > 0.0) {\n            currVertexPosition.xy = curr.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalA) / uScreen.xy;\n        } else {\n            currVertexPosition.xy = curr.xy + (aCorner.x * miter * uStrokeWidth * miterLength) / uScreen.xy;\n        }\n\n        if (all(equal(nextVertexPosition.xy, curr.xy))) {\n            curr.xy = nextVertexPosition.xy + normalize(nextVertexPosition.xy - nextNext.xy);\n        }\n        if (all(equal(nextVertexPosition.xy, nextNext.xy))) {\n            nextNext.xy = nextVertexPosition.xy + normalize(nextVertexPosition.xy - curr.xy);\n        }\n        vec2 C = normalize(normalize(nextVertexPosition.xy - curr.xy) * uScreen);\n        vec2 D = normalize(normalize(nextNext.xy - nextVertexPosition.xy) * uScreen);\n        vec2 tangentCD = normalize(C + D);\n        vec2 miterCD = vec2(-tangentCD.y, tangentCD.x);\n        vec2 normalC = vec2(-C.y, C.x);\n        float miterCDLength = 1.0 / dot(miterCD, normalC);\n        vec2 pointCD = normalize(C - D);\n        if (miterCDLength > 10.0 && sign(aCorner.x * dot(miterCD, pointCD)) > 0.0) {\n            nextVertexPosition.xy = nextVertexPosition.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalC) / uScreen.xy;\n        } else {\n            nextVertexPosition.xy = nextVertexPosition.xy + (aCorner.x * miterCD * uStrokeWidth * miterCDLength) / uScreen.xy;\n        }\n\n        gl_Position.xy = ((1.0 - aCorner.z) * currVertexPosition.xy) + (aCorner.z * nextVertexPosition.xy);"},z={header:"\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",body:"\n        vDefined = aDefined;\n        float isLow = (aCorner.y + 1.0) / 2.0;\n        float yValue = isLow * aLowValue + (1.0 - isLow) * aHighValue;\n\n        float isEdgeCorner = abs(aCorner.x);\n        float lineWidthXDirection = (1.0 - isEdgeCorner) * aCorner.z;\n        float lineWidthYDirection = isEdgeCorner * aCorner.z;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection) + (aBandwidth * aCorner.x / 2.0);\n        float yModifier = (uStrokeWidth * lineWidthYDirection);"},_={header:"\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aBaseValue;\n        attribute float aBaseNextValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        varying float vDefined;\n\n        float when_lt(float a, float b) {\n            return max(sign(b - a), 0.0);\n        }\n\n        float and(float a, float b) {\n            return a * b;\n        }",body:"\n        vDefined = aDefined * aDefinedNext;\n        gl_Position = vec4(0, 0, 0, 1);\n\n        float hasIntercepted = when_lt((aMainNextValue - aBaseNextValue) * (aMainValue - aBaseValue), 0.0);\n        float useIntercept = and(aCorner.z, hasIntercepted);\n\n        float yGradient = (aMainNextValue - aMainValue) / (aCrossNextValue - aCrossValue);\n        float yConstant = aMainNextValue - (yGradient * aCrossNextValue);\n\n        float y0Gradient = (aBaseNextValue - aBaseValue) / (aCrossNextValue - aCrossValue);\n        float y0Constant = aBaseNextValue - (y0Gradient * aCrossNextValue);\n\n        float denominator = (yGradient - y0Gradient) + step(abs(yGradient - y0Gradient), 0.0);\n        float interceptXValue = (y0Constant - yConstant) / denominator;\n        float interceptYValue = (yGradient * interceptXValue) + yConstant;\n\n        gl_Position = vec4(interceptXValue * useIntercept, interceptYValue * useIntercept, 0, 1);\n\n        gl_Position.x += (1.0 - useIntercept) * ((aCorner.x * aCrossNextValue) + ((1.0 - aCorner.x) * aCrossValue));\n        gl_Position.y += (1.0 - useIntercept) * (1.0 - aCorner.y) * ((aCorner.x * aMainNextValue) + ((1.0 - aCorner.x) * aMainValue));\n        gl_Position.y += (1.0 - useIntercept) * aCorner.y * ((aCorner.x * aBaseNextValue) + ((1.0 - aCorner.x) * aBaseValue));"},B={header:"\n        attribute vec4 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aCapWidth;\n        attribute float aHighValue;\n        attribute float aUpperQuartileValue;\n        attribute float aMedianValue;\n        attribute float aLowerQuartileValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;\n    ",body:"\n        vDefined = aDefined;\n        float isExtremeY = sign(abs(aCorner.y) - 2.0) + 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n\n        float isNonZeroY = abs(sign(aCorner.y));\n        float isZeroY = 1.0 - isNonZeroY;\n\n        float isQuartileY = isNotExtremeY * isNonZeroY;\n\n        float isPositiveY = (sign(aCorner.y + 0.5) + 1.0) / 2.0;\n        float isNegativeY = 1.0 - isPositiveY;\n\n        float yValue =\n          (isExtremeY * isNegativeY) * aHighValue +\n          (isQuartileY * isNegativeY) * aUpperQuartileValue +\n          isZeroY * aMedianValue +\n          (isQuartileY * isPositiveY) * aLowerQuartileValue +\n          (isExtremeY * isPositiveY) * aLowValue;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float isHorizontal = aCorner.w;\n        float isVertical = 1.0 - isHorizontal;\n\n        float xDisplacement = aCorner.x * (isExtremeY * aCapWidth + isNotExtremeY * aBandwidth) / 2.0;\n\n        float xModifier = (isVertical * uStrokeWidth * aCorner.z / 2.0) + xDisplacement;\n        float yModifier = isHorizontal * uStrokeWidth * aCorner.z / 2.0;"},I={header:"\n        varying float vSize;\n        varying float vDefined;",body:"\n        float canFill = 1.0;\n        float distance = length(2.0 * gl_PointCoord - 1.0);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"},w={header:"\n        varying float vSize;\n        varying float vDefined;\n\n        // anterior, exterior angles\n        float an = 0.628319;\n        vec2 acs = vec2(0.809017, 0.587786); // (cos, sin)\n        float en = 0.952000;\n        vec2 ecs = vec2(0.580055, 0.814577);\n    ",body:"\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        p -= acs;\n        p += ecs * clamp(-dot(p, ecs), 0.0, acs.y / ecs.y);\n        float d = length(p) * sign(p.x);\n\n        float distance = 1.0 + d;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"},Y={header:"\n        varying float vSize;\n        varying float vDefined;\n    ",body:"\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float an = 3.141593 / 3.0;\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        // box\n        vec2 d = abs(p) - vec2(0.9, 0.35);\n        float sdf = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n\n        float distance = 1.0 + sdf;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"},k={header:"\n        varying float vSize;\n        varying float vDefined;",body:"\n        float canFill = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float distance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);"},M={header:"\n        varying float vSize;\n        varying float vDefined;\n        float a = 0.6;\n        float b = 1.0;\n    ",body:"\n        if (vDefined < 0.5) {\n            discard;\n        }\n\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n\n        float x = abs(pointCoordTransform.x);\n        float y = abs(pointCoordTransform.y);\n\n        float X = (a * b * x) / (a * y + b * x);\n        float Y = (a * b * y) / (a * y + b * x);\n\n        float distance = length(vec2(x, y)) / length(vec2(X, Y));\n\n        if (distance > 1.0) {\n            discard;\n        }\n    "},H={header:"\n        varying float vSize;\n        varying float vDefined;",body:"\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float topEdgesDistance = abs(pointCoordTransform.x) - ((pointCoordTransform.y - 0.6) / sqrt(3.0));\n        float bottomEdgeDistance = pointCoordTransform.y + 0.5;\n        float distance = max(topEdgesDistance, bottomEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }"},T={header:"\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",body:"\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float innerCornerDistance = min(abs(pointCoordTransform.x), abs(pointCoordTransform.y)) + 0.66 - vStrokeWidthRatio;\n        float outerEdgeDistance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float distance = max(innerCornerDistance, outerEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }"},W={header:"\n        varying float vColorIndicator;\n        varying float vDefined;",body:"\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }"},F={header:"\n        varying float vColorIndicator;\n        varying float vDefined;",body:"\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }"},L={header:"\n        varying float vDefined;",body:"\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.86, 0.86, 0.86, 1);"},R={header:"\n        varying float vDefined;\n    ",body:"\n        float canFill = 0.0;\n        float canStroke = 1.0;\n\n        if (vDefined < 0.5) {\n            discard;\n        }"},O={header:"varying float vDefined;",body:"\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }"},G={header:"varying float vDefined;",body:"\n        float canFill = 1.0;\n        float canStroke = 0.0;\n\n        gl_FragColor = vec4(0.60, 0.60, 0.60, 1.0);\n\n        if (vDefined < 0.5) {\n            discard;\n        }"},U={header:"varying vec4 vFillColor;",body:"gl_FragColor = (canFill * vFillColor) + ((1.0 - canFill) * gl_FragColor);"},q={header:"varying vec4 vStrokeColor;",body:"gl_FragColor = (canStroke * vStrokeColor) + ((1.0 - canStroke) * gl_FragColor);"},X={header:"varying float vDefined;",body:"\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }"},Q=function(){var e=c(b),t=c(g);return e.appendHeader(_.header).appendBody(_.body),t.appendHeader(L.header).appendBody(L.body),{vertex:function(){return e},fragment:function(){return t}}},Z={BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,FLOAT:5126},j=function(){var e=-1,t=null,a=1,r=Z.FLOAT,i=!1,o=0,n=0,l=null,d=function(d){var f=d.context();null==t&&(t=f.createBuffer()),f.bindBuffer(f.ARRAY_BUFFER,t),f.vertexAttribPointer(e,a,r,i,o,n),f.enableVertexAttribArray(e);var u=d.extInstancedArrays();u.vertexAttribDivisorANGLE(e,null==l?0<d.subInstanceCount()?1:0:l)};return d.location=function(){return arguments.length?(e=0>=arguments.length?void 0:arguments[0],d):e},d.buffer=function(){return arguments.length?(t=0>=arguments.length?void 0:arguments[0],d):t},d.size=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],d):a},d.type=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],d):r},d.normalized=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],d):i},d.stride=function(){return arguments.length?(o=0>=arguments.length?void 0:arguments[0],d):o},d.offset=function(){return arguments.length?(n=0>=arguments.length?void 0:arguments[0],d):n},d.divisor=function(){return arguments.length?(l=0>=arguments.length?void 0:arguments[0],d):l},d},K=function(){var e=Z.FLOAT,t=new Float32Array(0),a=function(a){var r=o(e);return t.length>a?t=new r(t.buffer,0,a):t.length!==a&&(t=new r(a)),t};return a.type=function(){if(!arguments.length)return e;if(e!==(0>=arguments.length?void 0:arguments[0])){e=0>=arguments.length?void 0:arguments[0];var r=o(e);t=new r(0)}return a},a},J=function(){var e=!0,t=1,a=Z.FLOAT,r=K(),o=function(e){return e},n=null,l=function(){var l=n.length,d=r.type(a)(l*t);if(1<t)for(var f,u=0;u<l;u++){if(f=o(n[u],u),f.length!==t)throw new Error("Expected components array of size ".concat(t,", recieved array with length ").concat(f.length,"."));for(var s=0;s<t;s++)d[u*t+s]=f[s]}else for(var c,b=0;b<l;b++){if(c=o(n[b],b),Array.isArray(c))throw new Error("Expected a single component value, recieved array with length ".concat(c.length,"."));d[b]=c}return e=!1,d};return l.dirty=function(){return e},l.clear=function(){e=!0},l.size=function(){return arguments.length?(t=0>=arguments.length?void 0:arguments[0],e=!0,l):t},l.type=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],e=!0,l):a},l.arrayViewFactory=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],e=!0,l):r},l.value=function(){return arguments.length?(o=0>=arguments.length?void 0:arguments[0],e=!0,l):o},l.data=function(){return arguments.length?(n=0>=arguments.length?void 0:arguments[0],e=!0,l):n},l},$=function(){var e=j(),a=J(),r=function t(r){if(e.size(t.size()).type(t.type()),e(r),!!a.dirty()){var i=a(),o=r.context();o.bindBuffer(o.ARRAY_BUFFER,e.buffer()),o.bufferData(o.ARRAY_BUFFER,i,o.DYNAMIC_DRAW)}};return r.clear=function(){e.buffer(null),a.clear()},t.rebind(r,e,"normalized","location","divisor"),t.rebind(r,a,"data","value","size","type"),r},ee=function(e,t,a,r){for(var i=arguments.length,o=Array(4<i?i-4:0),n=4;n<i;n++)o[n-4]=arguments[n];e[t]=function(){for(var t=arguments.length,i=Array(t),n=0;n<t;n++)i[n]=arguments[n];var l=a[r].apply(a,o.concat(i));return l===a?e:l}},te=function(){var e=c(b),t=c(g);return e.appendHeader(y.header).appendBody(y.body),t.appendHeader(I.header).appendBody(I.body),{vertex:function(){return e},fragment:function(){return t}}},ae=function(){var e=c(b),t=c(g);return e.appendHeader(A.header).appendBody(A.body),t.appendHeader(X.header).appendBody(X.body),{vertex:function(){return e},fragment:function(){return t}}},re=function(){var e=1,t=function(t){t.buffers().uniform("uStrokeWidth",f(e))};return t.lineWidth=function(){return arguments.length?(e=0>=arguments.length?void 0:arguments[0],t):e},t},ie=function(e){var t=null,a=e,r=!0,i=function(e){var i=e.context();null==t&&(t=i.createBuffer()),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,t),r&&(i.bufferData(i.ELEMENT_ARRAY_BUFFER,new Uint16Array(a),i.STATIC_DRAW),r=!1)};return i.clear=function(){t=null,r=!0},i.data=function(){return arguments.length?(r=!0,a=0>=arguments.length?void 0:arguments[0],i):a},i},oe=function(){var e=c(b),t=c(g);return e.appendHeader(N.header).appendBody(N.body),t.appendHeader(F.header).appendBody(F.body),{vertex:function(){return e},fragment:function(){return t}}},ne=function(){var e=c(b),t=c(g);return e.appendHeader(E.header).appendBody(E.body),t.appendHeader(G.header).appendBody(G.body),{vertex:function(){return e},fragment:function(){return t}}},le=function(){var e=c(b),t=c(g);return e.appendHeader(z.header).appendBody(z.body),t.appendHeader(O.header).appendBody(O.body),{vertex:function(){return e},fragment:function(){return t}}},de=function(){var e=c(b),t=c(g);return e.appendHeader(D.header).appendBody(D.body),t.appendHeader(W.header).appendBody(W.body),{vertex:function(){return e},fragment:function(){return t}}},fe=function(){var e=c(b),t=c(g);return e.appendHeader(B.header).appendBody(B.body),t.appendHeader(R.header).appendBody(R.body),{vertex:function(){return e},fragment:function(){return t}}},ue=function(){var e=l(),a=function(e){return"linear".concat(e)},r=function t(r,i,o){r.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(a(o),"Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(a(o),"Scale;")).appendBody("".concat(i," = ").concat(i," + ").concat(a(o),"Offset;")).appendBody("".concat(i," = ").concat(i," * ").concat(a(o),"Scale;"));var n=e.domain()[1]-e.domain()[0],l=e.range()[1]-e.range()[0],d=e.range()[0]*(n/l)-e.domain()[0],u=[0,0,0,0],t=[1,1,1,1];u[o]=d,t[o]=l/n,r.buffers().uniform("".concat(a(o),"Offset"),f(u)).uniform("".concat(a(o),"Scale"),f(t))};return t.rebindAll(r,e),r},se=function(){function e(e,t){var a=Math.log10;return a(e)/a(t)}var a=l(),r=10,i=function(e){return"log".concat(e)},o=function t(o,n,l){var d="".concat(i(l),"Offset + (").concat(i(l),"Scale * clamp(log(").concat(n,") / log(").concat(i(l),"Base), -inf, inf))");o.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(i(l),"Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(l),"Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(l),"Include;")).appendHeaderIfNotExists("uniform float ".concat(i(l),"Base;")).appendBody("".concat(n," = (").concat(i(l),"Include * (").concat(d,")) + ((1.0 - ").concat(i(l),"Include) * ").concat(n,");"));var u=e(a.domain()[1],r)-e(a.domain()[0],r),s=a.range()[1]-a.range()[0],c=s/u,b=a.range()[0]-c*e(a.domain()[0],r),g=[0,0,0,0],t=[0,0,0,0],h=[0,0,0,0];g[l]=b,t[l]=c,h[l]=1,o.buffers().uniform("".concat(i(l),"Offset"),f(g)).uniform("".concat(i(l),"Scale"),f(t)).uniform("".concat(i(l),"Include"),f(h)).uniform("".concat(i(l),"Base"),f(r))};return o.base=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],o):r},t.rebindAll(o,a),o},ce=function(){function e(t,a){var e=Math.pow,r=Math.sign;return r(t)*e(n(t),a)}var a=l(),r=1,i=function(e){return"pow".concat(e)},o=function t(o,n,l){var d="".concat(i(l),"Offset + (").concat(i(l),"Scale * sign(").concat(n,") * pow(abs(").concat(n,"), vec4(").concat(i(l),"Exp)))");o.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(i(l),"Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(l),"Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(l),"Include;")).appendHeaderIfNotExists("uniform float ".concat(i(l),"Exp;")).appendBody("".concat(n," = (").concat(i(l),"Include * (").concat(d,")) + ((1.0 - ").concat(i(l),"Include) * ").concat(n,");"));var u=e(a.domain()[1],r)-e(a.domain()[0],r),s=a.range()[1]-a.range()[0],c=s/u,b=a.range()[0]-c*e(a.domain()[0],r),g=[0,0,0,0],t=[0,0,0,0],h=[0,0,0,0];g[l]=b,t[l]=c,h[l]=1,o.buffers().uniform("".concat(i(l),"Offset"),f(g)).uniform("".concat(i(l),"Scale"),f(t)).uniform("".concat(i(l),"Include"),f(h)).uniform("".concat(i(l),"Exp"),f(r))};return o.exponent=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],o):r},t.rebindAll(o,a),o},be=a.scaleLinear().copy.toString(),ge=a.scaleLog().copy.toString(),he=a.scalePow().copy.toString(),ve=a.scaleTime().copy.toString(),ye=a.scaleIdentity(),xe=function(){var e=c(b),t=c(g);return e.appendHeader(m.header).appendBody(m.body),t.appendHeader(k.header).appendBody(k.body),{vertex:function(){return e},fragment:function(){return t}}},pe=function(){var e=c(b),t=c(g);return e.appendHeader(V.header).appendBody(V.body),t.appendHeader(H.header).appendBody(H.body),{vertex:function(){return e},fragment:function(){return t}}},me=function(){var e=c(b),t=c(g);return e.appendHeader(C.header).appendBody(C.body),t.appendHeader(T.header).appendBody(T.body),{vertex:function(){return e},fragment:function(){return t}}},Se=function(){var e=c(b),t=c(g);return e.appendHeader(S.header).appendBody(S.body),t.appendHeader(M.header).appendBody(M.body),{vertex:function(){return e},fragment:function(){return t}}},Ve=function(){var e=c(b),t=c(g);return e.appendHeader(x.header).appendBody(x.body),t.appendHeader(w.header).appendBody(w.body),{vertex:function(){return e},fragment:function(){return t}}},Ce=function(){var e=c(b),t=c(g);return e.appendHeader(p.header).appendBody(p.body),t.appendHeader(Y.header).appendBody(Y.body),{vertex:function(){return e},fragment:function(){return t}}},De=function(e){var a=j().divisor(1),r=e,i=!0,o=function(e){if(a(e),!!i){if(!Array.isArray(r))throw new Error("Expected an array, received: ".concat(r));if(r.length!==a.size())throw new Error("Expected array of length: ".concat(a.size(),", recieved array of length: ").concat(r.length));var t=e.context();t["vertexAttrib".concat(r.length,"fv")](a.location(),r),t.disableVertexAttribArray(a.location()),i=!1}};return o.clear=function(){i=!0},o.value=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],i=!0,o):r},t.rebind(o,a,"normalized","size","location"),o};e.webglAdjacentAttribute=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;if(0<e||0>a)throw new Error("Offset values (".concat(e," & ").concat(a,") must straddle 0 "));var r=j(),o=J(),l=function t(l){var d=t.size()*i(t.type()),f=n(e)*d;if(r.offset(f).size(t.size()).type(t.type()),r(l),!!o.dirty()){var u=o(),s=f+u.length*i(t.type())+a*d,c=l.context();c.bindBuffer(c.ARRAY_BUFFER,r.buffer()),c.bufferData(c.ARRAY_BUFFER,s,c.DYNAMIC_DRAW),c.bufferSubData(c.ARRAY_BUFFER,f,u)}};return l.offset=function(o){if(e>o||o>a)throw new Error("Requested offset ".concat(o," exceeds bounds (").concat(e," & ").concat(a,") "));var n=function(t){r.offset((o-e)*l.size()*i(l.type())),r(t)};return t.rebind(n,l,"clear","location"),n},l.clear=function(){r.buffer(null),o.clear()},t.rebind(l,r,"normalized","location","divisor"),t.rebind(l,o,"data","value","size","type"),l},e.webglAttribute=$,e.webglBaseAttribute=j,e.webglBufferBuilder=d,e.webglElementIndices=ie,e.webglFillColor=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[0,0,0,1],a=$().size(4),r=e,i=!0,o=function(e){if(e.vertexShader().appendHeaderIfNotExists(h.header).appendBodyIfNotExists(h.body),e.fragmentShader().appendHeaderIfNotExists(U.header).appendBodyIfNotExists(U.body),Array.isArray(r))e.buffers().attribute("aFillColor",De(r).size(4));else if("function"==typeof r){if(!i)return;a.value(r),e.buffers().attribute("aFillColor",a)}else throw new Error("Expected value to be an array or function, received ".concat(r));i=!1};return o.value=function(){return arguments.length?(r!==(0>=arguments.length?void 0:arguments[0])&&(r=0>=arguments.length?void 0:arguments[0],i=!0),o):r},t.rebind(o,a,"data"),o},e.webglProgramBuilder=s,e.webglScaleLinear=ue,e.webglScaleLog=se,e.webglScaleMapper=function(e){switch(e.copy.toString()){case be:case ve:return{scale:ye,webglScale:ue().domain(e.domain())};case ge:return{scale:ye,webglScale:se().domain(e.domain()).base(e.base())};case he:return{scale:ye,webglScale:ce().domain(e.domain()).exponent(e.exponent())};default:return{scale:e.copy(),webglScale:ue().domain(e.range())};}},e.webglScalePow=ce,e.webglSeriesArea=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(6),a=l(),r=l(),i=function(){},o=$().divisor(0).size(3).type(Z.UNSIGNED_BYTE).data([[0,0,0],[0,1,0],[1,1,1],[0,0,1],[1,0,0],[1,1,0]]);e.buffers().attribute("aCorner",o);var n=function(t){var o=Q();e.vertexShader(o.vertex()).fragmentShader(o.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),i(e),e(t-1)};return n.decorate=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],n):i},n.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],n):a},n.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],n):r},t.rebind(n,e,"context"),ee(n,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(n,"crossNextValueAttribute",e.buffers(),"attribute","aCrossNextValue"),ee(n,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),ee(n,"mainNextValueAttribute",e.buffers(),"attribute","aMainNextValue"),ee(n,"baseValueAttribute",e.buffers(),"attribute","aBaseValue"),ee(n,"baseNextValueAttribute",e.buffers(),"attribute","aBaseNextValue"),ee(n,"definedAttribute",e.buffers(),"attribute","aDefined"),ee(n,"definedNextAttribute",e.buffers(),"attribute","aDefinedNext"),n},e.webglSeriesBar=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(6),a=l(),r=l(),i=function(){},o=$().divisor(0).size(2).type(Z.BYTE).data([[-1,-1],[1,1],[-1,1],[1,-1]]);e.buffers().elementIndices(ie([0,1,2,0,1,3])).attribute("aCorner",o);var n=function(t){var o=ne();e.vertexShader(o.vertex()).fragmentShader(o.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),e.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n        "),i(e),e(t)};return n.decorate=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],n):i},n.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],n):a},n.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],n):r},t.rebind(n,e,"context"),ee(n,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(n,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),ee(n,"baseValueAttribute",e.buffers(),"attribute","aBaseValue"),ee(n,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),ee(n,"definedAttribute",e.buffers(),"attribute","aDefined"),n},e.webglSeriesBoxPlot=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(54),a=l(),r=l(),i=function(){},o=re(),n=$().divisor(0).size(4).type(Z.BYTE).data([[-1,-2,-1,1],[1,-2,-1,1],[1,-2,1,1],[-1,-2,1,1],[0,-2,-1,0],[0,-2,1,0],[0,-1,1,0],[0,-1,-1,0],[-1,-1,-1,1],[1,-1,-1,1],[1,-1,1,1],[-1,-1,1,1],[-1,0,-1,1],[1,0,-1,1],[1,0,1,1],[-1,0,1,1],[-1,1,-1,1],[1,1,-1,1],[1,1,1,1],[-1,1,1,1],[-1,-1,-1,0],[-1,-1,1,0],[-1,1,1,0],[-1,1,-1,0],[1,-1,-1,0],[1,-1,1,0],[1,1,1,0],[1,1,-1,0],[0,2,-1,0],[0,2,1,0],[0,1,1,0],[0,1,-1,0],[-1,2,-1,1],[1,2,-1,1],[1,2,1,1],[-1,2,1,1]]);e.buffers().elementIndices(ie([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23,24,25,26,24,26,27,28,29,30,28,30,31,32,33,34,32,34,35])).attribute("aCorner",n);var d=function(t){var n=fe();e.vertexShader(n.vertex()).fragmentShader(n.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),o(e),e.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n            gl_Position.y += yModifier / uScreen.y * 2.0;\n        "),i(e),e(t)};return d.decorate=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],d):i},d.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],d):a},d.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],d):r},t.rebind(d,e,"context"),t.rebind(d,o,"lineWidth"),ee(d,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(d,"highValueAttribute",e.buffers(),"attribute","aHighValue"),ee(d,"upperQuartileValueAttribute",e.buffers(),"attribute","aUpperQuartileValue"),ee(d,"medianValueAttribute",e.buffers(),"attribute","aMedianValue"),ee(d,"lowerQuartileValueAttribute",e.buffers(),"attribute","aLowerQuartileValue"),ee(d,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),ee(d,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),ee(d,"capAttribute",e.buffers(),"attribute","aCapWidth"),ee(d,"definedAttribute",e.buffers(),"attribute","aDefined"),d},e.webglSeriesCandlestick=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(12),a=l(),r=l(),i=re(),o=function(){},n=$().divisor(0).size(3).type(Z.BYTE).data([[0,2,1],[0,2,-1],[0,-2,-1],[0,-2,1],[1,-1,0],[-1,-1,0],[-1,1,0],[1,1,0]]);e.buffers().elementIndices(ie([0,1,2,0,3,2,4,5,6,4,7,6])).attribute("aCorner",n);var d=function(t){var n=de();e.vertexShader(n.vertex()).fragmentShader(n.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),i(e),e.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x;\n          gl_Position.y += yModifier / uScreen.y;\n        "),o(e),e(t)};return d.decorate=function(){return arguments.length?(o=0>=arguments.length?void 0:arguments[0],d):o},d.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],d):a},d.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],d):r},t.rebind(d,e,"context"),t.rebind(d,i,"lineWidth"),ee(d,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(d,"openValueAttribute",e.buffers(),"attribute","aOpenValue"),ee(d,"highValueAttribute",e.buffers(),"attribute","aHighValue"),ee(d,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),ee(d,"closeValueAttribute",e.buffers(),"attribute","aCloseValue"),ee(d,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),ee(d,"definedAttribute",e.buffers(),"attribute","aDefined"),d},e.webglSeriesErrorBar=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(18),a=l(),r=l(),i=function(){},o=re(),n=$().divisor(0).size(3).type(Z.BYTE).data([[0,1,1],[0,1,-1],[0,-1,-1],[0,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1],[-1,-1,1],[-1,1,-1],[-1,1,1],[1,1,1],[1,1,-1]]);e.buffers().elementIndices(ie([0,1,2,0,3,2,4,5,6,4,7,6,8,9,10,8,11,10])).attribute("aCorner",n);var d=function(t){var n=le();e.vertexShader(n.vertex()).fragmentShader(n.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),o(e),e.vertexShader().appendBody("\n                gl_Position.x += xModifier / uScreen.x * 2.0;\n                gl_Position.y += yModifier / uScreen.y * 2.0;\n            "),i(e),e(t)};return d.decorate=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],d):i},d.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],d):a},d.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],d):r},t.rebind(d,e,"context"),t.rebind(d,o,"lineWidth"),ee(d,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(d,"highValueAttribute",e.buffers(),"attribute","aHighValue"),ee(d,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),ee(d,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),ee(d,"definedAttribute",e.buffers(),"attribute","aDefined"),d},e.webglSeriesLine=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(12),a=l(),r=l(),i=function(){},o=re(),n=$().divisor(0).size(3).type(Z.BYTE).data([[-1,0,0],[1,1,0],[1,-1,1],[-1,0,1],[1,1,1]]);e.buffers().elementIndices(ie([0,1,2,1,2,3,0,2,3,2,3,4])).attribute("aCorner",n);var d=function(t){var n=ae();e.vertexShader(n.vertex()).fragmentShader(n.fragment()),a(e,"prev",0),r(e,"prev",1),a(e,"curr",0),r(e,"curr",1),a(e,"gl_Position",0),r(e,"gl_Position",1),a(e,"nextNext",0),r(e,"nextNext",1),e.vertexShader().appendBody(P.body),o(e),i(e),e(t-1)};return d.decorate=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],d):i},d.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],d):a},d.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],d):r},t.rebind(d,e,"context"),t.rebind(d,o,"lineWidth"),ee(d,"crossPreviousValueAttribute",e.buffers(),"attribute","aCrossPrevValue"),ee(d,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(d,"crossNextValueAttribute",e.buffers(),"attribute","aCrossNextValue"),ee(d,"crossNextNextValueAttribute",e.buffers(),"attribute","aCrossNextNextValue"),ee(d,"mainPreviousValueAttribute",e.buffers(),"attribute","aMainPrevValue"),ee(d,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),ee(d,"mainNextValueAttribute",e.buffers(),"attribute","aMainNextValue"),ee(d,"mainNextNextValueAttribute",e.buffers(),"attribute","aMainNextNextValue"),ee(d,"definedAttribute",e.buffers(),"attribute","aDefined"),ee(d,"definedNextAttribute",e.buffers(),"attribute","aDefinedNext"),d},e.webglSeriesOhlc=function(){var e=s().mode(u.TRIANGLES).subInstanceCount(18),a=l(),r=l(),i=re(),o=function(){},n=$().divisor(0).size(3).type(Z.BYTE).data([[0,-2,-1],[0,-2,1],[0,2,1],[0,2,-1],[-1,-1,-1],[-1,-1,1],[0,-1,1],[0,-1,-1],[1,1,1],[0,1,1],[0,1,-1],[1,1,-1]]);e.buffers().elementIndices(ie([0,1,2,0,3,2,4,5,6,4,7,6,8,9,10,10,11,8])).attribute("aCorner",n);var d=function(t){var n=oe();e.vertexShader(n.vertex()).fragmentShader(n.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),i(e),e.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x;\n          gl_Position.y += yModifier / uScreen.y;\n        "),o(e),e(t)};return d.decorate=function(){return arguments.length?(o=0>=arguments.length?void 0:arguments[0],d):o},d.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],d):a},d.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],d):r},t.rebind(d,e,"context"),t.rebind(d,i,"lineWidth"),ee(d,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(d,"openValueAttribute",e.buffers(),"attribute","aOpenValue"),ee(d,"highValueAttribute",e.buffers(),"attribute","aHighValue"),ee(d,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),ee(d,"closeValueAttribute",e.buffers(),"attribute","aCloseValue"),ee(d,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),ee(d,"definedAttribute",e.buffers(),"attribute","aDefined"),d},e.webglSeriesPoint=function(){var e=s().mode(u.POINTS),a=l(),r=l(),i=te(),o=function(){},n=function(t){e.vertexShader(i.vertex()).fragmentShader(i.fragment()),a(e,"gl_Position",0),r(e,"gl_Position",1),o(e),e(t)};return n.type=function(){return arguments.length?(i=0>=arguments.length?void 0:arguments[0],n):i},n.decorate=function(){return arguments.length?(o=0>=arguments.length?void 0:arguments[0],n):o},n.xScale=function(){return arguments.length?(a=0>=arguments.length?void 0:arguments[0],n):a},n.yScale=function(){return arguments.length?(r=0>=arguments.length?void 0:arguments[0],n):r},t.rebind(n,e,"context"),ee(n,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),ee(n,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),ee(n,"sizeAttribute",e.buffers(),"attribute","aSize"),ee(n,"definedAttribute",e.buffers(),"attribute","aDefined"),n},e.webglShaderBuilder=c,e.webglStrokeColor=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[0,0,0,1],a=$().size(4),r=e,i=!0,o=function(e){if(e.vertexShader().appendHeaderIfNotExists(v.header).appendBodyIfNotExists(v.body),e.fragmentShader().appendHeaderIfNotExists(q.header).appendBodyIfNotExists(q.body),Array.isArray(r))e.buffers().attribute("aStrokeColor",De(r).size(4));else if("function"==typeof r){if(!i)return;a.value(r),e.buffers().attribute("aStrokeColor",a)}else throw new Error("Expected value to be an array or function, received ".concat(r));i=!1};return o.value=function(){return arguments.length?(r!==(0>=arguments.length?void 0:arguments[0])&&(r=0>=arguments.length?void 0:arguments[0],i=!0),o):r},t.rebind(o,a,"data"),o},e.webglSymbolMapper=function(e){switch(e){case r.symbolCircle:return te();case r.symbolSquare:return xe();case r.symbolTriangle:return pe();case r.symbolCross:return me();case r.symbolDiamond:return Se();case r.symbolStar:return Ve();case r.symbolWye:return Ce();default:throw new Error("Unrecognised symbol: ".concat(e));}},e.webglTypes=Z,e.webglUniform=f,Object.defineProperty(e,"__esModule",{value:!0})});
